<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tengine</title>
      <link href="2020/12/17/Tengine/"/>
      <url>2020/12/17/Tengine/</url>
      
        <content type="html"><![CDATA[<h3 id="getStarted"><a href="#getStarted" class="headerlink" title="getStarted"></a>getStarted</h3><h4 id="什么是tengine"><a href="#什么是tengine" class="headerlink" title="什么是tengine"></a>什么是tengine</h4><p>基于nginx，视为nginx加强版。是一个HTTP服务器、反向代理服务器以及负载均衡器。位于七层网路模型的第七层（看得见URL），后面讲的LVS位于第四层。</p><p>类似的HTTP服务器还有Apache的HTPPd，微软的lls。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx的优点：</span><br><span class="line"></span><br><span class="line">轻量级。</span><br><span class="line">抗并发，异步非阻塞IO模型。</span><br><span class="line">社区活跃。</span><br><span class="line">配置简洁。</span><br><span class="line">httpd的优点：</span><br><span class="line"></span><br><span class="line">apachehttpd的优点</span><br><span class="line">成熟，模块多，bug少。</span><br><span class="line">urlRewrite十分成熟。</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    和nginx一样</p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter接口压力测试</title>
      <link href="2020/12/16/jmeter%E6%8E%A5%E5%8F%A3%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
      <url>2020/12/16/jmeter%E6%8E%A5%E5%8F%A3%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="GetStarted"><a href="#GetStarted" class="headerlink" title="GetStarted"></a>GetStarted</h3><h4 id="常用压测工具"><a href="#常用压测工具" class="headerlink" title="常用压测工具"></a>常用压测工具</h4><ul><li>loadrunner</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多</span><br></pre></td></tr></table></figure><ul><li>apache ab(单接口压测最方便)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等</span><br></pre></td></tr></table></figure><ul><li>webbench</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</span><br></pre></td></tr></table></figure><h4 id="jmeter基本介绍"><a href="#jmeter基本介绍" class="headerlink" title="jmeter基本介绍"></a>jmeter基本介绍</h4><ul><li>压测不同的协议和应用</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …)</span><br><span class="line">2) SOAP &#x2F; REST Webservices</span><br><span class="line">3) FTP</span><br><span class="line">4) Database via JDBC</span><br><span class="line">5) LDAP  轻量目录访问协议</span><br><span class="line">6) Message-oriented middleware (MOM) via JMS</span><br><span class="line"> 7) Mail - SMTP(S), POP3(S) and IMAP(S)</span><br><span class="line">8) TCP等等</span><br></pre></td></tr></table></figure><ul><li>使用场景及优点</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）功能测试</span><br><span class="line">2）压力测试</span><br><span class="line">3）分布式压力测试</span><br><span class="line">4）纯java开发</span><br><span class="line">5）上手容易，高性能</span><br><span class="line">4）提供测试数据分析</span><br><span class="line">5）各种报表数据图形展示</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle学习笔记</title>
      <link href="2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><p>Windows10+Oracle11g +Oracle Developer19.2</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><h5 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--为表添加注释</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">TABLE</span> EAMP <span class="keyword">IS</span> <span class="string">&#x27;雇员表&#x27;</span>;</span><br><span class="line"><span class="comment">--为列添加注释</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> COLLUMN EMP.EMPNO <span class="keyword">IS</span> <span class="string">&#x27;雇员工号&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><ul><li>海量数据操作</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据泵 \  SQL Loader\ 外部表</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--delete  truncate drop</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp  ; <span class="comment">--可以回退</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> emp  ;<span class="comment">--不能回退</span></span><br><span class="line"><span class="comment">--原因： DML：insert  update  delete  -&gt;可以回退</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试二者执行时间</span><br><span class="line">打开执行时间：</span><br><span class="line">set timing on&#x2F;off</span><br><span class="line">对于少量数据： delete 效率高  ，一行一行删除</span><br><span class="line">对于海量数据：truncate效率高 ，  a.drop table 丢弃整张表 ，b.重新创建表</span><br><span class="line">delete支持闪回， truncate不支持闪回</span><br><span class="line">delete不会释放空间 （换两个地方存储数据[undo空间]），trucante会</span><br><span class="line">delete会产生碎片，trunate不会</span><br><span class="line">如果碎片太多，需要整理碎片：a.  alter table 表名 move ;  b.导出导入</span><br></pre></td></tr></table></figure><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><ul><li>追加新列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytab6 <span class="keyword">add</span> myother <span class="built_in">varchar2</span>(<span class="number">10</span>) ;</span><br></pre></td></tr></table></figure><ul><li>修改列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--修改列的长度</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytab6 <span class="keyword">modify</span>  myother <span class="built_in">varchar2</span>(<span class="number">20</span>) ;</span><br><span class="line"><span class="comment">--修改列的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytab6 <span class="keyword">modify</span>  myother <span class="built_in">number</span> ;</span><br><span class="line"><span class="comment">--注意： blob/clob不能修改  -&gt;先删除此列，重新追加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytab6 <span class="keyword">add</span> myother2 <span class="built_in">blob</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytab6 <span class="keyword">modify</span>  myother2 <span class="built_in">number</span> ;</span><br></pre></td></tr></table></figure><ul><li>删除列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytab6 <span class="keyword">drop</span> <span class="keyword">column</span> myother2 ;</span><br></pre></td></tr></table></figure><ul><li>重命名列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytab6 <span class="keyword">rename</span> <span class="keyword">column</span> myother <span class="keyword">to</span> myother3 ;</span><br></pre></td></tr></table></figure><h5 id="oracle主键"><a href="#oracle主键" class="headerlink" title="oracle主键"></a>oracle主键</h5><ul><li>主键类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">检查约束（<span class="keyword">check</span>）           <span class="keyword">name</span> &gt; <span class="number">4</span> </span><br><span class="line">唯一约束（<span class="keyword">Unique</span>）          <span class="keyword">id</span>:<span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span> <span class="number">4</span>  <span class="literal">null</span> </span><br><span class="line">主键约束（Primary <span class="keyword">key</span>）     类似唯一约束(唯一) </span><br><span class="line">外键约束（<span class="keyword">Foreign</span> <span class="keyword">Key</span>）      两张表 学生表   课程表(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">非空约束(<span class="keyword">Not</span> <span class="literal">null</span>)          不能为<span class="literal">null</span></span><br><span class="line">默认约束（<span class="keyword">Default</span>）         adress:   西安</span><br></pre></td></tr></table></figure><p>举个栗子（列级约束）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"> stuno <span class="built_in">number</span>(<span class="number">3</span>) primary <span class="keyword">key</span>  ,</span><br><span class="line"> stuname <span class="built_in">varchar2</span>(<span class="number">10</span>) <span class="keyword">unique</span>  ,</span><br><span class="line"> stuaddress <span class="built_in">varchar2</span>(<span class="number">20</span>)  <span class="keyword">default</span> <span class="string">&#x27;陕西西安&#x27;</span> <span class="keyword">check</span>(<span class="keyword">length</span>(stuaddress)&gt;<span class="number">2</span>) ,</span><br><span class="line"> stubid <span class="built_in">number</span>(<span class="number">3</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>增加约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add constraint 约束名  约束类型</span><br></pre></td></tr></table></figure><ul><li>eg</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student4(</span><br><span class="line"> stuno <span class="built_in">number</span>(<span class="number">3</span>) ,</span><br><span class="line"> stuname <span class="built_in">varchar2</span>(<span class="number">10</span>)  ,</span><br><span class="line"> stuaddress <span class="built_in">varchar2</span>(<span class="number">20</span>) ,</span><br><span class="line"> subid <span class="built_in">number</span>(<span class="number">3</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student4 <span class="keyword">add</span> <span class="keyword">constraint</span> UQ_stuaddress4  <span class="keyword">unique</span>(stuaddress);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student4 <span class="keyword">add</span> <span class="keyword">constraint</span> PK_stuno4  primary <span class="keyword">key</span> (stuno );</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student4 <span class="keyword">add</span> <span class="keyword">constraint</span> CK_stuname4  <span class="keyword">check</span>(<span class="keyword">length</span>(stuname)&gt;<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student4 <span class="keyword">add</span> <span class="keyword">constraint</span> FK_student4_sub   <span class="keyword">foreign</span> <span class="keyword">key</span>(subid) <span class="keyword">references</span> sub(<span class="keyword">sid</span>);</span><br></pre></td></tr></table></figure></li><li><p>约束命名</p><ul><li>规范：约束类型字段名</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主键：PK_stuno</span><br><span class="line">检查约束：  CK字段名</span><br><span class="line">唯一约束： UQ字段名</span><br><span class="line">非空约束：  NN字段名</span><br><span class="line">外键约束：  FK_子表_父表</span><br><span class="line">默认约束： 一般不需要命名</span><br><span class="line">加约束名： constraint 约束名 </span><br></pre></td></tr></table></figure><ul><li>举个栗子</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"> stuno <span class="built_in">number</span>(<span class="number">3</span>) <span class="keyword">constraint</span> PK_stuno    primary <span class="keyword">key</span>  ,</span><br><span class="line"> stuname <span class="built_in">varchar2</span>(<span class="number">10</span>) <span class="keyword">constraint</span> NN_stuname  <span class="keyword">not</span> <span class="literal">null</span>  <span class="keyword">constraint</span>  UQ_stuname  <span class="keyword">unique</span> ,</span><br><span class="line"> stuaddress <span class="built_in">varchar2</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;陕西西安&#x27;</span> <span class="keyword">constraint</span> CK_stuaddress  <span class="keyword">check</span>(<span class="keyword">length</span>(stuaddress)&gt;<span class="number">2</span>),</span><br><span class="line"> stubid <span class="built_in">number</span>(<span class="number">3</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>表级约束</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student2(</span><br><span class="line"> stuno <span class="built_in">number</span>(<span class="number">3</span>) ,</span><br><span class="line"> stuname <span class="built_in">varchar2</span>(<span class="number">10</span>)  ,</span><br><span class="line"> stuaddress <span class="built_in">varchar2</span>(<span class="number">20</span>) ,</span><br><span class="line"> stubid <span class="built_in">number</span>(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">constraint</span> PK_sno primary <span class="keyword">key</span>(stuno) ,</span><br><span class="line">  <span class="keyword">constraint</span> UQ_sname_subid <span class="keyword">unique</span>(stuname,stubid),</span><br><span class="line">  <span class="keyword">constraint</span> CK_saddress <span class="keyword">check</span>( <span class="keyword">length</span>(stuAddress)&gt;<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h5 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h5><ul><li><p>级联删除和级联置空</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student3;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student3(</span><br><span class="line"> stuno <span class="built_in">number</span>(<span class="number">3</span>) ,</span><br><span class="line"> stuname <span class="built_in">varchar2</span>(<span class="number">10</span>)  ,</span><br><span class="line"> stuaddress <span class="built_in">varchar2</span>(<span class="number">20</span>) ,</span><br><span class="line"> subid <span class="built_in">number</span>(<span class="number">3</span>)  ,</span><br><span class="line"> <span class="keyword">constraint</span> FK_student3_sub <span class="keyword">foreign</span> <span class="keyword">key</span>(subid) <span class="keyword">references</span> sub(<span class="keyword">sid</span>)  <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- on delete cascade表示级联删除</span></span><br><span class="line"><span class="comment">-- 换成on delete set null 表示级联置空</span></span><br><span class="line"><span class="comment">-- 级联删除：当删除父表中的数据时，子表 会跟着删除相对应的数据；</span></span><br><span class="line"><span class="comment">-- 级联置空：当删除父表中的数据时，子表 会将 相对应的 那一字段的值设置为Null，其他字段不影响；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><h5 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h5><ul><li>去重查询</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct deptno from emp</span><br></pre></td></tr></table></figure><ul><li>连接符</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;hello&#39;||&#39;world&#39; from dual;</span><br></pre></td></tr></table></figure><ul><li>模糊查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--姓名中第二个字母是M的员工信息：</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span>  <span class="string">&#x27;_M%&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--姓名中包含M的员工信息：</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span>  <span class="string">&#x27;%M%&#x27;</span> ;</span><br><span class="line"><span class="comment">--姓名长度&gt;6的员工信息：   &gt;6  &gt;=7</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span>  <span class="string">&#x27;_______%&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--姓名中包含下划线的 </span></span><br><span class="line">zhang_san</span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> ename  <span class="keyword">like</span> <span class="string">&#x27;%\_%&#x27;</span>  escape <span class="string">&#x27;\&#x27;</span> ;  </span><br><span class="line"></span><br><span class="line"><span class="comment">--not  in 不能出现null：如果出现了null，结果为null</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="literal">null</span>) ;</span><br></pre></td></tr></table></figure><ul><li>排序</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--order by 字段名|表达式|序号</span><br><span class="line">select *from emp order by sal desc ;--默认asc升序</span><br></pre></td></tr></table></figure><ul><li>对null的处理</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">nvl:if</span><br><span class="line">nvl(comm,0 )</span><br><span class="line"></span><br><span class="line">nvl2:if...else</span><br><span class="line">nvl2(comm,comm,0)</span><br><span class="line">if(comm==null)  return 0</span><br><span class="line">else   return comm</span><br></pre></td></tr></table></figure><p>​    NULL:自身特性： 如果!=NULL则无法查询出任何数据 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询 不是领导的员工信息（子查询时排除NULL）</span></span><br><span class="line"><span class="comment">--不是领导：判断empno 是否存在于mgr中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> empno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> mgr <span class="keyword">from</span> emp <span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> )</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>单行函数： 字符函数  数值函数  日期函数  转换函数 通用函数</p><ul><li><p>时间日期函数</p><ul><li>时间函数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select current_time() from dual;---- mysql:时间。 </span><br><span class="line">select current_date() form dual;  ---mysql；日期  </span><br><span class="line">select current_timestamp() from dual;---mysql：日期时间  </span><br></pre></td></tr></table></figure><ul><li>sysdate：当前时间</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--计算员工工龄 ：入职日期 天 星期 月 年</span><br><span class="line">select ename ,hiredate , (sysdate - hiredate) , (sysdate - hiredate)&#x2F;7 , (sysdate - hiredate)&#x2F;30, (sysdate - hiredate)&#x2F;365 from emp;</span><br></pre></td></tr></table></figure><ul><li><p>months_between(日期1,日期2) ： 日期1和日期2之间相差的月份</p></li><li><p>add_months(日期,月数)：返回加上x月后的日期d的值 </p></li><li><p>当前最大是第几天： last_day</p></li><li><p>下一个星期n是哪一天next_day</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select next_day(sysdate,&#39;星期五&#39;) from dual ;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数字函数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">round（number，n）<span class="comment">--返回四舍五入后的值  </span></span><br><span class="line"></span><br><span class="line">trunc（number，n）</span><br><span class="line"></span><br><span class="line">mod（x，y）求余数</span><br><span class="line"></span><br><span class="line">ceil()上取整 </span><br><span class="line"></span><br><span class="line">floor()下取整  </span><br></pre></td></tr></table></figure></li><li><p>转换函数</p><ul><li><p>TO_CHAR</p><p>操作日期</p><table><thead><tr><th>格式元素</th><th>含义</th></tr></thead><tbody><tr><td>YYYY</td><td>代表四位、两位数字的年份</td></tr><tr><td>YYMM</td><td>用数字表示的月份</td></tr><tr><td>MON</td><td>月份的缩写、对中文月份来说就是全称</td></tr><tr><td>DD</td><td>数字表示的日</td></tr><tr><td>DY</td><td>星期的缩写，对中文的星期来说就是全称</td></tr><tr><td>HH24、HH12</td><td>12小时或者24小时进制下的时间</td></tr><tr><td>Ml</td><td>分钟数</td></tr><tr><td>ss</td><td>秒数</td></tr></tbody></table></li></ul><p>eg：select sysdate, to_char(sysdate,’yyyy-mon-dd hh12:mi:ss’) from dual; </p><ul><li><p>操作数字</p><table><thead><tr><th>控制符</th><th>含义</th></tr></thead><tbody><tr><td>9</td><td>代表一位数字，如果该位没有数字则不进行显示，但对于小数点后面的部分仍会强制显示</td></tr><tr><td>0</td><td>代表一位数字，如果该位没有数字则强制显示0</td></tr><tr><td>￥</td><td>显示美元符号</td></tr><tr><td>L</td><td>显示本地货币符号</td></tr><tr><td>.</td><td>显示小数点</td></tr><tr><td>,</td><td>显示千分位符号</td></tr></tbody></table></li><li><p>to_number &amp; to_date </p></li></ul></li><li><p>coalesce :从左往后 找到第一个不为null的值</p></li><li><p>条件判断函数</p><ul><li><p>decode(字段,条件1，返回值1，条件2，返回2，….,最后表达式)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select ename,job , sal 涨前,  decode(job, &#39;PRESIDENT&#39;,sal+1000,&#39;MANAGER&#39;,sal+500,sal+300) 涨后 FROM EMP;</span><br></pre></td></tr></table></figure></li><li><p>case表达式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select ename ,job ,sal  涨前,case job </span><br><span class="line">when  &#39;PRESIDENT&#39; then sal+1000</span><br><span class="line">when  &#39;MANAGER&#39; then sal+500</span><br><span class="line">else  sal + 300 end</span><br><span class="line">涨后 </span><br><span class="line">from emp ; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符函数</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">substr(str,begin,len)  --从1开始数</span><br><span class="line"></span><br><span class="line">length --字符数  </span><br><span class="line">lengthb --字节数</span><br><span class="line"></span><br><span class="line">lpad&#x2F; rpad：--填充</span><br><span class="line">trim --去掉任意字符</span><br><span class="line"></span><br><span class="line">Instr（）--字符串出现的位置, instr（ string ，’A‘） </span><br><span class="line">replace --替换</span><br></pre></td></tr></table></figure><ul><li>数值函数</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">round() <span class="comment">--round(数字,n位数):四舍五入  ，保留n位小数</span></span><br><span class="line">trunc() <span class="comment">--trunc(数字,n位数):舍尾，保留n位小数</span></span><br><span class="line"></span><br><span class="line">mod() <span class="comment">--取模</span></span><br></pre></td></tr></table></figure><p>多行函数：组函数、 聚合函数</p><p>//我直接TM省略，和mysql大差不差????</p><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><ul><li>交叉连接(笛卡尔积)</li><li>内连接</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;多张表通过  相同字段进行匹配，只显示匹配成功的数据</span><br><span class="line">select * from emp e ,dept d</span><br><span class="line">where e.deptno &#x3D; d.deptno ;</span><br></pre></td></tr></table></figure><p>不等值连接(用的少)</p><ul><li>左外连接</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp e ,dept d</span><br><span class="line">where e.deptno &#x3D; d.deptno(+) ;</span><br></pre></td></tr></table></figure><ul><li>右外连接</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp e</span><br><span class="line">left outer join dept d</span><br><span class="line">on e.deptno(+) &#x3D; d.deptno </span><br></pre></td></tr></table></figure><ul><li><p>全外连接</p><p> 左外 + 右外连接 - 去重</p></li><li><p>自连接</p><p>将一张表 通过别名 “视为”不同的表</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询 员工姓名，以及 该员工的领导姓名</span><br><span class="line">select e.ename ,b.ename from emp e,emp b</span><br><span class="line">where e.mgr &#x3D;b.empno;</span><br></pre></td></tr></table></figure><h5 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5><ul><li>层次连接</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select level ,empno, ename ,mgr from emp </span><br><span class="line">connect by prior  empno&#x3D;mgr</span><br><span class="line">start with mgr is null</span><br><span class="line">order by level ;</span><br></pre></td></tr></table></figure><ul><li><p>子查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from emp  where sal &gt; (select SAL from emp where ename &#x3D; &#39;SCOTT&#39; )</span><br></pre></td></tr></table></figure><ul><li>分组查询</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select deptno,min(sal) from emp  </span><br><span class="line">group by deptno</span><br><span class="line">having min(sal) &gt; ( select min(sal) from emp where deptno &#x3D;10  );</span><br></pre></td></tr></table></figure><ul><li>增强group by：rollup()</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,job ,<span class="keyword">sum</span>(sal)   <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">rollup</span>( deptno,job) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--group by  rollup( a,b)相当于：</span></span><br><span class="line"><span class="comment">--group by a,b</span></span><br><span class="line"><span class="comment">--group by a,</span></span><br><span class="line"><span class="comment">--group by null </span></span><br></pre></td></tr></table></figure></li></ul><ul><li>修改oracle默认日期格式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter session set NLS_DATE_FORMAT &#x3D; &#39;yyyy-mm-dd&#39; ;</span><br><span class="line"></span><br><span class="line">alter session set NLS_DATE_FORMAT &#x3D; &#39;DD-MON-RR&#39; ;</span><br></pre></td></tr></table></figure><ul><li>范围查询</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--必须</span><br><span class="line">between  小 and  大</span><br></pre></td></tr></table></figure><ul><li>模糊查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--姓名中包含下划线的 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> ename  <span class="keyword">like</span> <span class="string">&#x27;%\_%&#x27;</span>  escape <span class="string">&#x27;\&#x27;</span> ;  </span><br><span class="line"></span><br><span class="line"><span class="comment">--not  in 不能出现null：如果出现了null，结果为null</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="literal">null</span>) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看当前系统编码格式：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> nls_database_parameters ;</span><br></pre></td></tr></table></figure><h4 id="PLSQL"><a href="#PLSQL" class="headerlink" title="PLSQL"></a>PLSQL</h4><h5 id="Helleo-World"><a href="#Helleo-World" class="headerlink" title="Helleo World"></a>Helleo World</h5><ul><li>代码</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--打开之后才能执行</span><br><span class="line">set serveroutput on;</span><br><span class="line"></span><br><span class="line">--declare 定义变量、常量、光标（游标除外）、例外（自定义异常）</span><br><span class="line">declare</span><br><span class="line">--先变量名 再变量类型</span><br><span class="line"></span><br><span class="line">-- :&#x3D;为赋值符号,</span><br><span class="line">psex char(3) :&#x3D;&#39;男&#39;;</span><br><span class="line"></span><br><span class="line">--可以先声明不赋值</span><br><span class="line">pname varchar2(10);</span><br><span class="line"></span><br><span class="line">--引用型(类型和emp表的empname字段保持一致, 推荐使用)</span><br><span class="line">pname emp.empname%type;</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">dmbs_output.put_line(&#39;Hello World&#39;);</span><br><span class="line">end;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>another eg</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set serveroutput on ;</span><br><span class="line">declare</span><br><span class="line">pnum number :&#x3D; 3 ;</span><br><span class="line">    </span><br><span class="line">begin</span><br><span class="line">    if pnum&#x3D;1   then   dbms_output.put_line(&#39;一&#39;);</span><br><span class="line">    elsif pnum&#x3D;2  then   dbms_output.put_line(&#39;二&#39;);</span><br><span class="line">    else dbms_output.put_line(&#39;其他&#39;);</span><br><span class="line">    end if ;   </span><br><span class="line">    </span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><ul><li>loop示例</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set serveroutput on ;</span><br><span class="line">declare</span><br><span class="line">    pnum number:&#x3D;1 ;</span><br><span class="line">        psum number:&#x3D; 0 ;</span><br><span class="line">begin</span><br><span class="line">        loop</span><br><span class="line">            exit when pnum &gt;5 ;</span><br><span class="line">            psum :&#x3D; psum + pnum ; --sum+&#x3D; i ;</span><br><span class="line">            pnum :&#x3D; pnum +1 ;</span><br><span class="line">        end loop ;</span><br><span class="line">        dbms_output.put_line(psum);</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><ul><li>语法</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create  procedure 过程名</span><br><span class="line">&#x2F;*</span><br><span class="line">参数列表，可以无参</span><br><span class="line">参数名 出&#x2F;入参参数类型;</span><br><span class="line">IN是入参，OUT是出参</span><br><span class="line">O_TEST IN NUMBER;</span><br><span class="line">IN_TESTOUTNUMBER;</span><br><span class="line">*&#x2F;</span><br><span class="line">as</span><br><span class="line">&#x2F;*</span><br><span class="line">定义参数</span><br><span class="line"></span><br><span class="line">V_TESTNUMBER(4);</span><br><span class="line">V_TEST2VARCHAR2(10)</span><br><span class="line">*&#x2F;</span><br><span class="line">begin </span><br><span class="line">&#x2F;*</span><br><span class="line">plsql语句</span><br><span class="line">*&#x2F;</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--存储过程： 传入员工编号，返回姓名、工作</span><br><span class="line">create or replace procedure getEmpInfo(pempno in emp.empno%type, pename out emp.ename%type, pjob out emp.job%type )</span><br><span class="line">as</span><br><span class="line">   </span><br><span class="line">begin </span><br><span class="line">    select ename  ,job into pename ,pjob from emp where empno &#x3D; pempno;</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><h5 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h5><ul><li>语法</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义</span><br><span class="line">cursor 光标名(参数列表)</span><br><span class="line">is</span><br><span class="line">select ....</span><br></pre></td></tr></table></figure><ul><li>光标的属性</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%isopen  %rowcount%found%notfound </span><br></pre></td></tr></table></figure><ul><li>示例1</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--查询并打印全部员工的姓名、薪水</span><br><span class="line">set serveroutput on ;</span><br><span class="line">declare</span><br><span class="line">--变量、常量、光标（游标）、例外（自定义异常）</span><br><span class="line">  cursor cemp  is select ename ,sal from emp ;</span><br><span class="line">  pename emp.ename%type ; </span><br><span class="line">  psal emp.sal%type ;</span><br><span class="line">  </span><br><span class="line">begin</span><br><span class="line">      open cemp ;--1.打开光标</span><br><span class="line">      loop    --2.循环 准备获取每一行数据</span><br><span class="line">         fetch  cemp  into pename,psal ;--3.一行一行获取光标的值</span><br><span class="line">         exit when cemp%notfound ;</span><br><span class="line">         </span><br><span class="line">         dbms_output.put_line(pename||&#39;的工资是：&#39;||psal);</span><br><span class="line">         </span><br><span class="line">      end loop ;</span><br><span class="line">      close cemp ;--关闭光标</span><br><span class="line">    </span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><ul><li>示例2</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--涨工资。 每个10%， 按入职时间顺序涨工资，且涨后的总工资不能超过5万。计算 需要涨工资的人个数 以及涨后的工资总额。</span><br><span class="line"></span><br><span class="line">set serveroutput on ;</span><br><span class="line"></span><br><span class="line">declare </span><br><span class="line"> cursor cemp is select empno,sal from emp order by hiredate asc ;</span><br><span class="line"> pempno emp.empno%type ;</span><br><span class="line"> psal emp.sal%type ;</span><br><span class="line"> countEmp number :&#x3D;0 ;</span><br><span class="line"> salTotal number :&#x3D;0 ;</span><br><span class="line">  </span><br><span class="line">begin </span><br><span class="line">    OPEN cemp ;</span><br><span class="line">    loop </span><br><span class="line">        </span><br><span class="line">        --exit when salTotal &gt; 50000 ;--  5.1</span><br><span class="line">        </span><br><span class="line">        fetch cemp into pempno ,psal ;</span><br><span class="line">        exit when cemp%notfound ;</span><br><span class="line">        </span><br><span class="line">        if salTotal + psal*1.1 &lt; 50000</span><br><span class="line">            --涨工资</span><br><span class="line">           then  update emp set sal &#x3D; sal*1.1 where empno &#x3D; pempno;</span><br><span class="line">           countEmp :&#x3D; countEmp +1;</span><br><span class="line">            --salTotal: 50  ,51 </span><br><span class="line">            salTotal :&#x3D; salTotal + psal*1.1 ;  --psal 是变量， sal是表的字段</span><br><span class="line">        else </span><br><span class="line">            dbms_output.put_line(&#39;人数&#39;||countEmp ||&#39;--&#39;|| &#39;涨后的总额&#39;||salTotal);</span><br><span class="line">        </span><br><span class="line">            exit  ;</span><br><span class="line">        </span><br><span class="line">        end if ;</span><br><span class="line">    </span><br><span class="line">    end loop ;</span><br><span class="line"> </span><br><span class="line">    close cemp ;</span><br><span class="line"></span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><ul><li>示例3</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*统计各部门的工资情况。格式如下</span><br><span class="line">部门编号&lt;2000的人数2000-4000人数&gt;4000人数工资总额</span><br><span class="line">count1count2count3salTotal</span><br><span class="line"></span><br><span class="line">光标保存各个部门：10  20  30*&#x2F;</span><br><span class="line">set serveroutput on ;</span><br><span class="line"></span><br><span class="line">declare </span><br><span class="line">    cursor cdept is select deptno from dept ;--10  20 30 40</span><br><span class="line">    pdeptno dept.deptno%type ;</span><br><span class="line">    </span><br><span class="line">    --部门中员工的所有工资</span><br><span class="line">    cursor cemp(dno number) is select sal from emp where deptno &#x3D; dno;</span><br><span class="line">    psal emp.sal%type ;</span><br><span class="line">    </span><br><span class="line">    count1 number;</span><br><span class="line">    count2 number;</span><br><span class="line">    count3 number ;</span><br><span class="line">    </span><br><span class="line">    --各部门工资总额</span><br><span class="line">    salTotal number ;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">begin </span><br><span class="line">    open  cdept;</span><br><span class="line">    loop  --外层循环：遍历所有的部门 编号；；内层循环：遍历某个部门的所有工资</span><br><span class="line">        fetch cdept into pdeptno ;</span><br><span class="line">        exit when cdept%notfound ;</span><br><span class="line">        count1 :&#x3D;0 ;</span><br><span class="line">        count2 :&#x3D;0 ;</span><br><span class="line">        count3 :&#x3D;0 ;</span><br><span class="line">        select sum(sal) into salTotal from emp where deptno &#x3D;pdeptno ;</span><br><span class="line">        open  cemp(pdeptno) ;</span><br><span class="line">            loop</span><br><span class="line">                fetch cemp into psal ;</span><br><span class="line">                exit when cemp%notfound ;</span><br><span class="line">                if psal&lt;2000 then count1:&#x3D;count1+1;</span><br><span class="line">                elsif psal&gt;&#x3D;2000 and psal&lt;4000 then  count2:&#x3D;count2+1;</span><br><span class="line">                else count3:&#x3D; count3+1 ;</span><br><span class="line">                end if ;                </span><br><span class="line">            end loop ;       </span><br><span class="line">        </span><br><span class="line">        close cemp ;</span><br><span class="line">        dbms_output.put_line(pdeptno||&#39; &#39;||count1||&#39; &#39;||count2||&#39; &#39;||count3||&#39; &#39;||salTotal);     </span><br><span class="line">        </span><br><span class="line">    end loop;</span><br><span class="line">    </span><br><span class="line">    close cdept;</span><br><span class="line"></span><br><span class="line">end ;</span><br><span class="line"></span><br><span class="line">public void hellworld()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="例外（异常）"><a href="#例外（异常）" class="headerlink" title="例外（异常）"></a>例外（异常）</h5><ul><li>系统例外<pre><code>no_data_found       too_many_rows   zero_Divide  value_error:算术或转换错误  timeout_on_resource：资源等待超时</code></pre></li><li>示例1</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set serveroutput on ;</span><br><span class="line">declare </span><br><span class="line">   pnum number ;</span><br><span class="line">   </span><br><span class="line">begin </span><br><span class="line"></span><br><span class="line">   pnum :&#x3D; 1&#x2F;0 ;</span><br><span class="line">   </span><br><span class="line">   exception </span><br><span class="line">     when zero_divide then dbms_output.put_line(&#39;0不能作为除数&#39;);</span><br><span class="line">     when too_many_rows then dbms_output.put_line(&#39;行数太多&#39;);</span><br><span class="line">     when others then dbms_output.put_line(&#39;其他例外..&#39;);</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><ul><li>示例2</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--是否存在编号50的部门，如果不存在 ，抛出一个例外；如果存在，将该部门的员工姓名 打印。。</span><br><span class="line"></span><br><span class="line">set serveroutput on ;</span><br><span class="line">declare </span><br><span class="line">  cursor cemp(dno number) is select ename from emp where deptno &#x3D; dno ;</span><br><span class="line">   pename emp.ename%type ;</span><br><span class="line">   no_emp_found exception ;</span><br><span class="line">   </span><br><span class="line">begin </span><br><span class="line">   open cemp(50);</span><br><span class="line">     fetch cemp into pename ;</span><br><span class="line">    if cemp%notfound then  raise no_emp_found ;</span><br><span class="line">    </span><br><span class="line">    else </span><br><span class="line">           loop</span><br><span class="line">                  exit when cemp%notfound ;</span><br><span class="line">                  fetch cemp into pename ;</span><br><span class="line">           end loop ;</span><br><span class="line">        </span><br><span class="line">    end if ;</span><br><span class="line">        </span><br><span class="line">    exception  </span><br><span class="line">           when no_emp_found then dbms_output.put_line(&#39;自定义例外,没有此号部门...&#39;);</span><br><span class="line">  </span><br><span class="line">   close cemp;</span><br><span class="line">   </span><br><span class="line">end ；</span><br></pre></td></tr></table></figure><h5 id="IFELSE"><a href="#IFELSE" class="headerlink" title="IFELSE"></a>IFELSE</h5><ul><li>语法</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件 then ..;</span><br><span class="line">elsif 条件 then ...</span><br><span class="line">else ..</span><br><span class="line">end if ;</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set serveroutput on ;</span><br><span class="line">declare</span><br><span class="line">pnum number :&#x3D; 3 ;    </span><br><span class="line">begin</span><br><span class="line">    if pnum&#x3D;1   then   dbms_output.put_line(&#39;一&#39;);</span><br><span class="line">    elsif pnum&#x3D;2  then   dbms_output.put_line(&#39;二&#39;);</span><br><span class="line">    else dbms_output.put_line(&#39;其他&#39;);</span><br><span class="line">    end if ;  </span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><ul><li>while</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while 条件</span><br><span class="line">loop </span><br><span class="line">...</span><br><span class="line">end loop ;</span><br></pre></td></tr></table></figure><ul><li>do while</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop </span><br><span class="line">...</span><br><span class="line">   exit when i&gt;5 ;</span><br><span class="line">end loop;</span><br></pre></td></tr></table></figure><ul><li>for循环</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for  i in  1 .. 10</span><br><span class="line">loop</span><br><span class="line"></span><br><span class="line">..</span><br><span class="line">end loop ;</span><br><span class="line">--示例</span><br><span class="line">set serveroutput on ;</span><br><span class="line">declare    </span><br><span class="line">begin</span><br><span class="line">  for x in 1 .. 5</span><br><span class="line">    loop</span><br><span class="line">            dbms_output.put_line(x);</span><br><span class="line">    end loop ;</span><br><span class="line">end ;</span><br><span class="line"></span><br><span class="line">--求1-5之和</span><br><span class="line">declare</span><br><span class="line">    pnum number:&#x3D;1 ;</span><br><span class="line">        psum number:&#x3D; 0 ;</span><br><span class="line">begin</span><br><span class="line">        loop</span><br><span class="line">            exit when pnum &gt;5 ;</span><br><span class="line">            psum :&#x3D; psum + pnum ; --sum+&#x3D; i ;</span><br><span class="line">            pnum :&#x3D; pnum +1 ;</span><br><span class="line">        end loop ;</span><br><span class="line">        dbms_output.put_line(psum);</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><h5 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h5><ul><li><p>语法</p><p>存储函数:与存储过程的最大区别： 必须有return</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [or replace] function PRO_NAME -- 函数名(参数列表)</span><br><span class="line">return --返回值类型 </span><br><span class="line">as</span><br><span class="line"></span><br><span class="line">begin </span><br><span class="line">..</span><br><span class="line">return  --返回值</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure></li><li><p>示例</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--查询某个员工的年收入</span><br><span class="line">create or replace function getTotalSal(pid in number) </span><br><span class="line">    return number </span><br><span class="line">as </span><br><span class="line">    empSal emp.sal%type ;</span><br><span class="line">    empComm emp.comm%type ;</span><br><span class="line">begin </span><br><span class="line">    select sal ,comm into empSal,empComm from emp where empno &#x3D; pid ;</span><br><span class="line">    dbms_output.put_line( empSal*12+  nvl( empComm,0));</span><br><span class="line">    return empSal*12+  nvl( empComm,0) ;</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure><h5 id="程序包"><a href="#程序包" class="headerlink" title="程序包"></a>程序包</h5><ul><li><p>作用: 可以用来定义光标(sql返回值是一个几何,  用光标来进行接收)</p></li><li><p>创建包</p></li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\创建包.png" alt="image-20201216134820933"></p><ul><li>包体</li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\包主体.png" alt="image-20201216135333754"></p><h5 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h5><ul><li><p>理解为与表相关联的，PLSQL程序(事件????), 当执行DML时，自动执行触发器</p></li><li><p>语法</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace trigger 触发器名</span><br><span class="line">before|after</span><br><span class="line">delete|insert |update [of 列名]</span><br><span class="line">on 表</span><br><span class="line">for each row [ when (条件)]</span><br><span class="line">...plsql 代码</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure><ul><li>创建语句</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--修改某行触发</span><br><span class="line">create or replace trigger logInsertStudent</span><br><span class="line">after</span><br><span class="line">insert on student</span><br><span class="line">declare</span><br><span class="line">--没有所以不写</span><br><span class="line">begin</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&#39;增加成功&#39;);</span><br><span class="line">end;</span><br><span class="line">&#x2F;</span><br><span class="line"></span><br><span class="line">--具体修改某列触发</span><br><span class="line">create or replace trigger logUpdateStudent</span><br><span class="line">after </span><br><span class="line">update of sname</span><br><span class="line">declare</span><br><span class="line">begin</span><br><span class="line">DBMS_OUTPUT.PUT_LINE(&#39;修改成功&#39;);</span><br><span class="line">end;</span><br><span class="line">&#x2F;</span><br><span class="line">--修改到多行时, 触发器也只会触发一次. 即打印一次(默认为语句级触发器,修改为行级触发器的方法为:for each row [ when (条件)] )</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">--插入校验: 新增员工,但是必须在工作日, 工作时间内新增</span><br><span class="line">create or replace trigger securityCheckStudent</span><br><span class="line">before  insert </span><br><span class="line">on student</span><br><span class="line">begin</span><br><span class="line">        --校验  --不正常</span><br><span class="line">        if to_char(sysdate,&#39;day&#39;)  in (&#39;星期六&#39;,&#39;星期日&#39;)  or to_number( to_char(sysdate,&#39;hh24&#39;) ) not between 9 and 18</span><br><span class="line">        then </span><br><span class="line">            --禁止插入，例外</span><br><span class="line">            raise_application_error(-20001,&#39;禁止非工作时间插入学生&#39;  );</span><br><span class="line">        end if ;</span><br><span class="line">end ;</span><br><span class="line">&#x2F;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">--使用触发器确保：涨工资，涨后的工资 不能少于涨前的工资</span><br><span class="line">create or replace trigger checkSalary</span><br><span class="line">before update </span><br><span class="line">on emp </span><br><span class="line">for each row </span><br><span class="line">begin   --new  old</span><br><span class="line">    if :new.sal &lt; :old.sal  --3000 - 5000 </span><br><span class="line">    then </span><br><span class="line">    raise_application_error(-20002 , &#39;涨后的工资不能小于涨前的！&#39;);</span><br><span class="line">    end if ;</span><br><span class="line">end ;</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure><p>​        ps:  raise_application_error(-20002 , ‘涨后的工资不能小于涨前的！’); 错误编码范围为: 20000~20999</p><p>​        question:  那么, 这个数据校验可以做一些什么呢????</p><ul><li>验证</li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\触发器.png" alt="image-20201216143141667"></p><h5 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h5><p>了解就行</p><p>​    即元数据,   数据库的各种描述信息，系统自带很多表 , 如dictionary、user_objects 、user_tables、user_tab_columns ;</p><p>数据字典的命名规范：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user：当前用户能够使用的</span><br><span class="line">all：系统中全部的</span><br><span class="line">dba:管理员</span><br><span class="line">v$:性能相关</span><br><span class="line"></span><br><span class="line">user_sequences ;</span><br><span class="line">user_synonyms;</span><br><span class="line">user_关键字s;</span><br><span class="line">eg: user_tab_comments  查注释</span><br><span class="line">all_tab_comments</span><br><span class="line">eg:  user_triggers查看有哪些触发器</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="DBCA"><a href="#DBCA" class="headerlink" title="DBCA"></a>DBCA</h5><ul><li><p>打开</p><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\dbca位置.png" alt="image-20201216155357132"></p></li><li><p>创建数据库用的最多</p></li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\DBCA_创建新库.png" alt="image-20201216155009655"></p><ul><li><p>下一步</p><p>数据仓库：分析数据用的，只查询  不DML。</p></li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\dbca步骤2.png" alt="image-20201216155552548"></p><ul><li>下一步</li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\dbca步骤3.png" alt="image-20201216155902621"></p><ul><li>直接到第五步</li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\dbca步骤第五步.png" alt="image-20201216161358703"></p><ul><li>第六步</li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\dbca步骤第六步.png" alt="image-20201216161542601"></p><ul><li>第七步</li></ul><p><img src="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java\blog\zyaireleo.github.io\source_posts\Oracle学习笔记\dbca第七步.png" alt="image-20201216161823409"></p><p>归档和备份有关</p><p>​    备份：<br>​        热备份 ：联机备份 ，必须要启用归档<br>​        冷备份 ： 脱机备份</p><ul><li>第八步</li></ul><h5 id="其他设置或参数、常用命令"><a href="#其他设置或参数、常用命令" class="headerlink" title="其他设置或参数、常用命令"></a>其他设置或参数、常用命令</h5><ul><li>打开执行时间</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set timing on&#x2F;off</span><br></pre></td></tr></table></figure><ul><li>查看保留字:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from v$reserved_words order by keyword asc ;</span><br></pre></td></tr></table></figure><ul><li>查看回收站</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show recyclebin</span><br></pre></td></tr></table></figure><ul><li>清空回收站</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">purge recyclebin;</span><br></pre></td></tr></table></figure><ul><li><p>还原回收站</p><p>闪回</p></li><li><p>修改默认的日期格式</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--默认 DD-MON-RR</span><br><span class="line">alter session set NLS_DATE_FORMAT &#x3D; &#39;yyyy-mm-dd&#39; ;</span><br><span class="line">alter session set NLS_DATE_FORMAT &#x3D; &#39;DD-MON-RR&#39; ;</span><br></pre></td></tr></table></figure><ul><li>查看当前系统编码格式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from nls_database_parameters ;</span><br></pre></td></tr></table></figure><ul><li>查看用户下的表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看用户下的所有表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TAB;</span><br><span class="line"><span class="comment">--查看当前用户下的表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> USER_TABLES;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h5><ol><li><p>1NF:确保每列的原子性（不可再分）</p></li><li><p>宏观：每张表只描述一件事情（例如，一个student表 描述的全部是学生字段）</p><p>微观：通过2NF定义：除了主键以外的其他字段，都依赖于主键</p></li><li><p>微观：除了主键以外的其他字段，都不传递依赖于主键</p></li></ol><p>建议：三大范式 只是一个建议，不必严格遵守。实际使用时，需要“规范性”和“易用性、性能”间综合考虑</p><h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h5><p>模拟自增，本质就是内存中的数组 </p><ul><li>建立序列语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> 序列名</span><br><span class="line"><span class="keyword">increment</span> <span class="keyword">by</span> 步长</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> 起始值</span><br><span class="line">maxvalue | <span class="keyword">nomaxvalue</span></span><br><span class="line"><span class="keyword">minvalue</span> | <span class="keyword">nominvalue</span></span><br><span class="line"><span class="keyword">cycle</span> | <span class="keyword">nocycle</span></span><br><span class="line"><span class="keyword">cache</span> n | <span class="keyword">no</span> <span class="keyword">cache</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- cycle是否循环  cache元素的个数 &lt;= 循环元素个数</span></span><br><span class="line"><span class="comment">-- 循环序列 不能用于给 主键/唯一约束的键 赋值</span></span><br><span class="line"><span class="comment">--修改序列：只对修改之后的操作有效：alter sequence myseq increment by 2</span></span><br></pre></td></tr></table></figure><ul><li>查看序列</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from user_sequences ;</span><br></pre></td></tr></table></figure><ul><li><p>序列有2个属性：</p><p>nextval:下一个值</p><p>currval:当前值</p></li><li><p>裂缝</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [1,2,3...,20]   [21,]</span><br><span class="line">断电、异常、回滚、多表使用同一个序列 ……</span><br></pre></td></tr></table></figure><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><ul><li>建立索引</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名</span><br><span class="line"><span class="comment">-- create index myindex  on emp(deptno) ;</span></span><br><span class="line"><span class="comment">--主键默认 就是索引</span></span><br></pre></td></tr></table></figure><ul><li><p>什么时候 适合建立索引：</p><ul><li>数据集中的列,经常在where中使用的列， 数据量大</li><li>数据集中的列：主键列(empno,id)不集中，但是因为 会被频繁使用 ，因此也适合建索引</li></ul></li><li><p>删除索引<br>drop index 索引名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> myindex ;</span><br></pre></td></tr></table></figure></li></ul><h5 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h5><p>数据库对象（表 视图 索引…）起别名 （默认私有/专用）</p><ul><li><p>可能会遇到 查看其它用户的表，报错“表或视图不存在” 。是因为权限不足</p><ul><li><p>grant xxx  to 用户名;</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> hr.employees  <span class="keyword">to</span> scott；<span class="comment">--con / sysdaba 完成授权</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">synonym</span> <span class="keyword">to</span> scott ; <span class="comment">-- 授于建别名的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--revoke xxx from 用户名;回收权限</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建公有同义词</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">public</span> <span class="keyword">synonym</span>  hremp2 <span class="keyword">for</span> hr.employees ;</span><br></pre></td></tr></table></figure><ul><li>公有同义词的操作（创建、删除） 一般建议由管理员操作</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop [public ] sysnonym 同义词名</span><br></pre></td></tr></table></figure><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><ul><li><p>创建视图的语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create  view 视图名</span><br><span class="line">as </span><br><span class="line">select ...语句</span><br></pre></td></tr></table></figure></li><li><p>优点</p><ul><li>简化查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--原始SQL:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> d.deptno 部门编号,e.empno,e.ename,e.sal,e.comm ,d.dname <span class="keyword">from</span> emp e ,dept d   <span class="keyword">where</span>  e.deptno =d.deptno <span class="keyword">and</span>  d.deptno=<span class="number">20</span>;</span><br><span class="line"><span class="comment">--用视图封装以上的查询结果：</span></span><br><span class="line"><span class="keyword">create</span>  <span class="keyword">view</span>  myempview</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> d.deptno 部门编号,e.empno,e.ename,e.sal,e.comm ,d.dname <span class="keyword">from</span> emp e ,dept d <span class="keyword">where</span> e.deptno=d.deptno <span class="keyword">and</span>  d.deptno=<span class="number">20</span>; </span><br><span class="line"><span class="comment">--用视图简化查询：</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> myempview ;</span><br></pre></td></tr></table></figure><ul><li><p>b增加数据的安全性。可以将其他开发人 需要的某些字段封装到一个视图中交付</p><p> DML  +Query  和表完全一致</p></li></ul></li><li><p>注意：</p><pre><code>某个用户在创建视图时，可能权限不足。需要授权。  如果在创建视图时，给某个字段起了别名，那么在视图中 就只能识别 该“别名”而不能识别原来真实的字段名。</code></pre></li><li><p>通过sys 授予scott 创建视图的权限。</p><pre><code>撤销revoke create view  from scott;  创建grant  xxxx to scott</code></pre></li><li><p>尝试修改视图时：update myempview set ename = ‘hello’ where  empno=7934 ;</p><p>报错:无法修改与非键值保存表对应的列</p><p>本次的原因：在二表关联时，忘了编写 连接条件</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.deptno 部门编号,e.empno,e.ename,e.sal,e.comm ,d.dname <span class="keyword">from</span> emp e ,dept d   <span class="keyword">where</span>  【e.deptno =d.deptno】 <span class="keyword">and</span>  d.deptno=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>drop  view myempview ;</p></li><li><p>视图选项</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> 语句..</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span> ;</span><br><span class="line"> <span class="comment">--with check option :限制对视图操作时，必须满足where子句</span></span><br><span class="line"> <span class="comment">--强烈建议使用：with read only ;</span></span><br><span class="line"><span class="comment">--视图只建议查看，不建议DML。因为对视图的操作，会影响原表。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> myempview</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"> <span class="keyword">select</span> empno ,ename ,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno =<span class="number">20</span>   <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br></pre></td></tr></table></figure></li><li><p>如果非要对视图进行增删改，还需要遵循一些严格的苛刻条件。</p><pre><code>当视图中存在以下之一时，不能Insert/update      group by 、distinct、组函数、列的定义为表达式</code></pre><p>​    当视图中存在以下之一时， 不能delete</p><p>​    group by 、distinct、rownum伪劣</p><p>–&gt;视图只查看，不要DML</p></li></ul><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java虚拟机</title>
      <link href="2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h4><h5 id="Java内存区域分布与概述"><a href="#Java内存区域分布与概述" class="headerlink" title="Java内存区域分布与概述"></a>Java内存区域分布与概述</h5><ul><li><p>线程私有内存区域：java虚拟机栈、程序技术器、本地方法栈。生命周期和线程的生命周期一致。</p><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg"></p></li><li><p>Java语言为甚么优势巨大，一处编译随处运行</p></li><li><p>Java的另外一个优势</p><ul><li>自从内存管理机制之下，不再需要为没一个new操作去写配对的内存分配和回收等代码，<br>不容易出现内存泄漏和内存溢出等问题</li></ul></li><li><p>JVM运行时数据区分布图讲解</p><ul><li>线程共享数据区：方法区、堆</li><li>线程隔离数据区：虚拟机栈、本地方法栈、堆、程序计数器</li></ul></li></ul><h5 id="Java内存区域程序计算器"><a href="#Java内存区域程序计算器" class="headerlink" title="Java内存区域程序计算器"></a>Java内存区域程序计算器</h5><ul><li><p><strong>是什么？</strong></p><ul><li><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器</p></li><li><p>线程是一个独立的执行单元，是由CPU控制执行的</p></li><li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p></li><li><p>查看.class文件行号</p><p><strong>创建User类</strong></p><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/User%E7%B1%BB.png"></p><p>javac User.java编译</p><p>javap -l User.class查看如下</p><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/class%E6%96%87%E4%BB%B6%E8%A1%8C%E5%8F%B7.png"></p></li></ul></li><li><p>为什么要有？</p><ul><li>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</li></ul></li></ul><ul><li>特点？<ul><li>内存区域中唯一一 个没有规定任何 OutOfMemoryError 情况的区域</li></ul></li></ul><h5 id="Java内存区域JAVA虚拟机栈"><a href="#Java内存区域JAVA虚拟机栈" class="headerlink" title="Java内存区域JAVA虚拟机栈"></a>Java内存区域JAVA虚拟机栈</h5><ul><li><p>是什么？</p><p>用于作用于方法执行的一块Java内存区域</p></li><li><p>有什么用？</p><ul><li>每个方法在执行的同时都会创建一个栈帧（Stack Framel）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</li></ul></li><li><p>特点？</p><ul><li>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象引用（reference 类型）</li><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量表: 可以理解为方法里面的变量</span></span><br><span class="line">    <span class="comment">//操作数栈: 例如 c=a*b这种</span></span><br><span class="line">    <span class="comment">//动态链接: 对对象的引用, 例如 User user = new user()的这种</span></span><br><span class="line">    <span class="comment">//方法出口: 就是return语句</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;enter method a&quot;</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a();</span><br><span class="line">        System.out.println(<span class="string">&quot;enter method b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        b();</span><br><span class="line">        System.out.println(<span class="string">&quot;enter method main&quot;</span>);</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Java内存区域本地方法栈"><a href="#Java内存区域本地方法栈" class="headerlink" title="Java内存区域本地方法栈"></a>Java内存区域本地方法栈</h5><ul><li><p>是什么？</p><ul><li>用于作用域本地方法执行的一块Java内存区域，和虚拟机栈不同的是这里执行的是native方法，而本地虚拟机栈执行的是java方法，会被编译成class文件。</li></ul></li><li><p>什么是本地（native）方法？</p><ul><li>是一个修饰符，不能有方法体。调用java之外的方法。</li></ul></li><li><p>这又是什么呢？</p><ul><li>与Java虚拟机栈相同，每个方法在执行的同时都会创建一个栈帧（Stack Framel）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</li></ul></li><li><p>Hotshot（<strong>jvm其中的一种实现方式</strong>）将Java虚拟机栈和本地方法栈合二为一</p></li></ul><h5 id="Java内存区域Java堆"><a href="#Java内存区域Java堆" class="headerlink" title="Java内存区域Java堆"></a>Java内存区域Java堆</h5><ul><li><p>查看java程序堆内存使用情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -heap +java程序进程号</span><br></pre></td></tr></table></figure></li><li><p>是什么？</p><ul><li>是Java内存区域中一块用来存放对象实例的区域，【几乎所有的对象实例都在这里分配内存】</li></ul></li><li><p>拿来干什么？</p><ul><li>此内存区域的唯一目的就是存放对象实例</li><li>Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块 Java 堆是被所有线程共享的一块内存区域  </li></ul></li><li><p>特点？</p><ul><li><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage</p></li><li><p>-Xmx -Xms</p></li><li><p>Java堆可以分成新生代和老年代   新生代可分为To Space、From Space、Eden</p></li></ul></li></ul><h5 id="Java内存区域方法区"><a href="#Java内存区域方法区" class="headerlink" title="Java内存区域方法区"></a>Java内存区域方法区</h5><ul><li>class文件</li></ul><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/user%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"></p><ul><li><p>是什么？</p><ul><li>是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li><li>什么是类信息：类版本号、方法、接口</li></ul></li><li><p>拿来干什么？</p><ul><li>内存中存放类信息、静态变量等数据，属于线程共享的一块区域</li><li>Hotspot使用永久代（对象经常被使用，经过多次垃圾回收后还没有被回收掉，就把它放在永久代里面）来实现方法区   JRockit、IBM J9VM Java堆一样管理这部分内存</li></ul></li><li><p>特点？</p><ul><li>并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载</li><li>方法区也会抛出OutofMemoryError，当它无法满足内存分配需求时 </li></ul></li></ul><h5 id="神秘的运行时常量池"><a href="#神秘的运行时常量池" class="headerlink" title="神秘的运行时常量池"></a>神秘的运行时常量池</h5><ul><li>是什么？<ul><li>运行时常量池是<strong>方法区的一部分</strong>，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</li></ul></li><li>特点：<ul><li>运行时常量池是方法区的一部分，受到方法区内存的限制，当常量池再申请到内存时会抛出OutOfMemoryError异常</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="comment">//在方法区会有维护StringTable的表(本质上是一个HashSet的结构)来存储常量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(a==b);</span><br><span class="line">        </span><br><span class="line">        String c = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(a==c);</span><br><span class="line">        <span class="comment">//intern (native方法) 用来将java堆里面的内存移到java方法区中, 下面结果为true</span></span><br><span class="line">        System.out.println(a==c.intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞"></a>起飞</h3><h4 id="深入了解对象"><a href="#深入了解对象" class="headerlink" title="深入了解对象"></a>深入了解对象</h4><h5 id="创建对象的地层顺序"><a href="#创建对象的地层顺序" class="headerlink" title="创建对象的地层顺序"></a>创建对象的地层顺序</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%BA%95%E5%B1%82%E6%AD%A5%E9%AA%A4.jpg" alt="Java对象创建底层步骤"></p><ul><li><p><strong>对象创建的流程步骤包括哪些：</strong></p><ol><li><p>虚拟机遇到一条new指令时，首先检查这个对应的类能否在常量池中定位到一个类的符号引用 (如果能够定位到, 就说明这个对象在常量池存在)</p></li><li><p>判断这个类是否已被加载、解析和初始化</p></li><li><p>为这个新生对象在Java堆中分配内存空间，其中Java堆分配内存空间的方式主要有以下两种</p><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E6%96%B9%E5%BC%8F.jpg" alt="对象分配空间方式"></p><ul><li>**指针碰撞 **(就是将使用内存进行扩大,  空闲内存减小,  新增的内存就是为对象分配的内存)<ul><li>分配内存空间包括开辟一块内存和移动指针两个步骤</li><li>非原子步骤可能出现并发问题，Java虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</li></ul></li><li><strong>空闲列表</strong> ( 列表存储并维护堆内存中空闲内存的地址 )<ul><li>分配内存空间包括开辟一块内存和修改空闲列表两个步骤</li><li>非原子步骤可能出现并发问题，Java虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</li></ul></li></ul></li><li><p>将分配到的内存空间都初始化为零值</p></li><li><p>设置对象头相关数据</p><ul><li>GC分代年龄</li><li>对象的哈希码 hashCode</li><li>元数据信息</li></ul></li><li><p>执行对象<init>方法</init></p></li></ol></li><li><p>代码分析对象执行的过程</p><p>加载类(例如执行static方法)—&gt;构造方法—&gt;普通方法</p></li></ul><h5 id="不可不知的对象结构"><a href="#不可不知的对象结构" class="headerlink" title="不可不知的对象结构"></a>不可不知的对象结构</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="对象内存布局"></p><ol><li>对象头用于存储对象的元数据信息：<ul><li>GC分代年龄: 不同的分代年龄,  GC回收时会采用不同的回收算法(总共三种)</li><li>锁状态: 为线程安全锁设置的一个概念</li><li>Mark Word 部分数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，存储对象自身的运行时数据如哈希值等。Mark Word一般被设计为非固定的数据结构，以便存储更多的数据信息和复用自己的存储空间。</li><li>类型指针 指向它的类元数据的指针，用于判断对象属于哪个类的实例。</li></ul></li><li>实例数据存储的是真正有效数据，如各种字段内容，各字段的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops(ordinary object pointers)，相同宽度的字段总是被分配到一起，便于之后取数据。父类定义的变量会出现在子类定义的变量的前面。</li><li>对齐填充部分仅仅起到占位符的作用 (为了保证对象头字节数为8的倍数 )</li></ol><h5 id="如何访问对象的"><a href="#如何访问对象的" class="headerlink" title="如何访问对象的"></a>如何访问对象的</h5><p><strong>对象访问定位方式</strong></p><ul><li><p>当我们在堆上创建一个对象实例后，就要通过虚拟机栈中的reference类型数据来操作堆上的对象。现在主流的访问方式有两种（HotSpot虚拟机采用的是第二种）：</p><ul><li><p>类型数据和实例数据:</p><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/User%E7%B1%BB.png"></p><p>实例数据:    id之类的数据</p><p>类型数据:     用来描述class文件有哪些数据类型,  实现了哪些接口等等的数据</p></li><li><p><strong>使用句柄访问对象</strong>。即reference中存储的是对象句柄的地址，而句柄中包含了对象实例数据与类型数据的具体地址信息，相当于二级指针。</p><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.jpg" alt="对象句柄访问"></p></li><li><p><strong>直接指针访问对象</strong>。即reference中存储的就是对象地址，相当于一级指针<strong>。</strong></p><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE.jpg" alt="对象访问定位直接访问"></p></li></ul></li><li><p>对比</p><ul><li><p>垃圾回收分析：方式1当垃圾回收移动对象时，reference中存储的地址是稳定的地址，不需要修改，仅需要修改对象句柄的地址；方式2垃圾回收时需要修改reference中存储的地址。</p></li><li><p>访问效率分析，方式二优于方式一，因为方式二只进行了一次指针定位，节省了时间开销，而这也是HotSpot采用的实现方式。</p><p>​    </p></li></ul></li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h5 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h5><ul><li>为什么要垃圾回收？<ul><li>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存</li></ul></li><li>如果让你考虑垃圾回收算法你会怎么设计<ul><li>完成哪些对象回收哪些对象不回收的功能需求</li></ul></li><li>对象是否存活判断<ul><li>堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1</li></ul></li></ul><h5 id="对象存活算法引用计数法"><a href="#对象存活算法引用计数法" class="headerlink" title="对象存活算法引用计数法"></a>对象存活算法引用计数法</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.jpg" alt="引用计数法"></p><ul><li><p>引用计数法存在的特点分析</p></li><li><p>优缺点</p><ul><li>最大的特点就是简单，通过对象的引用数就可以判断是否回收</li><li>引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</li><li>无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</li></ul></li><li><p>配置启动参数打印GC日志</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-verbose:gc  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*num];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA= <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB= <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相当于切断了虚拟机栈对堆的引用, 这样可以查看GC到底有没有使用引用计数器来判断是否回收(引用计数法有循环引用的问题)</span></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="对象存活算法可达性分析"><a href="#对象存活算法可达性分析" class="headerlink" title="对象存活算法可达性分析"></a>对象存活算法可达性分析</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.jpg" alt="可达性分析法"></p><ul><li><p>可达性分析算法的概念(又叫根搜索法)</p><ul><li>根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点</li></ul></li><li><p>java中可作为GC Root的对象有</p><ul><li>虚拟机栈中引用的对象（本地变量表）</li></ul></li></ul><ul><li>本地方法栈中引用的对象<ul><li>方法区中静态属性引用的对象</li></ul></li><li>方法区中常量引用的对象</li></ul><h5 id="算法内功之剖析标记清除"><a href="#算法内功之剖析标记清除" class="headerlink" title="算法内功之剖析标记清除"></a>算法内功之剖析标记清除</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="标记清除算法"></p><ul><li>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：<ul><li>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前- -节讲述对象标记判定时已经介绍过了。</li><li>它的主要不足有两个：<ul><li>一个是效率问题，标记和清除两个过程的效率都不高；</li><li>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li></ul></li></ul><h5 id="算法内功之剖析复制算法"><a href="#算法内功之剖析复制算法" class="headerlink" title="算法内功之剖析复制算法"></a>算法内功之剖析复制算法</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="复制算法"></p><ul><li>为毛会出现复制算法？<ul><li>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按量划分为大小相等的两块，每次只使用其中的一块</li><li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效</li></ul></li><li>使用场景<ul><li>现在的商业虚拟机都采用这种收集算法来回收<strong>新生代</strong>，研究表明，新生代中的对象 98%是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。  Survivor from  和Survivor to  ，内存比例 8：1：1</li></ul></li><li>回收算法<ul><li>当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor  ( Survivor to ,  回收完成后会把所有存活的对象拷贝到Survivor from 里面 ) 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1, 也就是每次新生代中可用内存空间为整个新生代容量的 90% (80%+10%），只有 10% 的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10%的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li></ul></li></ul><h5 id="标记整理算法与分代收集算法"><a href="#标记整理算法与分代收集算法" class="headerlink" title="标记整理算法与分代收集算法"></a>标记整理算法与分代收集算法</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.jpg" alt="标记整理"></p><ul><li><p>标记整理算法解决了什么问题</p><ul><li>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100%存活的极端情况，所以在老年代一般不能直接选用这种算法</li></ul></li><li><p>标记-整理</p><ul><li>根据老年代的特点，有人提出了另外一种“标记-整理（Mark- Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li></ul></li></ul><ul><li>分代收集<ul><li>一般把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法</li><li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记一整理”算法来进行回收</li></ul></li></ul><h4 id="偷偷在干活的JVM垃圾收集器"><a href="#偷偷在干活的JVM垃圾收集器" class="headerlink" title="偷偷在干活的JVM垃圾收集器"></a>偷偷在干活的JVM垃圾收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Serial%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="Serial垃圾收集器"></p><ul><li><p>是什么？</p><ul><li>收集算法是内存收到的方法论，垃圾回收器是内存回收的具体实现。</li><li>Serial是一个单线程的垃圾收集器</li></ul></li><li><p>serial垃圾收集器的特点</p><ul><li>“Stop The World”，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。在用户不可见的情况下把用户正常工作的线程全部停掉</li><li>使用场景：多用于桌面应用，Client端的垃圾回收器。桌面应用内存小，进行垃圾回收的时间比较短，只要不频繁发生停顿就可以接受</li></ul></li></ul><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/ParNew%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="ParNew垃圾收集器"></p><ul><li><p>是什么？</p><ul><li>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如：-XX: SurvivorRatio、-XX: PretenureSize’ Threshold、-XX: HandlePromotionFailure 等）、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码</li></ul></li><li><p>parnew垃圾收集器的特点？</p><ul><li>ParNew 收集器除了多线程收集之外，其他与 Serial 收集器相比并没有太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，<strong>目前只有它能与 CMS 收集器配合工作</strong>。</li><li>使用-XX: ParallelGCThreads 参数来限制垃圾收集的线程数</li><li>多线程操作存在上下文切换的问题，所以建议将-XX: ParallelGCThreads设置成和CPU核数相同，如果设置太多的话就会产生上下文切换消耗</li></ul></li><li><p>并发与并行的概念讲解   CMS垃圾回收器（用来回收老年代）</p><ul><li><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能</p><p>会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上</p></li></ul></li></ul><h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><ul><li><p>是什么？</p><ul><li>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</li><li>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器</li><li><strong>吞吐量是什么？</strong><ul><li>CPU用于运行用户代码的时间与CPU总时间的比值，99%时间执行用户线程，1%时间回收垃圾 ，这时候吞吐量就是99%</li></ul></li></ul></li></ul><ul><li>特点：<ul><li>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是<strong>尽可能地缩短垃圾收集时用户线程的停顿时间</strong>，而 Parallel Scavenge 收集器的目标则是达到个可控制的吞吐（Throughput）。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%  停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li><li>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 <strong>GC自适应调节策略</strong></li><li>-XX:MaxGCPauseMillis参数GC停顿时间，500MB  ——&gt;300MB，这个参数配置太小的话会发生频繁GC</li><li>-XX:GCTimeRatio参数，99%</li></ul></li><li>Serial old收集器，它是一个单线程收集器，使用”标记–整理”算法</li><li>Parallel old收集器Parallel Scavenge收集器的老年代版本，使用多线程+标记整理算法</li></ul><h5 id="不得不懂的CMS收集器"><a href="#不得不懂的CMS收集器" class="headerlink" title="不得不懂的CMS收集器"></a>不得不懂的CMS收集器</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="CMS垃圾收集器"></p><p>**标记整理算法以及分代收集算法 **</p><ul><li><p>是什么？</p><ul><li><p>CMS  (Concurrent Mark Sweep）收集器是-种以获取最短回收停顿时间为目标的收集器。</p></li><li><p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重 视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p></li><li><p>CMS 收集器是基于“<strong>标记-清除</strong>”算法实现的</p></li></ul></li><li><p>步骤流程：</p><ul><li><p>初始标记（CMS initial mark)  —–标记一下 GC Roots 能直接关联到的对象，速度很快</p></li><li><p>并发标记（CMS concurrent mark ——–并发标记阶段就是进行 GC RootsTracing 的过程（可以是多线程）</p></li><li><p>重新标记（CMS remark)  ———–为了修正并发标记期间因用户程序导致标记产生变动的标记记录</p></li><li><p>并发清除（CMS concurrent sweep)</p></li></ul></li><li><p>CMS垃圾收集器缺点</p><ul><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾：程序在进行并发清除阶段用户线程所产生的新垃圾</li><li>标记-清除暂时空间碎片</li></ul></li></ul><h5 id="不得不懂的G1收集器"><a href="#不得不懂的G1收集器" class="headerlink" title="不得不懂的G1收集器"></a>不得不懂的G1收集器</h5><p><img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/G1.jpg" alt="G1"></p><ul><li><p>是什么</p><ul><li>G1是一款面向服务端应用的垃圾收集器</li></ul></li><li><p>特点：</p><ul><li>G1 中每个 Region 都有一个与之对应的 Remembered Set（用来记录和维护Reference关系），当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏    检查Reference引用的对象是否处于不同的Region</li></ul></li></ul><ul><li><p>G1 收集器的运作大致可划分为以下几个步骤</p><ul><li><p>初始标记（Initial Marking）  –标记一下 GC Roots 能直接关联到的对象</p></li><li><p>并发标记（Concurrent Marking）—从GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行</p></li><li><p>最终标记（Final Marking) —为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs的数据合并到 Remembered Set 中</p></li><li><p>筛选回收（Live Data Counting and Evacuation)</p></li></ul></li></ul><ul><li><strong>G1的优势</strong><ul><li>空间整合：基于“标记一整理”算法实现为主和Region之间采用复制算法实现的垃圾收集</li><li>可预测的停顿：（<strong>因为他维护了region和RememberSet，可以预估停顿时间</strong>）这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型</li><li>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 雄划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔髙的了，它们都是一部分 Region（不需要连续）的集合。</li><li>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Regions 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage- Firsti 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高</li></ul></li></ul><h4 id="简明扼要内存分配"><a href="#简明扼要内存分配" class="headerlink" title="简明扼要内存分配"></a>简明扼要内存分配</h4><h5 id="探索堆内存到底是怎么分配"><a href="#探索堆内存到底是怎么分配" class="headerlink" title="探索堆内存到底是怎么分配"></a>探索堆内存到底是怎么分配</h5><p><strong>堆内存分配方式，分配规则</strong></p><ul><li><p>Java堆内存区域的划分以及作用讲解</p></li><li><p>对象分配的规则有哪些</p><ul><li>对象主要分配在新生代的 Eden 区上</li><li>如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配</li><li>少数情况下也可能会直接分配在老年代中</li></ul></li><li></li><li><p>GC参数指定垃圾回收</p><ul><li>-Xms20 M、-Xmx20 M、-Xmn1 0 M 这 3 个参数限制了 Java 堆大小为 20 MB，不可扩展，其中 10 MB 分配给新生代，剩下的 10 MB 分配给老年代。-Xx: SurvivorRatio= 8 决定了新生代中 Eden 区与两个 Survivor 区的空间比例是 8:1</li></ul></li><li><p>新生代与老年代</p><ul><li>新生代 GC (Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度老年代 GC (Major GC/ Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li></ul></li></ul><h4 id="大对象的分配和基本分配一样吗？"><a href="#大对象的分配和基本分配一样吗？" class="headerlink" title="大对象的分配和基本分配一样吗？"></a>大对象的分配和基本分配一样吗？</h4><p><strong>堆内存JVM参数讲解，大对象分配原则讲解和代码验证</strong></p><ul><li><p>是什么？</p><ul><li><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组</p></li><li><p>虚拟机提供了一个-XX: PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制</p></li></ul></li><li><p>实战代码演练大对象配置</p><ul><li><p>-verbose:gc -XX:+PrintGCDetails  开启GC日志打印</p></li><li><p>-Xms20 M  设置JVM初始内存为20M</p></li><li><p>-Xmx20 M  设置JVM最大内存为20M</p></li><li><p>-Xmn10 M 设置年轻代内存大小为10M</p></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:PretenureSizeThreshold=3145728</span><br></pre></td></tr></table></figure><h5 id="逃逸分析和栈上分配"><a href="#逃逸分析和栈上分配" class="headerlink" title="逃逸分析和栈上分配"></a>逃逸分析和栈上分配</h5><p><strong>堆内存分配方式，分配规则</strong></p><ul><li><p>逃逸分析</p><ul><li>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</li></ul></li><li><p>栈上分配</p><ul><li><p>栈上分配就是把方法中的变量和对象分配到栈上，方法执行完后自动销毁，而不需要垃圾回收的介入，从而提高系统性能</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis开启逃逸分析（jdk1.8默认开启，其它版本未测试）</span><br><span class="line">-XX:-DoEscapeAnalysis 关闭逃逸分析</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="中高级工程师必备线上虚拟机工具"><a href="#中高级工程师必备线上虚拟机工具" class="headerlink" title="中高级工程师必备线上虚拟机工具"></a>中高级工程师必备线上虚拟机工具</h4><h5 id="实战应用之使用虚拟机工具jps"><a href="#实战应用之使用虚拟机工具jps" class="headerlink" title="实战应用之使用虚拟机工具jps"></a>实战应用之使用虚拟机工具jps</h5><p>虚拟机工具的意义以及JPS讲解</p><ul><li><p>虚拟机工具的意义</p><ul><li><p>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段</p></li><li><p>数据包括：运行日志、异常堆栈、GC 日志、线程快照</p><p>( threaddump/javacore文件）、堆转储快照（ heapdump/hprof文件)等。使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位解决问题的速度</p></li></ul></li><li><p>ps -ef|grep java</p><ul><li>grep命令是查找</li><li>中间的|是管道命令 是指ps命令与grep同时执行</li><li>PS是LINUX下最常用的也是非常强大的进程查看命令</li><li>grep命令是查找，是一种强大的文本搜索工具，它能<a href="https://www.baidu.com/s?wd=%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9uWD3PhP9n1b4m1nduAcz0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjfvrHnzPWT3">使用正则表达式</a>搜索文本，并把匹配的行打印出来</li></ul></li><li><p>JPS是什么？</p><ul><li>jps  (JVM Process Status Tool）是其中的典型jvm工具。除了名字像 UNIX 的 ps 命令之外，它的功能也和 ps 命令类似：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class, main（）函数所在的类）名称以及这些进程的本地虚拟机唯- ID  (Local Virtual Machine Identifier, LVMID），虽然功能比较单一，但它是使用频率最高的 JDK 命令行工具</li></ul></li><li><p>实战使用</p><ul><li>jps -l 输出主类的全名，如果进程执行的是Jar包则输出Jar路径</li><li>jps -v 输出虚拟机进程启动时JVM参数</li></ul></li></ul><h3 id="第2集-实战应用之使用虚拟机工具jstat与jinfo"><a href="#第2集-实战应用之使用虚拟机工具jstat与jinfo" class="headerlink" title="第2集     实战应用之使用虚拟机工具jstat与jinfo"></a>第2集     实战应用之使用虚拟机工具jstat与jinfo</h3><p>**简介：jstat命令和jinfo命令实战讲解<br> **</p><ul><li><p>jstat是什么</p><ul><li>Jstat  (JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程-虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据，在没有 GU 图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具</li></ul></li><li><p>jstat命令使用 </p></li></ul>  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">jstat <span class="literal">-gc</span> <span class="number">2764</span> <span class="number">250</span> <span class="number">20</span>   //<span class="number">2764</span>表示进程id ，<span class="number">250</span>表示<span class="number">250</span>毫秒打印一次 ，<span class="number">20</span>表示一共打印<span class="number">20</span>次</span><br><span class="line">S0C：第一个幸存区的大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">OC：老年代大小</span><br><span class="line">OU：老年代使用大小</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure><ul><li><p>jinfo是什么？</p><ul><li>jinfo (Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。使用 jps 命令的-v 参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用 info 的-flag 选项进行查询了</li></ul></li><li><p>jinfo命令使用  </p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">jinfo <span class="literal">-flag</span> CMSInititingOccupancyFraction <span class="number">1444</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="第3集-实战应用之使用虚拟机工具jmap"><a href="#第3集-实战应用之使用虚拟机工具jmap" class="headerlink" title="第3集     实战应用之使用虚拟机工具jmap"></a>第3集     实战应用之使用虚拟机工具jmap</h3><p>**简介：jmap常用命令讲解，linux命令说明书怎么看？<br> **</p><ul><li><p>jmap是什么？ </p><ul><li>Jmap  (Memory Map for Java）命令用于生成堆转储快照。如果不使用 jmap 命令，要想获取 Java 堆转储快照，还有一些比较“暴力”的手段：-XX: +HeapDumpOnOutOfMemoryError 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，用于系统复盘环节</li><li>和 info 命令一样，jmap 有不少功能在 Windows 平台下都是受限的，除了生成 dump 文件的- dump 选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris 下使用。</li></ul></li><li><p>jmap常用命令</p><ul><li><p>-dump</p><ul><li><p>生成 Java 堆转储快照。格式为：-dump:  format=b, file= <filename></filename></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">windows： jmap <span class="literal">-dump</span>:format=b,file=d:\a.bin <span class="number">1234</span></span><br><span class="line">mac:      jmap <span class="literal">-dump</span>:format=b,file=/Users/daniel/deskTop</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>-histo   more分页去查看</p><ul><li>显示堆中对象统计信息，包括类、实例数量、合计容量</li></ul><p>B ：byte</p><p>C :  char</p><p>I ：Int</p></li></ul><h3 id="第4集-实战应用之使用虚拟机工具jhat"><a href="#第4集-实战应用之使用虚拟机工具jhat" class="headerlink" title="第4集    实战应用之使用虚拟机工具jhat"></a>第4集    实战应用之使用虚拟机工具jhat</h3><p>**简介：jhat命令的是什么？jhat命令的使用<br> **</p><ul><li>实战OOM场景dump下内存快照</li><li>jhat是什么？</li><li><ul><li>Sun JDK 提供 jhat  (JVM Heap Analysis Tool）命令常与 jmap 搭配使用，来分析 jmap 生成的堆 转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看</li></ul></li><li>特点：<ul><li>jhat分析工作是一个耗时而且消耗硬件资源的过程</li><li>jhat 的分析功能相对来说比较简陋</li></ul></li></ul><h3 id="第5集-实战应用之使用虚拟机工具jstack"><a href="#第5集-实战应用之使用虚拟机工具jstack" class="headerlink" title="第5集 实战应用之使用虚拟机工具jstack"></a>第5集 实战应用之使用虚拟机工具jstack</h3><p>**简介：堆内存分配方式，分配规则讲解<br> **</p><ul><li><p>Jstack是什么？</p><ul><li><p>Jstack  (Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（-般称为 threaddump 或者 javacore 文件）</p></li><li><p>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源</p></li></ul></li></ul><ul><li><p>Jstack怎么做</p><ul><li>常用命令jstack -l 3500</li><li>jstack -F 当正常输出的请求不被响应时，强制输出线程堆栈 Force</li><li>经典面试题之 【jstack怎么进行死锁问题定位？】</li></ul></li><li><p>线上程序一般不能kill进程pid的方式直接关闭</p><ul><li>shutdownHook :在关闭之前执行的任务</li></ul></li></ul><h3 id="第6集-经典面试题之死锁"><a href="#第6集-经典面试题之死锁" class="headerlink" title="第6集 经典面试题之死锁"></a>第6集 经典面试题之死锁</h3><p>**简介：线程死锁是什么？怎么模拟一个线程死锁？怎么用jstack定位到线程死锁<br> **</p><ul><li>线程死锁是什么？<ul><li>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行</li></ul></li><li>死锁的模拟过程，代码模拟死锁</li></ul><h3 id="第7集-经典面试题之线程状态"><a href="#第7集-经典面试题之线程状态" class="headerlink" title="第7集 经典面试题之线程状态"></a>第7集 经典面试题之线程状态</h3><p>**简介：线程状态有哪些？他们之间是怎么切换的<br> **</p><ul><li><p>线程状态分类</p><ul><li>NEW</li><li>RUNNABLE</li><li>BLOCKED   一个正在阻塞等待一个监视器的线程处于这一状态</li><li>WAITING    一个正在无限期等待另一个线程执行一个特别的动作的线程处于这一状态</li><li>TIMED_WAITING 一个正在限时等待另一个线程执行一个动作的线程处于这一状态</li><li>TERMINATED</li></ul></li></ul><ul><li><p>Blocked状态与Waiting状态的区别</p><ul><li>WAITING 状态属于主动地显式地申请的阻塞，BLOCKED 则属于被动的阻塞</li></ul></li></ul><p>**<img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGoAAAAiCAMAAACA9LykAAAAY1BMVEUAAAAjJikjJiojJiokJigjJikkJigjJikjJikjJikjJikkJigjJiojJiokJigjJiomJiYmJibWABPWABMmJiYmJiYmJibWABN9Ex99Ex/WABMmJiYjJiqgoKB3d3dcXFxBQUEZhcyGAAAAG3RSTlMAQIC/MGAQz9+fj+8gr3BQv4C/gCCvUN+/gGCwJXa4AAACP0lEQVRIx72W2ZLbIBBFe2EVQrLHnslCZ/n/rwwoOCDH5CWyzxO2VJy63TQlGGAQFbwEhagpOseE8BpmzRL8Cq9h9iJOw2uYWYRneBb67LtTsYiEZwXDlE47s4g8x2VsVplXuJRLGbtzUXap4zOFYvr54x16rIiFo1lS4fu3sIuFzyjhe6qcocftYukJRrQn7c0Bp6a679bcfvHDLpMCEB/jVB8bWonB4EBlq8kDjCvYVF8vlwtpA4UoMauQGeU2kZYYfBhMb9oIV7gjq6YHqrdPb28sQUEGGUsq5/ymQvLi2MUwkX5Y6lRdCgpq6VT8SHUphYphLi8z9KnIol+w4HnUqpZLJ2/+UsWpqBQvVVVcjrYiFwE5RwSZWQHlJauyesA53bAA14RQ6VWxqKIIZD5/gYLnqkJEaxGxpRccj9UNDR+2XfBZFaFgRJUt1uAhw1T1N9Wy9KrAPFSppnJwPu2uQaqT0vWqqpToTaUAJsc82b6rQ0Jz4dJU9s8tSGavQkQKXAdiXmVhBuuriNgRjWL5pprQ9mPlunPKuykIWZ+Zg1ZuBea88oNUgwpalfpQ1G0/ja6lGYoKVJYbzHiLmRke4prLJFN3KKG6+xfhHygFGwYrQ9XUVB8O65nIIBxNf9zPJ9z+ka18/816Hw7vVMZLxsMBTOvwXPikAJ1kJjgEYuzr1/XKnRSLHPlthtZq08rXYSVz7BendmIJi+7aPJJ+ixCOZY3btuw3ScMjHI9ZvZUdzq8GngYiVTQeq/kFPvQz03kWbEEAAAAASUVORK5CYII=" alt="å°Dè¯¾å ">   愿景：”让编程不在难学，让技术与生活更加有趣”                  **</p><hr><h2 id="第8章-中高级工程师必备虚拟机图形化工具"><a href="#第8章-中高级工程师必备虚拟机图形化工具" class="headerlink" title="第8章   中高级工程师必备虚拟机图形化工具"></a>第8章   中高级工程师必备虚拟机图形化工具</h2><h3 id="第1集-可视化虚拟机工具Jconsole介绍"><a href="#第1集-可视化虚拟机工具Jconsole介绍" class="headerlink" title="第1集     可视化虚拟机工具Jconsole介绍"></a>第1集     可视化虚拟机工具Jconsole介绍</h3><p>**简介：jconsole是什么？怎么连接与使用介绍<br> **</p><ul><li><p>Jconsole是什么？</p><ul><li>JConsole  (Java Monitoring and Management Console）是一种基于 JMX 的可视化监视、管理工具，它管理部分的功能是针对 JMXMBean 进行管理，由于 MBean 可以使用代码、中间件服务器的管理控制台或者所有符合 JMX 规范的软件进行访问</li><li>特点：jconsole集成了线程与内存的可视化展示</li></ul></li><li><p>Jconsole怎么连接使用？</p><ul><li><p>本地连接 </p><ul><li>通过JDK/bin目录下的“jconsole.exe”启动JConsole 后，将自动搜索出本机运行的所有虚拟机进程，不需要用户自己再使用 jps 来查询了</li></ul></li><li><p>远程连接</p><ul><li><p>mvn install 生成项目jar</p></li><li><p>scp将jar包进行远程复制</p></li></ul></li></ul></li></ul><pre><code>  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo scp /Users/daniel/Desktop/jvm<span class="literal">-demo</span><span class="literal">-0</span>.<span class="number">0.1</span><span class="literal">-SNAPSHOT</span>.jar daniel@<span class="number">172.16</span>.<span class="number">244.151</span>:/usr/local</span><br><span class="line"></span><br></pre></td></tr></table></figure>* 将jar包启动  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m -Dcom.sun.management.jmxremote.port=9999 </span><br><span class="line">-Djava.rmi.server.hostname=172.16.244.151 </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false -jar /Users/daniel/Desktop/jvm-demo-0.0.1-SNAPSHOT.jar &amp;</span><br></pre></td></tr></table></figure>  http与https的区别：https=http+ssl</code></pre><h3 id="第2集-可视化虚拟机工具Jconsole内存监控验证"><a href="#第2集-可视化虚拟机工具Jconsole内存监控验证" class="headerlink" title="第2集     可视化虚拟机工具Jconsole内存监控验证"></a>第2集     可视化虚拟机工具Jconsole内存监控验证</h3><p><strong>简介：怎么设计程序验证jconsole内存监控功能</strong></p><ul><li>设计jconsole内存监控功能需求分析<ul><li>掌握需求分析能力的重要性</li><li>作为一个有追求的程序员我们应该怎么分析需求</li></ul></li><li>实战演练jconsole内存增长过程<ul><li>编写jconsole内存分配代码</li><li>分析jconsole各个指标的增长情况</li></ul></li></ul><h3 id="第3集-可视化虚拟机工具Jconsole线程验证"><a href="#第3集-可视化虚拟机工具Jconsole线程验证" class="headerlink" title="第3集     可视化虚拟机工具Jconsole线程验证"></a>第3集     可视化虚拟机工具Jconsole线程验证</h3><p><strong>简介：怎么设计程序验证jconsole线程监控功能</strong></p><ul><li><p>设计jconsole线程监控功能需求分析</p></li><li><p>实战演练jconsole线程状态过程</p><ul><li>线程状态waiting、timeWaiting模拟</li></ul></li></ul><h3 id="第4集-可视化虚拟机工具VisualVM"><a href="#第4集-可视化虚拟机工具VisualVM" class="headerlink" title="第4集     可视化虚拟机工具VisualVM"></a>第4集     可视化虚拟机工具VisualVM</h3><p><strong>简介：VisualVM插件安装讲解以及基础线程功能/内存功能讲解</strong></p><ul><li><p>VisualVM是什么？</p><ul><li>VisualVM是一个集成命令行JDK工具和轻量级分析功能的可视化工具</li></ul></li><li><p>VisualVM怎么用？</p><ul><li><p>在IDEA安装VisualVM插件，File-&gt; Setting-&gt; Plugins -&gt; Browers Repositrories 搜索VisualVM Launcher安装并重启IDEA</p></li><li><p>点击配置VisualVM executable执行路径</p><p>如： /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/bin/jvisualvm</p></li><li><p>eclipse配置教程原理相同</p></li></ul></li></ul><h3 id="第5集-可视化虚拟机工具VisualVM实战"><a href="#第5集-可视化虚拟机工具VisualVM实战" class="headerlink" title="第5集     可视化虚拟机工具VisualVM实战"></a>第5集     可视化虚拟机工具VisualVM实战</h3><p><strong>简介：VisualVM实战</strong></p><ul><li><p>VisualVM大对象模拟，HashMap和Integer大对象对应的在堆内存信息的展示</p><ul><li>dump内存实时情况</li></ul></li><li><p>学员需自己实战VisualVM部分内容</p><ul><li><p>怎么查看线程堆栈信息？</p></li><li><p>VisualVM怎么查看内存信息，堆信息，堆使用量大小</p></li></ul></li></ul><p>**<img src="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGoAAAAiCAMAAACA9LykAAAAY1BMVEUAAAAjJikjJiojJiokJigjJikkJigjJikjJikjJikjJikkJigjJiojJiokJigjJiomJiYmJibWABPWABMmJiYmJiYmJibWABN9Ex99Ex/WABMmJiYjJiqgoKB3d3dcXFxBQUEZhcyGAAAAG3RSTlMAQIC/MGAQz9+fj+8gr3BQv4C/gCCvUN+/gGCwJXa4AAACP0lEQVRIx72W2ZLbIBBFe2EVQrLHnslCZ/n/rwwoOCDH5CWyzxO2VJy63TQlGGAQFbwEhagpOseE8BpmzRL8Cq9h9iJOw2uYWYRneBb67LtTsYiEZwXDlE47s4g8x2VsVplXuJRLGbtzUXap4zOFYvr54x16rIiFo1lS4fu3sIuFzyjhe6qcocftYukJRrQn7c0Bp6a679bcfvHDLpMCEB/jVB8bWonB4EBlq8kDjCvYVF8vlwtpA4UoMauQGeU2kZYYfBhMb9oIV7gjq6YHqrdPb28sQUEGGUsq5/ymQvLi2MUwkX5Y6lRdCgpq6VT8SHUphYphLi8z9KnIol+w4HnUqpZLJ2/+UsWpqBQvVVVcjrYiFwE5RwSZWQHlJauyesA53bAA14RQ6VWxqKIIZD5/gYLnqkJEaxGxpRccj9UNDR+2XfBZFaFgRJUt1uAhw1T1N9Wy9KrAPFSppnJwPu2uQaqT0vWqqpToTaUAJsc82b6rQ0Jz4dJU9s8tSGavQkQKXAdiXmVhBuuriNgRjWL5pprQ9mPlunPKuykIWZ+Zg1ZuBea88oNUgwpalfpQ1G0/ja6lGYoKVJYbzHiLmRke4prLJFN3KKG6+xfhHygFGwYrQ9XUVB8O65nIIBxNf9zPJ9z+ka18/816Hw7vVMZLxsMBTOvwXPikAJ1kJjgEYuzr1/XKnRSLHPlthtZq08rXYSVz7BendmIJi+7aPJJ+ixCOZY3btuw3ScMjHI9ZvZUdzq8GngYiVTQeq/kFPvQz03kWbEEAAAAASUVORK5CYII=" alt="å°Dè¯¾å ">   愿景：”让编程不在难学，让技术与生活更加有趣”                  **</p><hr><h2 id="第9章-20W年薪面试必备实战篇"><a href="#第9章-20W年薪面试必备实战篇" class="headerlink" title="第9章   20W年薪面试必备实战篇"></a>第9章   20W年薪面试必备实战篇</h2><h3 id="第1集-教你如何剖析传统项目JVM问题"><a href="#第1集-教你如何剖析传统项目JVM问题" class="headerlink" title="第1集     教你如何剖析传统项目JVM问题"></a>第1集     教你如何剖析传统项目JVM问题</h3><p><strong>简介：20W年薪应该掌握哪些实战知识</strong></p><ul><li><p>关于JAVA项目分类</p><ul><li>传统项目容易遇到哪些JVM问题</li><li>互联网项目容易遇到哪些JVM问题</li></ul></li><li><p>实战案例讲解，传统公司遇到的上传下载问题</p><ul><li><p>项目介绍</p></li><li><p>项目特点分析</p></li><li><p>瓶颈分析</p><ul><li><p>是否是单接口性能问题？</p><p>如果是的是，先考虑是否有sql慢查询，定位慢查询的方法一般是用explain查看sql的执行计划   </p><p> select  * from user u where u.id=1;  ==&gt; explain select  * from user u where u.id=1;</p><p> 扫描行数是特别占CPU的，举个例子一个sql的扫描行数达到100w</p></li></ul></li></ul></li></ul><h3 id="第2集-FullGC与Minor的区别频繁FullGC问题分析"><a href="#第2集-FullGC与Minor的区别频繁FullGC问题分析" class="headerlink" title="第2集     FullGC与Minor的区别频繁FullGC问题分析"></a>第2集     FullGC与Minor的区别频繁FullGC问题分析</h3><p><strong>简介：FullGC与MinorGC讲解</strong></p><ul><li><p>Minor GC触发条件：当Eden区满时，触发Minor GC</p></li><li><p>FullGC触发条件</p><ul><li><p>调用 System.gc()<br>此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc()</p></li><li><p>老年代空间不足<br>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组</p></li><li><p>空间分配担保失败<br>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC</p></li></ul></li><li><p>此项目中出现频繁FullGC，也就是系统空间分配不足导致的系统堆内存强制回收</p></li><li><p>问题解决方法分析</p><ul><li>由于本机单服务内存过大导致，此场景下Full GC，而且需要回收的内存很大，持续时间过长</li><li>解决停顿时间过长问题，缩短GC时间</li></ul></li></ul><h3 id="第3集-下载导致的频繁FullGC问题演练与解决"><a href="#第3集-下载导致的频繁FullGC问题演练与解决" class="headerlink" title="第3集     下载导致的频繁FullGC问题演练与解决"></a>第3集     下载导致的频繁FullGC问题演练与解决</h3><p><strong>简介：FullGC演练</strong></p><ul><li>下载问题是什么问题？<ul><li>用户线程访问所导致的大对象问题</li></ul></li><li>怎么设计一个用户线程所导致的FullGC问题</li><li>解决这个问题的关键是什么?<ul><li>32G内存-xmx30G，系统每次进行FullGC时长太长</li><li>可以减少-xmx大小成4G，从而缩短Full GC</li><li>最终解决方案：集群部署，第一个节点4G  第二个节点4G   第三个节点4G   用nginx配置转发  upstream </li></ul></li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">-verbose</span>:<span class="built_in">gc</span> <span class="literal">-XX</span>:+PrintGCDetails <span class="literal">-XX</span>:+PrintGCTimeStamps</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第4集-互联网项目常见的JVM问题剖析"><a href="#第4集-互联网项目常见的JVM问题剖析" class="headerlink" title="第4集     互联网项目常见的JVM问题剖析"></a>第4集     互联网项目常见的JVM问题剖析</h3><p><strong>简介：互联网项目常见JVM问题讲述</strong></p><ul><li>为什么访问量大就越容易出问题<ul><li>判断一个用户是否在白名单    List.contain(用户) true，==》Set.contain(用户) 通过hash比较==》布隆过滤器 </li><li>结论==》用户量大和用户量小的项目遇到的问题和解决方案也就不一样</li></ul></li><li>案例1，关于死锁问题<ul><li>解决方案==》jstack -m命令查看帮我们检测是否有死锁，或者jconsole、jvisualVM也能检查</li><li>new Thread的时候最好带上名称</li></ul></li><li>案例2，堆内存泄漏问题<ul><li>现象：出现OOM或者Full GC，heap使用率明显上升，经常达到Xmx</li><li>Full GC出现的正常频率是大概一天一到两次</li><li>解决方案==》jmap dump下内存/heap dump on OOM/heap dump on FullGC+jhat本地分析/mat（eclipse），或者jconsole、jvisualVM也能检查</li></ul></li></ul><ul><li><p>案例3，堆外内存泄漏</p><ul><li><p>现象：heap使用率很低，但是出现了OOM或者Full GC</p></li><li><p>解决方案==》可以用btrace跟踪DirectByteBuffer的构造函数来定位</p></li></ul></li></ul><h3 id="第5集-互联网20W年薪学习秘笈分享"><a href="#第5集-互联网20W年薪学习秘笈分享" class="headerlink" title="第5集     互联网20W年薪学习秘笈分享"></a>第5集     互联网20W年薪学习秘笈分享</h3><ul><li>互联网学习秘笈</li><li>掌握学习秘笈提高效率巩固知识</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm java 必修 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付宝沙箱支付demo</title>
      <link href="2020/11/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98deomo/"/>
      <url>2020/11/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98deomo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程入门</title>
      <link href="2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
      <url>2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="概念入门"><a href="#概念入门" class="headerlink" title="概念入门"></a>概念入门</h4><h5 id="什么是并发编程"><a href="#什么是并发编程" class="headerlink" title="什么是并发编程"></a>什么是并发编程</h5><ul><li><p>什么是并发编程</p><p>并发历史: 早期计算机–从头到尾执行一个程序，资源浪费 操作系统出现–计算机能运行多个程序，不同的程序在不同的单独的进程中运行</p></li></ul><p>一个进程，有多个线程 提高资源的利用率，公平</p><ul><li><p>串行与并行的区别</p><p>串行：洗茶具、打水、烧水、等水开、冲茶 并行：打水、烧水同时洗茶具、水开、冲茶</p><p>好处：可以缩短整个流程的时间</p></li><li><p>并发编程目的</p><p>摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。这一定律揭示了信息技术进步的速度。 让程序充分利用计算机资源 加快程序响应速度（耗时任务、web服务器） 简化异步事件的处理</p></li><li><p>什么时候适合使用并发编程</p><p>任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况 任务执行时间过长，可以划分为分工明确的子任务：比如分段下载 任务间断性执行：日志打印 任务本身需要协作执行：比如生产者消费者问题</p></li></ul><h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p><strong>什么是上下文切换</strong></p><ul><li>cpu为线程分配时间片，时间片非常短（毫秒级别），cpu不停的切换线程执行，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，让我们感觉是多个程序同时运行的。</li><li>上下文的频繁切换，会带来一定的性能开销</li></ul><p><strong>如何减少上下文切换的开销？</strong></p><ul><li><p>无锁并发编程</p><p>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据</p></li><li><p>CAS</p><p>Java的Atomic包使用CAS算法来更新数据，而不需要加锁。使用最少线程</p></li><li><p>使用最少线程。</p><p>避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态</p></li><li><p>协程</p><p>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。–GO语言比较多</p></li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><ul><li>好比打架互掐，揪头发，你不放过我，我也不饶你。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xdclass.synopsis;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 死锁Demo</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public class DeadLockDemo &#123;</span><br><span class="line">        private static final Object HAIR_A &#x3D; new Object();</span><br><span class="line">        private static final Object HAIR_B &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                synchronized (HAIR_A) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(50L);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    synchronized (HAIR_B) &#123;</span><br><span class="line">                        System.out.println(&quot;A成功的抓住B的头发&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                synchronized (HAIR_B) &#123;</span><br><span class="line">                    synchronized (HAIR_A) &#123;</span><br><span class="line">                        System.out.println(&quot;B成功抓到A的头发&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>jps 查看pid      jstack+pid查看进程</p><p>或者直接 jconsole 检测死锁查看</p></li></ul><h4 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h4><ul><li><p><strong>进程和线程的关系</strong></p><ul><li>进程：是系统进行分配和管理资源的基本单位</li><li>线程：进程的一个执行单元，是进程内调度的实体、是CPU调度和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程,线程是程序执行的最小单位。</li><li>一个程序至少一个进程，一个进程至少一个线程。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。</li></ul><p>​     如何处理好同步与互斥是编写多线程程序的难点。 多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响， 而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题。</p></li><li><p><strong>状态及其相互转换</strong></p><ul><li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li><li>运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。</li><li>阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。</li><li>等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，它可以在指定的时间内自行返回。</li><li>终止(TERMINATED)：表示该线程已经执行完毕。</li></ul></li><li><p><strong>创建线程都方式</strong></p><ul><li>继承Thread，并重写父类的run方法</li><li>实现Runable接口，并实现run方法</li><li>使用匿名内部类</li><li>Lambda表达式</li><li>线程池</li></ul></li><li><p><strong>线程的挂起和恢复</strong></p><ul><li><p><strong>什么是挂起线程？</strong></p><p> 线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。 在线程挂起后，可以通过重新唤醒线程来使之恢复运行</p></li><li><p><strong>为什么要挂起线程？</strong></p><p>cpu分配的时间片非常短、同时也非常珍贵。避免资源的浪费。</p></li><li><p><strong>如何挂起线程？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">被废弃的方法 thread.suspend() </span><br><span class="line">该方法不会释放线程所占用的资源。如果使用该方法将某个线程挂起，则可能会使其他等待资源的线程死锁 </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread.resume() 方法</span><br><span class="line">本身并无问题，但是不能独立于suspend()方法存在 </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以使用的方法 ：</span><br><span class="line">wait() 暂停执行、放弃已经获得的锁、进入等待状态</span><br><span class="line">notify() 随机唤醒一个在等待锁的线程</span><br><span class="line">notifyAll() 唤醒所有在等待锁的线程，自行抢占cpu资源</span><br></pre></td></tr></table></figure></li><li><p><strong>什么时候适合使用挂起线程？</strong></p><p>我等的船还不来(等待某些未就绪的资源)，我等的人还不明白。直到notify方法被调用</p></li></ul></li><li><p><strong>线程的中断操作</strong></p><ul><li>stop() 废弃方法，开发中不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线程安全性问题</li><li>Thread.interrupt方法</li><li>自行定义一个标志，用来判断是否继续执行</li></ul></li><li><p><strong>线程的优先级</strong></p><ul><li><p>线程的优先级告诉程序该线程的重要程度有多大。如果有大量线程都被堵塞，都在等候运行，程序会尽可能地先运行优先级的那个线程。 但是，这并不表示优先级较低的线程不会运行。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。</p></li><li><p>线程的优先级设置可以为1-10的任一数值，Thread类中定义了三个线程优先级，分别是：MIN_PRIORITY（1）、NORM_PRIORITY（5）、MAX_PRIORITY（10），一般情况下推荐使用这几个常量，不要自行设置数值。</p></li><li><p>不同平台，对线程的优先级的支持不同。 编程的时候，不要过度依赖线程优先级，如果你的程序运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确</p></li><li><p>任务：</p><p>快速处理：设置高的优先级 慢慢处理：设置低的优先级</p></li></ul></li><li><p><strong>守护线程</strong></p><ul><li><p>线程分类：用户线程、守护线程 </p><p>守护线程：任何一个守护线程都是整个程序中所有用户线程的守护者，只要有活着的用户线程，守护线程就活着。当JVM实例中最后一个非守护线程结束时，也随JVM一起退出</p></li><li><p>守护线程的用处：jvm垃圾清理线程</p></li><li><p>建议： 尽量少使用守护线程，因其不可控，不要在守护线程里去进行读写操作、执行计算逻辑</p></li></ul></li></ul><h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞"></a>起飞</h3><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><h5 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h5><ul><li><p>当多个线程访问某个类,不管运行时环境采用何种调度方式或者这些线程如何交替执行,并且在主调代码中不需要任何额外的同步或协同,这个类都能表现出正确的行为,那么就称这个类为线程安全的。—-《并发编程实战》</p></li><li><p><strong>什么是线程不安全？</strong></p><p>多线程并发访问时，得不到正确的结果。</p></li></ul><h5 id="从字节码角度分析线程不安全操作"><a href="#从字节码角度分析线程不安全操作" class="headerlink" title="从字节码角度分析线程不安全操作"></a>从字节码角度分析线程不安全操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -encoding UTF-8  指定字节码编译</span><br><span class="line">javap -c 反编译</span><br></pre></td></tr></table></figure><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="image-20201118170522642"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: getstatic     #2               获取指定类的静态域，并将其押入栈顶</span><br><span class="line">3: iconst_1 将int型1押入栈顶</span><br><span class="line">4: iadd 将栈顶两个int型相加，将结果押入栈顶</span><br><span class="line">5: putstatic     #2               为指定类静态域赋值</span><br><span class="line">8: return</span><br></pre></td></tr></table></figure><p>注意：究极原因++操作不是原子操作</p><h5 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h5><ul><li><p><strong>什么是原子性操作</strong></p><p>一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。（和mysql事务里的原子性感觉相差无几，要么都成功，要么都失败）</p></li><li><p><strong>如何变成原子操作</strong></p><ul><li>volatile关键字只能保证可见性，不能保证原子性</li><li>synchronized关键字可以保证原子性</li></ul></li></ul><h5 id="简单理解synchronized"><a href="#简单理解synchronized" class="headerlink" title="简单理解synchronized"></a>简单理解synchronized</h5><ul><li><p>内置锁</p><pre><code>        每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</code></pre></li><li><p>互斥锁</p><pre><code>    内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</code></pre></li><li><p>synchronized用法：</p><p>​    修饰普通方法：锁住对象的实例，不同对象不会竞争锁<br>​    修饰静态方法：锁住整个类，不同对象会竞争锁<br>​    修饰代码块： 锁住一个对象 synchronized (lock) 即synchronized后面括号里的内容</p></li></ul><h5 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h5><ul><li>能且仅能修饰变量</li><li>保证该变量的可见性，volatile关键字仅仅保证可见性，并不保证原子性</li><li>禁止指令重排序</li><li>A、B两个线程同时读取volatile关键字修饰的对象，A读取之后，修改了变量的值,修改后的值，对B线程来说，是可见</li><li>使用场景 1：作为线程开关 2：单例，修饰对象实例，禁止指令重排序</li></ul><h5 id="单例与线程安全"><a href="#单例与线程安全" class="headerlink" title="单例与线程安全"></a>单例与线程安全</h5><ul><li><p>饿汉式–本身线程安全</p><p>在类加载的时候，就已经进行实例化，无论之后用不用到。如果该类比较占内存，之后又没用到，就白白浪费了资源。</p></li><li><p>懒汉式 – 最简单的写法是非线程安全的，在需要的时候再实例化</p></li></ul><h5 id="避免线程安全性问题"><a href="#避免线程安全性问题" class="headerlink" title="避免线程安全性问题"></a>避免线程安全性问题</h5><ul><li><p>线程安全性问题成因</p><ul><li>多线程环境</li><li>多个线程操作同一共享资源</li><li>对该共享资源进行了非原子性操作</li></ul></li><li><p>如何避免<br>打破成因中三点任意一点</p><ul><li>多线程环境–将多线程改单线程（必要的代码，加锁访问）</li><li>多个线程操作同一共享资源–不共享资源（ThreadLocal、不共享、操作无状态化、不可变——比如final修饰）</li><li>对该共享资源进行了非原子性操作– 将非原子性操作改成原子性操作（加锁、使用JDK自带的原子性操作的类、JUC提供的相应的并发工具类）</li></ul></li></ul><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h5><ul><li>自旋锁： 线程状态及上下文切换消耗系统资源，当访问共享资源的时间短，频繁上下文切换不值得。jvm实现，使线程在没获得锁的时候，不被挂起，转而执行空循环，循环几次之后，如果还没能获得锁，则被挂起</li><li>阻塞锁：阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态</li><li>重入锁:支持线程再次进入的锁,就跟我们有房间钥匙，可以多次进入房间类似</li><li>读写锁： 两把锁，读锁跟写锁，写写互斥、读写互斥、读读共享</li><li>互斥锁： 上厕所，进门之后就把门关了，不让其他人进来</li><li>悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁</li><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。（mysql的version机制）</li><li>公平锁：大家都老老实实排队，对大家而言都很公平</li><li>非公平锁：一部分人排着队，但是新来的可能插队</li><li>偏向锁：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</li><li>独占锁：独占锁模式下，每次只能有一个线程能持有锁</li><li>共享锁：允许多个线程同时获取锁，并发访问共享资源</li></ul><h5 id="深入理解lock接口"><a href="#深入理解lock接口" class="headerlink" title="深入理解lock接口"></a>深入理解lock接口</h5><ul><li><p>lock的使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock mylock &#x3D; new ReentrantLock();</span><br><span class="line">&#x2F;&#x2F;手动加锁</span><br><span class="line">mylock.lock();</span><br><span class="line">&#x2F;&#x2F;手动解锁</span><br><span class="line">mylock.unlock();</span><br></pre></td></tr></table></figure></li><li><p>synchronized和lock锁的区别</p><ul><li><p>lock 获取锁与释放锁的过程，都需要程序员手动的控制 </p></li><li><p>Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作 </p></li><li><p>synchronized托管给jvm执行 原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。</p></li></ul></li><li><p>lock实现类</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB" alt="image-20201118192050223"></p></li><li><p>lock里的方法</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E6%96%B9%E6%B3%95" alt="image-20201118192222720"></p></li></ul><h5 id="写一个锁"><a href="#写一个锁" class="headerlink" title="写一个锁"></a>写一个锁</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package net.zyaire.lock.mylock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isHoldLock &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private Thread holdLockThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private int reentryCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 同一时刻，能且仅能有一个线程获取到锁，</span><br><span class="line">     * 其他线程，只能等待该线程释放锁之后才能获取到锁</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void lock() &#123;</span><br><span class="line">        if (isHoldLock &amp;&amp; Thread.currentThread() !&#x3D; holdLockThread) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        holdLockThread &#x3D; Thread.currentThread();</span><br><span class="line">        isHoldLock &#x3D; true;</span><br><span class="line">        reentryCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void unlock() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断当前线程是否是持有锁的线程，是，重入次数减去1，不是就不做处理</span><br><span class="line">        if (Thread.currentThread() &#x3D;&#x3D; holdLockThread) &#123;</span><br><span class="line">            reentryCount--;</span><br><span class="line">            if (reentryCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                isHoldLock &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="浅入AQS"><a href="#浅入AQS" class="headerlink" title="浅入AQS"></a>浅入AQS</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/AQS%E7%9A%84public%E6%96%B9%E6%B3%95" alt="image-20201118194744682"></p><ul><li><p>主要方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  acqiure(相当于加锁)</span><br><span class="line">  release(相当于释放锁)</span><br><span class="line">addwaiter(加入等待队列)</span><br><span class="line">  isHeldExclusively(是否是独占锁)</span><br></pre></td></tr></table></figure></li></ul><h5 id="Reentrantlock非公平锁"><a href="#Reentrantlock非公平锁" class="headerlink" title="Reentrantlock非公平锁"></a>Reentrantlock非公平锁</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="ReentranLock非公平和公平锁的实现"></p><ul><li><p><strong>lock()</strong></p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%8A%A0%E9%94%81.png" alt="ReentranLock加锁"></p><p>1.进入aquire（）</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%85%AC%E5%B9%B3%E9%94%81aquire%E9%80%BB%E8%BE%91.png" alt="ReentranLock公平锁aquire逻辑"></p><ul><li>tryaquire(arg)尝试获得锁，aquireQueued（）加入等待队列。</li><li>假如既没有获得锁成功，也没有成功假如等待队列，就会执行selfInterrupt（）方法；</li></ul><p>2.进入selfInterrupt（），调用的是线程的interrupt（）方法</p><p>3.tryAquire()逻辑，具体实现在其子类NonfairSync（）实现</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/Reentranlock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0.png" alt="Reentranlock非公平锁加锁具体实现"></p><p>注意是compareAndSetState(0, acquires)进行都操作，即是CAS操作</p><p>4.加入队列的操作</p><p>//TODO</p></li><li><p><strong>unlock()</strong></p></li></ul><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E8%A7%A3%E9%94%81%E9%80%BB%E8%BE%91.png" alt="ReentranLock解锁逻辑"></p><ol><li><p>进入release()</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E9%87%8A%E6%94%BE%E9%94%81.png" alt="ReentranLock释放锁"></p><p>首先会tryRelease()，成功会唤起等待队列里面的线程</p></li><li><p>tryRelease()逻辑</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/tryRelease%E9%80%BB%E8%BE%91" alt="image-20201119160236412"></p></li></ol><h5 id="Reentrantlock公平锁"><a href="#Reentrantlock公平锁" class="headerlink" title="Reentrantlock公平锁"></a>Reentrantlock公平锁</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81" alt="image-20201119163132797"></p><h5 id="如何多线程debug"><a href="#如何多线程debug" class="headerlink" title="如何多线程debug"></a>如何多线程debug</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug" alt="image-20201119164635268"></p><h5 id="读写锁ReentrantReadlock"><a href="#读写锁ReentrantReadlock" class="headerlink" title="读写锁ReentrantReadlock"></a>读写锁ReentrantReadlock</h5><ul><li><strong>readLock（）</strong></li></ul><p><strong>lock操作</strong></p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/readLock()" alt="image-20201119172020524"></p><p>读锁具体实现之tryAcquireShared（）</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81%E5%86%99%E9%94%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" alt="image-20201119180216772"></p><p>读锁具体实现之doAcquireShared（）</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81doAcquire" alt="image-20201119181023428"></p><p><strong>unlock操作</strong></p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81releaseShared" alt="image-20201119181411049"></p><ul><li><h5 id="unLock（）-TODO"><a href="#unLock（）-TODO" class="headerlink" title="unLock（）//TODO"></a>unLock（）//TODO</h5><p>ps：差不多一样，更简单。</p></li></ul><h5 id="解密AQS如何用单一int值表示读写两种状态"><a href="#解密AQS如何用单一int值表示读写两种状态" class="headerlink" title="解密AQS如何用单一int值表示读写两种状态"></a>解密AQS如何用单一int值表示读写两种状态</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int 是32位，将其拆分成两个无符号short</span><br><span class="line">    高位表示读锁          低位表示写锁</span><br><span class="line">    0000000000000000   0000000000000000</span><br><span class="line"></span><br><span class="line">两种锁的最大次数均为65535也即是2的16次方减去1</span><br><span class="line">    读锁： 每次都从当前的状态加上65536</span><br><span class="line">    0000000000000000   0000000000000000</span><br><span class="line">    ‭0000000000000001   0000000000000000‬</span><br><span class="line">    -----------------------------------</span><br><span class="line">    0000000000000001   0000000000000000‬</span><br><span class="line">    0000000000000001   0000000000000000‬</span><br><span class="line">    -----------------------------------</span><br><span class="line">    0000000000000010   0000000000000000‬</span><br><span class="line"></span><br><span class="line">    获取读锁个数，将state整个无符号右移16位就可得出读锁的个数</span><br><span class="line">                       0000000000000001 </span><br><span class="line"></span><br><span class="line">    写锁：每次都直接加1</span><br><span class="line">    0000000000000000   0000000000000000</span><br><span class="line">    0000000000000000   0000000000000001</span><br><span class="line">    -----------------------------------</span><br><span class="line">    0000000000000000   0000000000000001</span><br><span class="line"></span><br><span class="line">    获取写锁的个数</span><br><span class="line">    0000000000000000   0000000000000001</span><br><span class="line">    ‭0000000000000000   1111111111111111‬   </span><br><span class="line">    ----------------------------------- </span><br><span class="line">    0000000000000000   0000000000000001</span><br></pre></td></tr></table></figure><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><ul><li><p>锁降级：写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性。</p><p>注意点：锁降级之后，写锁并不会直接降级成读锁，不会随着读锁的释放而释放，因此需要显式地释放写锁</p></li><li><p>是否有锁升级？</p><p>在ReentrantReadWriteLock里面，不存在锁升级这一说法</p></li><li><p>锁降级的应用场景</p><p>用于对数据比较敏感，需要在对数据修改之后，获取到修改后的值，并进行接下来的其他操作</p></li></ul><h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><ul><li><p><strong>1.8之前，锁已经那么多了，为什么还要有StampedLock？</strong></p><p>一般应用，都是读多写少，ReentrantReadWriteLock 因读写互斥，故读时阻塞写，因而性能上上不去。可能会使写线程饥饿</p></li><li><p>StampedLock的特点</p><p>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功； 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致； StampedLock是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁） 支持锁升级跟锁降级 可以乐观读也可以悲观读 使用有限次自旋，增加锁获得的几率，避免上下文切换带来的开销 乐观读不阻塞写操作，悲观读，阻塞写得操作</p></li><li><p>StampedLock的优点</p><p>相比于ReentrantReadWriteLock，吞吐量大幅提升</p></li><li><p>StampedLock的缺点</p><p>api相对复杂，容易用错 内部实现相比于ReentrantReadWriteLock复杂得多</p></li><li><p>StampedLock的原理</p><p>每次获取锁的时候，都会返回一个邮戳（stamp），相当于mysql里的version字段 释放锁的时候，再根据之前的获得的邮戳，去进行锁释放</p></li><li><p>使用stampedLock注意点</p><p>如果使用乐观读，一定要判断返回的邮戳是否是一开始获得到的，如果不是，要去获取悲观读锁，再次去读取</p><p>官方Demo：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * StampedLock Demo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StampedLockDemo &#123;</span><br><span class="line">    &#x2F;&#x2F; 成员变量</span><br><span class="line">    private double x, y;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 锁实例</span><br><span class="line">    private final StampedLock sl &#x3D; new StampedLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 排它锁-写锁（writeLock）</span><br><span class="line">    void move(double deltaX, double deltaY) &#123;</span><br><span class="line">        long stamp &#x3D; sl.writeLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            x +&#x3D; deltaX;</span><br><span class="line">            y +&#x3D; deltaY;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 乐观读锁</span><br><span class="line">    double distanceFromOrigin() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 尝试获取乐观读锁（1）</span><br><span class="line">        long stamp &#x3D; sl.tryOptimisticRead();</span><br><span class="line">        &#x2F;&#x2F; 将全部变量拷贝到方法体栈内（2）</span><br><span class="line">        double currentX &#x3D; x, currentY &#x3D; y;</span><br><span class="line">        &#x2F;&#x2F; 检查在（1）获取到读锁票据后，锁有没被其他写线程排它性抢占（3）</span><br><span class="line">        if (!sl.validate(stamp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果被抢占则获取一个共享读锁（悲观获取）（4）</span><br><span class="line">            stamp &#x3D; sl.readLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 将全部变量拷贝到方法体栈内（5）</span><br><span class="line">                currentX &#x3D; x;</span><br><span class="line">                currentY &#x3D; y;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 释放共享读锁（6）</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回计算结果（7）</span><br><span class="line">        return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用悲观锁获取读锁，并尝试转换为写锁</span><br><span class="line">    void moveIfAtOrigin(double newX, double newY) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里可以使用乐观读锁替换（1）</span><br><span class="line">        long stamp &#x3D; sl.readLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前点在原点则移动（2）</span><br><span class="line">            while (x &#x3D;&#x3D; 0.0 &amp;&amp; y &#x3D;&#x3D; 0.0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 尝试将获取的读锁升级为写锁（3）</span><br><span class="line">                long ws &#x3D; sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                &#x2F;&#x2F; 升级成功，则更新票据，并设置坐标值，然后退出循环（4）</span><br><span class="line">                if (ws !&#x3D; 0L) &#123;</span><br><span class="line">                    stamp &#x3D; ws;</span><br><span class="line">                    x &#x3D; newX;</span><br><span class="line">                    y &#x3D; newY;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 读锁升级写锁失败则释放读锁，显示获取独占写锁，然后循环重试（5）</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp &#x3D; sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁（6）</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><h5 id="wait，notify，notifyAll"><a href="#wait，notify，notifyAll" class="headerlink" title="wait，notify，notifyAll"></a>wait，notify，notifyAll</h5><ul><li><p>何时使用 在多线程环境下，有时候一个线程的执行，依赖于另外一个线程的某种状态的改变，这个时候，我们就可以使用wait与notify或者notifyAll</p></li><li><p>wait跟sleep的区别 wait会释放持有的锁，而sleep不会，sleep只是让线程在指定的时间内，不去抢占cpu的资源 注意点 wait notify必须放在同步代码块中, 且必须拥有当前对象的锁，即不能取得A对象的锁，而调用B对象的wait 哪个对象wait，就得调哪个对象的notify</p></li><li><p>notify跟notifyAll的区别</p><p>nofity随机唤醒一个等待的线程 notifyAll唤醒所有在该对象上等待的线程</p></li></ul><h5 id="等待通知经典模型之生产者消费者"><a href="#等待通知经典模型之生产者消费者" class="headerlink" title="等待通知经典模型之生产者消费者"></a>等待通知经典模型之生产者消费者</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="生产者消费者"></p><p>//TODO 代码太长</p><h5 id="使用管道流进行通信"><a href="#使用管道流进行通信" class="headerlink" title="使用管道流进行通信"></a>使用管道流进行通信</h5><ul><li><p>以内存为媒介，用于线程之间的数据传输。</p></li><li><p>主要有面向字节：【PipedOutputStream、PipedInputStream】、面向字符【PipedReader、PipedWriter】</p></li><li><p>reader</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">public class Reader implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private PipedInputStream pipedInputStream;</span><br><span class="line"></span><br><span class="line">    public Reader(PipedInputStream pipedInputStream) &#123;</span><br><span class="line">        this.pipedInputStream &#x3D; pipedInputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (pipedInputStream !&#x3D; null) &#123;</span><br><span class="line">            String collect &#x3D; new BufferedReader(new InputStreamReader(pipedInputStream)).lines().collect(Collectors.joining(&quot;\n&quot;));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +collect);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            pipedInputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        PipedInputStream pipedInputStream &#x3D; new PipedInputStream();</span><br><span class="line">        PipedOutputStream pipedOutputStream &#x3D; new PipedOutputStream();</span><br><span class="line"></span><br><span class="line">        pipedOutputStream.connect(pipedInputStream);</span><br><span class="line"></span><br><span class="line">        new Thread(new Reader(pipedInputStream)).start();</span><br><span class="line">        BufferedReader bufferedReader &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bufferedReader &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            pipedOutputStream.write(bufferedReader.readLine().getBytes());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            pipedOutputStream.close();</span><br><span class="line">            if (bufferedReader !&#x3D; null) &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Thread-join（）方法"><a href="#Thread-join（）方法" class="headerlink" title="Thread.join（）方法"></a>Thread.join（）方法</h5><ul><li>使用场景：线程A执行到一半，需要一个数据，这个数据需要线程B去执行修改，只有B修改完成之后，A才能继续操作。线程A的run方法里面，调用线程B的join方法，这个时候，线程A会等待线程B运行完成之后，再接着运行</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;开始运行&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;结束运行&quot;);</span><br><span class="line">        &#125;, &quot;线程1&quot;);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;开始运行&quot;);</span><br><span class="line">            thread.start();&#x2F;&#x2F;这里调用start,程序不会按预期进行</span><br><span class="line">            try &#123;</span><br><span class="line">&#x2F;&#x2F;调用join方法,结果:线程2开始---&gt;线程1开始---&gt;线程1结束----&gt;线程2结束</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;运行结束&quot;);</span><br><span class="line">        &#125;, &quot;线程2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join()方法可以传参，相当于wait()</p><h5 id="Threadlocal的使用"><a href="#Threadlocal的使用" class="headerlink" title="Threadlocal的使用"></a>Threadlocal的使用</h5><ul><li>线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。为每个线程单独存放一份变量副本，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。只要线程处于活动状态并且ThreadLocal实例可访问，那么每个线程都拥有对其本地线程副本的隐式引用变量一个线程消失后，它的所有副本线程局部实例受垃圾回收（除非其他存在对这些副本的引用）</li><li>一般用的比较多的是 <ul><li>ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。 </li><li>ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。 </li><li>ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。 </li><li>ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。</li></ul></li></ul><h5 id="condition的使用"><a href="#condition的使用" class="headerlink" title="condition的使用"></a>condition的使用</h5><ul><li>可以在一个锁里面，存在多种等待条件</li><li>主要的方法 await signal signalAll</li></ul><h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><ul><li><p>一度认为原子是不可分割的最小单位，故原子类可以认为其操作都是不可分割</p></li><li><p><strong>为什么要有原子类？</strong></p><p>对多线程访问同一个变量，我们需要加锁，而锁是比较消耗性能的，JDk1.5之后， 新增的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的.方式， 这些类同样位于JUC包下的atomic包下，发展到JDk1.8，该包下共有17个类， 囊括了原子更新基本类型、原子更新数组、原子更新属性、原子更新引用</p></li><li><p>1.8新增的原子类</p><p>DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64</p></li></ul><h5 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h5><ul><li><p>发展至JDk1.8，基本类型原子类有以下几个：</p><p>AtomicBoolean、AtomicInteger、AtomicLong、DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p></li><li><p>大致可以归为3类</p><ul><li>AtomicBoolean、AtomicInteger、AtomicLong 元老级的原子更新，方法几乎一模一样 </li></ul><p><strong>AutomicInterger</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化实例</span><br><span class="line">    private static AtomicInteger sum &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void inCreate() &#123;</span><br><span class="line">        sum.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 100; j++) &#123;</span><br><span class="line">                    inCreate();</span><br><span class="line">                    System.out.println(sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DoubleAdder、LongAdder 对Double、Long的原子更新性能进行优化提升 </li><li>DoubleAccumulator、LongAccumulator 支持自定义运算</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;输入一个数字，如果比上一个输入的大，则直接返回，如果小，则返回上一个</span><br><span class="line">        LongAccumulator longAccumulator &#x3D; new LongAccumulator((left, right) -&gt;</span><br><span class="line">        &#x2F;&#x2F;可以自定义逻辑</span><br><span class="line">                left * right, 0L</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        longAccumulator.accumulate(3L);</span><br><span class="line">        System.out.println(longAccumulator.get());</span><br><span class="line">        longAccumulator.accumulate(5L);</span><br><span class="line">        System.out.println(longAccumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="原子更新数组类型"><a href="#原子更新数组类型" class="headerlink" title="原子更新数组类型"></a>原子更新数组类型</h5><ul><li><p>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * AtomicIntegerArray Demo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AtomicIntegerArrayDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;3, 2&#125;;</span><br><span class="line">        AtomicIntegerArray atomicIntegerArray &#x3D; new AtomicIntegerArray(arr);</span><br><span class="line">        System.out.println(atomicIntegerArray.addAndGet(1, 8));&#x2F;&#x2F;第一个入参是数组的下标，执行结果为10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义逻辑，支持lamada表达式</span><br><span class="line">        int i &#x3D; atomicIntegerArray.accumulateAndGet(0, 2, (left, right) -&gt;</span><br><span class="line">                left * right &#x2F; 3</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="原子地更新属性"><a href="#原子地更新属性" class="headerlink" title="原子地更新属性"></a>原子地更新属性</h5><ul><li><p>原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下4个类进行原子字段更新 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicStampedReference、AtomicReferenceFieldUpdater</p><p><strong>AtomicIntegerFieldUpdater</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicLongFieldUpdater;</span><br><span class="line">import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * AtomicLongFieldUpdaterDemo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AtomicLongFieldUpdaterDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicLongFieldUpdater&lt;Student&gt; longFieldUpdater &#x3D; AtomicLongFieldUpdater.newUpdater(Student.class, &quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        Student xdclass &#x3D; new Student(1L, &quot;xdclass&quot;);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F;第二个入参的是第几个字段,从1开始  </span><br><span class="line">        longFieldUpdater.compareAndSet(xdclass, 1L, 100L);</span><br><span class="line">        System.out.println(&quot;id&#x3D;&quot;+xdclass.getId());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二个为要修改的类型，第三个为要修改的字段</span><br><span class="line">        AtomicReferenceFieldUpdater&lt;Student, String&gt; referenceFieldUpdater &#x3D; AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, &quot;name&quot;);</span><br><span class="line">        referenceFieldUpdater.compareAndSet(xdclass, &quot;xdclass&quot;, &quot;wiggin&quot;);</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+xdclass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;必须以volatile修饰，并且是基本数据类型，不能用包装类型</span><br><span class="line">    volatile long id;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    volatile String name;</span><br><span class="line"></span><br><span class="line">    public Student(Long id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用上述类的时候，必须遵循以下原则</span><br><span class="line">字段必须是volatile类型的，在线程之间共享变量时保证立即可见</span><br><span class="line">字段的描述类型是与调用者与操作对象字段的关系一致。</span><br><span class="line">也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。</span><br><span class="line">对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</span><br><span class="line">只能是实例变量，不能是类变量，也就是说不能加static关键字。</span><br><span class="line">只能是可修改变量，不能使final变量，因为final的语义就是不可修改。</span><br><span class="line">对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int&#x2F;long类型的字段，不能修改其包装类型（Integer&#x2F;Long）。</span><br><span class="line">如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</span><br></pre></td></tr></table></figure></li></ul><h5 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h5><ul><li>AtomicReference：用于对引用的原子更新</li><li>AtomicMarkableReference：带版本戳的原子引用类型，版本戳为boolean类型。</li><li>AtomicStampedReference：带版本戳的原子引用类型，版本戳为int类型。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * AtomicReferenceDemo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AtomicReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicReference&lt;Student&gt; studentAtomicReference &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line">        Student student &#x3D; new Student(1L, &quot;xdclass&quot;);</span><br><span class="line">        Student student1 &#x3D; new Student(2L, &quot;wiggin&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果不先把要CAS的对象set进去的话,最后get会报空指针异常</span><br><span class="line">        studentAtomicReference.set(student);</span><br><span class="line">        studentAtomicReference.compareAndSet(student, student1);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;必需通过get获取CAS后的对象</span><br><span class="line">        Student student2 &#x3D; studentAtomicReference.get();</span><br><span class="line">        System.out.println(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(long id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="同步容器和并发容器"><a href="#同步容器和并发容器" class="headerlink" title="同步容器和并发容器"></a>同步容器和并发容器</h5><ul><li><p>同步容器</p><p>Vector、HashTable – JDK提供的同步容器类 Collections.synchronizedXXX 本质是对相应的容器进行包装</p></li><li><p>同步容器类的缺点</p><p>在单独使用里面的方法的时候，可以保证线程安全。但是，复合操作需要额外加锁来保证线程安全 使用Iterator迭代容器或使用for-each遍历容器，在迭代过程中修改容器会抛出ConcurrentModificationException异常。想要避免出现ConcurrentModificationException，就必须在迭代过程持有容器的锁。但是若容器较大，则迭代的时间也会较长。那么需要访问该容器的其他线程将会长时间等待。从而会极大降低性能。 </p><p>若不希望在迭代期间对容器加锁，可以使用”克隆”容器的方式。使用线程封闭，由于其他线程不会对容器进行修改，可以避免ConcurrentModificationException。但是在创建副本的时候，存在较大性能开销。 toString，hashCode，equalse，containsAll，removeAll，retainAll等方法都会隐式的Iterate，也即可能抛出ConcurrentModificationException。</p></li><li><p>并发容器</p><p>CopyOnWrite、Concurrent、BlockingQueue 根据具体场景进行设计，尽量避免使用锁，提高容器的并发访问性。</p><p> ConcurrentBlockingQueue：基于queue实现的FIFO的队列。队列为空，取操作会被阻塞 </p><p>ConcurrentLinkedQueue，队列为空，取得时候就直接返回空</p></li></ul><h5 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h5><ul><li><p>  public static void main(String[] args) {</p><pre><code>  Vector&lt;String&gt; stringVector = new Vector&lt;&gt;();  for (int i = 0; i &lt; 1000; i++) &#123;      stringVector.add(&quot;demo&quot; + i);  &#125;  //错误遍历 stringVector.forEach(e-&gt;&#123;     if (e.equals(&quot;demo3&quot;)) &#123;         stringVector.remove(e);     &#125;     System.out.println(e); &#125;);  //正确迭代  Iterator&lt;String&gt; stringIterator = stringVector.iterator(); while (stringIterator.hasNext()) &#123;     String next = stringIterator.next();     if (next.equals(&quot;demo2&quot;)) &#123;         stringIterator.remove();     &#125; &#125;  //模拟多线程修改  Iterator&lt;String&gt; stringIterator2 = stringVector.iterator();  for (int i = 0; i &lt; 4; i++) &#123;      new Thread(() -&gt; &#123;          //不加synchronized会报错          synchronized (stringIterator2) &#123;              while (stringIterator2.hasNext()) &#123;                  String next = stringIterator2.next();                  if (next.equals(&quot;demo2&quot;)) &#123;                      stringIterator2.remove();                  &#125;              &#125;          &#125;      &#125;).start();  &#125;</code></pre><p>  }</p></li></ul><h5 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h5><pre><code>public static void main(String[] args) &#123;    CopyOnWriteArrayList&lt;String&gt; strings = new CopyOnWriteArrayList&lt;&gt;();    for (int i = 0; i &lt; 1000; i++) &#123;        strings.add(&quot;demo&quot; + i);    &#125;    //不会报错   strings.forEach(e-&gt;&#123;       if (e.equals(&quot;demo2&quot;)) &#123;           strings.remove(e);       &#125;   &#125;);   //不支持在迭代器里直接remove的操作, 会直接报错   Iterator&lt;String&gt; iterator = strings.iterator();   while (iterator.hasNext()) &#123;       String next = iterator.next();       if (next.equals(&quot;demo2&quot;)) &#123;           iterator.remove();       &#125;   &#125;    //然鹅多线程修改并不会报错    for (int i = 0; i &lt; 4; i++) &#123;        new Thread(() -&gt; &#123;            strings.forEach(e -&gt; &#123;                if (e.equals(&quot;demo2&quot;)) &#123;                    strings.remove(e);                &#125;            &#125;);        &#125;).start();    &#125;&#125;</code></pre><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><ul><li><p>为什么用</p><p>在并发编程中，LinkedBlockingQueue使用的非常频繁。因其可以作为生产者消费者的中间商</p></li><li><p>常用方法</p><p>add  实际上调用的是offer，区别是在队列满的时候，add会报异常</p><p>offer  对列如果满了，直接入队失败</p></li></ul><p>  put(“111”); 在队列满的时候，会进入阻塞的状态  </p><p>  remove(); 直接调用poll，唯一的区别即使remove会抛出异常，而poll在队列为空的时候直接返回null<br>  poll(); 在队列为空的时候直接返回null<br>  take(); 在队列为空的时候，会进入等待的状态   </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        LinkedBlockingQueue&lt;String&gt; strings &#x3D; new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;往队列里存元素</span><br><span class="line">        strings.add(&quot;111&quot;);</span><br><span class="line">        strings.offer(&quot;111&quot;);</span><br><span class="line">        strings.put(&quot;111&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;从队列中取元素</span><br><span class="line">        String remove &#x3D; strings.remove();</span><br><span class="line">        strings.poll();</span><br><span class="line">        strings.take();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h4><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><ul><li>await(),进入等待的状态</li><li>countDown(),计数器减一</li><li>应用场景：启动三个线程计算，需要对结果进行累加</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(8);</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;800米比赛结束，准备清空跑道并继续跨栏比赛&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">            int finalI &#x3D; i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(finalI * 1000L);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;到达终点&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier–栅栏"><a href="#CyclicBarrier–栅栏" class="headerlink" title="CyclicBarrier–栅栏"></a>CyclicBarrier–栅栏</h5><ul><li><p>允许一组线程相互等待达到一个公共的障碍点，之后再继续执行</p></li><li><p>跟countDownLatch的区别</p><p>CountDownLatch一般用于某个线程等待若干个其他线程执行完任务之后，它才执行；不可重复使用 CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；可重用的</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xdclass.tool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(8);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">            int finalI &#x3D; i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(finalI * 1000L);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;准备就绪&quot;);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;开始比赛&quot;);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Semaphore–信号量"><a href="#Semaphore–信号量" class="headerlink" title="Semaphore–信号量"></a>Semaphore–信号量</h5><ul><li>控制并发数量</li><li>使用场景：接口限流</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;必须获得信号量才可以执行</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;开始执行&quot;);</span><br><span class="line">                    Thread.sleep(5000L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F;用完之后必须释放</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h5><ul><li>用于交换数据</li><li>它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger的重点是成对的线程使用exchange()方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是   <strong>成对</strong>   的。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line">public class ExchangerDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;String&gt; stringExchanger &#x3D; new Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String str1 &#x3D; &quot;xdclass&quot;;</span><br><span class="line">        String str2 &#x3D; &quot;wiggin&quot;;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + str1);</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange &#x3D; stringExchanger.exchange(str1);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;交換后的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + str2);</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange &#x3D; stringExchanger.exchange(str2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;交換后的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程2&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新增一个线程执行exchange, 程序会一直卡着(必须要有一个线程的exchange和他匹配!!!)</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + str2);</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange &#x3D; stringExchanger.exchange(str2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;交換后的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程3&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池及Executor框架"><a href="#线程池及Executor框架" class="headerlink" title="线程池及Executor框架"></a>线程池及Executor框架</h4><h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">诸如 Web 服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务。请求以某种方式到达服务器，这种方式可能是通过网络协议（例如 HTTP、FTP ）、通过 JMS队列或者可能通过轮询数据库。不管请求如何到达，服务器应用程序中经常出现的情况是：单个任务处理的时间很短而请求的数目却是巨大的。每当一个请求到达就创建一个新线程，然后在新线程中为请求服务，但是频繁的创建线程，销毁线程所带来的系统开销其实是非常大的。</span><br><span class="line">线程池为线程生命周期开销问题和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。其好处是，因为在请求到达时线程已经存在，所以无意中也消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。而且，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。</span><br><span class="line">风险与机遇</span><br><span class="line">    用线程池构建的应用程序容易遭受任何其它多线程应用程序容易遭受的所有并发风险，</span><br><span class="line">    诸如同步错误和死锁，它还容易遭受特定于线程池的少数其它风险，诸如与池有关的死锁、资源不足和线程泄漏。</span><br></pre></td></tr></table></figure><h5 id="创建线程池及使用"><a href="#创建线程池及使用" class="headerlink" title="创建线程池及使用"></a>创建线程池及使用</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0" alt="image-20201120162227498"></p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E5%9B%BE%E7%A4%BA" alt="image-20201120162307754"></p><p>线程池的创建和使用</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BD%BF%E7%94%A8"></p><h5 id="Future与Callable、FutureTask"><a href="#Future与Callable、FutureTask" class="headerlink" title="Future与Callable、FutureTask"></a>Future与Callable、FutureTask</h5><ul><li>Callable与Runable功能相似，Callable的call有返回值，可以返回给客户端，而Runable没有返回值，一般情况下，Callable与FutureTask一起使用，或者通过线程池的submit方法返回相应的Future</li><li>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。get方法会阻塞，直到任务返回结果</li><li>FutureTask则是一个RunnableFuture，而RunnableFuture实现了Runnbale又实现了Futrue这两个接口</li></ul><p>FutureTask</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/FutureTask%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3" alt="image-20201120164134227"></p><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class CallableDemo implements Callable&lt;String&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(3000L);</span><br><span class="line">        return &quot;1111&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CallableDemo callableDemo &#x3D; new CallableDemo();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;callable的实现类不能直接使用</span><br><span class="line">        FutureTask&lt;String&gt; stringFutureTask &#x3D; new FutureTask&lt;&gt;(callableDemo);\</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;FutureTask实现了Rnnable接口</span><br><span class="line">        new Thread(stringFutureTask).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过get拿到返回值</span><br><span class="line">        System.out.println(stringFutureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程池核心组成部分"><a href="#线程池核心组成部分" class="headerlink" title="线程池核心组成部分"></a>线程池核心组成部分</h5><ul><li><p>构造参数</p><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E5%9B%BE%E7%A4%BA" alt="image-20201120162307754"></p><ul><li>corePoolSize：核心线程池大小 cSize</li><li>maximumPoolSize：线程池最大容量 mSize</li><li>keepAliveTime：当线程数量大于核心时，多余的空闲线程在终止之前等待新任务的最大时间。</li><li>unit：时间单位</li><li>workQueue:工作队列 nWorks</li><li>ThreadFactory：线程工厂</li><li>handler：拒绝策略</li></ul></li><li><p>运行机制</p><p>通过new创建线程池时，除非调用prestartAllCoreThreads方法初始化核心线程，否则此时线程池中有0个线程，即使工作队列中存在多个任务，同样不会执行</p><p>任务数X</p><p>x &lt;= cSize(核心线程数) 只启动x个线程</p><p>x &gt;= cSize &amp;&amp; x &lt; nWorks(等待对列最大值) + cSize 会启动 &lt;= cSize 个线程 其他的任务就放到工作队列里</p><p>x &gt; cSize &amp;&amp; x &gt; nWorks + cSize</p><ul><li><p>x-(nWorks) &lt;= mSize 会启动x-(nWorks)个线程</p></li><li><p>x-(nWorks) &gt; mSize 会启动mSize个线程来执行任务，其余的执行相应的拒绝策略</p></li></ul></li></ul><h5 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ExcutionHandler%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5" alt="image-20201120171650128"></p><ul><li><p>AbortPolicy：该策略直接抛出异常，阻止系统正常工作</p></li><li><p>CallerRunsPolicy：只要线程池没有关闭，该策略直接在调用者线程中，执行当前被丢弃的任务（叫老板帮你干活）</p></li><li><p>DiscardPolicy：直接啥事都不干，直接把任务丢弃</p></li><li><p>DiscardOldestPolicy：丢弃最老的一个请求（任务队列里面的第一个），再尝试提交任务</p></li><li><p>自定义handler</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">public class CustomPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送邮件告警</span><br><span class="line">        System.out.println(&quot;线程池满了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h5><p>总共六种    </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Executor 框架Demo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ExecutorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        ExecutorService executorService1 &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService &#x3D; Executors.newScheduledThreadPool(1);</span><br><span class="line">        ExecutorService executorService2 &#x3D; Executors.newWorkStealingPool();</span><br><span class="line">        ExecutorService executorService3 &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService1 &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;submit来使用线程池</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过相应的方法，能创建出6种线程池</p></li><li><p>上面的方法最终都创建了ThreadPoolExecutor</p><ul><li><p>newCachedThreadPool：创建一个可以根据需要创建新线程的线程池，如果有空闲线程，优先使用空闲的线程 </p></li><li><p>newFixedThreadPool：创建一个固定大小的线程池，在任何时候，最多只有N个线程在处理任务</p></li><li><p>newScheduledThreadPool：能延迟执行、定时执行的线程池 </p></li><li><p>newWorkStealingPool：工作窃取，使用多个队列来减少竞争 </p><p>通过new ForkJoinPool, 空闲队列窃取满队列任务</p></li><li><p>newSingleThreadExecutor：单一线程的线程次，只会使用唯一一个线程来执行任务，即使提交再多的任务，也都是会放到等待队列里进行等待 </p></li><li><p>newSingleThreadScheduledExecutor：单线程能延迟执行、定时执行的线程池</p></li></ul></li></ul><h5 id="线程池的使用建议"><a href="#线程池的使用建议" class="headerlink" title="线程池的使用建议"></a>线程池的使用建议</h5><ul><li><p>尽量避免使用Executor框架创建线程池</p><ul><li>newFixedThreadPool newSingleThreadExecutor 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </li><li>newCachedThreadPool newScheduledThreadPool 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</li></ul><p><strong>PS:</strong></p><p>创建线程时用的内存并不是我们制定jvm堆内存，而是系统的剩余内存。（电脑内存-系统其它程序占用的内存-已预留的jvm内存）</p></li><li><p>创建线程池时，核心线程数不要过大</p></li><li><p>相应的逻辑，发生异常时要处理</p></li><li><p>submit 如果发生异常，不会立即抛出，而是在get的时候，再抛出异常</p></li><li><p>execute 直接抛出异常</p></li></ul><h4 id="jvm与并发"><a href="#jvm与并发" class="headerlink" title="jvm与并发"></a>jvm与并发</h4><h5 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h5><ul><li><p>硬件内存模型</p><p>处理器—&gt;高速缓存—&gt;缓存一致性协议—&gt;主存</p></li><li><p>java内存模型</p><p>线程&lt;—&gt;工作内存&lt;—&gt;save和load &lt;—&gt;主存</p></li></ul><p>  <strong>硬件内存模型和java内存模型</strong></p><p>  <img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="java内存模型"></p><ul><li><p><strong>java内存间的交互操作(八种)</strong></p><ul><li>lock(锁定)：作用于<strong>主内存的变量</strong>，把一个变量标记为一条线程独占状态 </li><li>unlock(解锁)：作用于<strong>主内存的变量</strong>，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 </li><li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 </li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 </li><li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 </li><li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 </li><li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 </li><li>write(写入)：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ul></li><li><p><strong>上面8中操作必须满足以下规则</strong>(8点)</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 </li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 </li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。 </li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 </li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 </li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 </li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 </li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li></ul></li></ul><h5 id="Happens-before原则"><a href="#Happens-before原则" class="headerlink" title="Happens-before原则"></a>Happens-before原则</h5><ul><li><p>判断数据是有有竞争、线程是否安全的主要依据</p><ol><li>程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。</li><li>管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。</li><li>volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作</li><li>线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。</li><li>线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。</li><li>线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断</li><li>对象终结规则：一个对象的初始化完成先行于发生它的finalize（）方法的开始。</li><li>传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C。</li></ol></li><li><p><strong>为什么要有该原则？</strong></p><p> 无论jvm或者cpu，都希望程序运行的更快。如果两个操作不在上面罗列出来的规则里面，那么久可以对他们进行任意的重排序。</p></li><li><p>时间先后顺序与先行发生的顺序之间基本没有太大的关系。</p></li></ul><h5 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h5><ul><li><p>什么是指令重排序？</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p></li><li><p>数据依赖性</p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。）</p></li><li><p>两操作访问同一个变量，其两个操作中有至少一个写操作，此时就存在依赖性</p><p>写后读 a=0 b=a</p><p>读后写 a=b b=1</p><p>写后写 a=1 a=2 a=1,b=1</p><p>写后读 a=0 b=a 正确b=0 错误b=1</p></li><li><p>as-if-serial原则</p><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HungerSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static HungerSingleton ourInstance &#x3D; new HungerSingleton();</span><br><span class="line"></span><br><span class="line">    public static HungerSingleton getInstance() &#123;</span><br><span class="line">        return ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private HungerSingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(HungerSingleton.getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断实例是否为空，为空则实例化</span><br><span class="line">        if (null &#x3D;&#x3D; lazySingleton) &#123;</span><br><span class="line">            &#x2F;&#x2F;模拟实例化时耗时的操作</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (LazySingleton.class) &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; lazySingleton) &#123;</span><br><span class="line">                    lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则直接返回</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(LazySingleton.getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 jvm 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql必知必会系列</title>
      <link href="2020/11/13/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"/>
      <url>2020/11/13/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="数据库操纵语言分类"><a href="#数据库操纵语言分类" class="headerlink" title="数据库操纵语言分类"></a>数据库操纵语言分类</h4><ul><li>DDL 数据定义语言 (Data Definition Language) 例如：建库，建表</li><li>DML 数据操纵语言(Data Manipulation Language) 例如：对表中的数据进行增删改操作</li><li>DQL 数据查询语言(Data Query Language) 例如：对数据进行查询</li><li>DCL 数据控制语言(Data Control Language) 例如：对用户的权限进行设置</li></ul><h5 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h5><ul><li><p>创建表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">                  字段名1 字段类型1 约束条件1 说明1,</span><br><span class="line">                  字段名2 字段类型2 约束条件2 说明2,</span><br><span class="line">                  字段名3 字段类型3 约束条件3 说明3</span><br><span class="line">                  );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table 新表名 as select * from 旧表名 where 1&#x3D;2;(注意：建议这种创建表的方式用于日常测试，因  为可能索引什么的会复制不过来)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table 新表名 like 旧表名;</span><br></pre></td></tr></table></figure></li><li><p>约束条件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment         ----说明解释</span><br><span class="line">not null        ----不为空</span><br><span class="line">default         ----默认值</span><br><span class="line">unsigned        ----无符号（即正数）</span><br><span class="line">auto_increment  ----自增</span><br><span class="line">zerofill        ----自动填充</span><br><span class="line">unique key      ----唯一值</span><br></pre></td></tr></table></figure></li><li><p>查看表基本信息</p><ul><li>查看数据库中的所有表：show tables；</li><li>查看表结构：desc 表名;</li><li>查看创建表的sql语句：show create table 表名;</li><li>\G :有结束sql语句的作用，还有把显示的数据纵向旋转90度</li><li>\g :有结束sql语句的作用</li></ul></li><li><p>修改表基本结构</p><ul><li>修改表名</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename table 旧表名 to 新表名;</span><br><span class="line">rename table student to user;</span><br></pre></td></tr></table></figure><ul><li>添加列</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给表添加一列：alter table 表名 add 列名 类型;</span><br><span class="line">alter table user add addr varchar(50);</span><br><span class="line"></span><br><span class="line">alter table add 列名 类型 comment &#39;说明&#39;;</span><br><span class="line">alter table user add famliy varchar(50) comment &#39;学生父母&#39;;</span><br><span class="line"></span><br><span class="line">给表最前面添加一列：alter table 表名 add 列名 类型 first;</span><br><span class="line">alter table user add job varchar(10) first;</span><br><span class="line"></span><br><span class="line">给表某个字段后添加一列：alter table 表名 add 列名 类型 after 字段名;</span><br><span class="line">alter table user add servnumber int(11)  after id;</span><br><span class="line"></span><br><span class="line">注意：没有给表某个字段前添加一列的说法。</span><br></pre></td></tr></table></figure><ul><li>修改列类型</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify 列名 新类型;</span><br><span class="line">alter table user modify servnumber varchar(20);</span><br></pre></td></tr></table></figure><ul><li>修改列名</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 change 旧列名 新列名 类型;</span><br><span class="line">alter table user change servnumber telephone varchar(20);</span><br></pre></td></tr></table></figure><ul><li>删除列</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 列名;</span><br><span class="line">alter table user drop famliy;</span><br></pre></td></tr></table></figure><ul><li>修改字符集</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 character set 字符集;</span><br><span class="line">alter table user character  set GBK;</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table 表名；</span><br><span class="line">drop table user;</span><br></pre></td></tr></table></figure></li></ul><h5 id="DML数据操纵语言"><a href="#DML数据操纵语言" class="headerlink" title="DML数据操纵语言"></a>DML数据操纵语言</h5><ul><li><p>增</p><ul><li>普通的插入表数据</li><li>蠕虫复制</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名1 select * from 表名2;</span><br><span class="line"></span><br><span class="line">insert into 表名1（字段名1，字段名2） select 字段名1，字段名2 from 表名2;</span><br><span class="line"></span><br><span class="line">insert into emp (empno,ename) select empno,ename from employee;</span><br></pre></td></tr></table></figure><ul><li>建表复制</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名1 as select 字段名1，字段名2 from 表名2;</span><br><span class="line"></span><br><span class="line">create table emp as select empno ,ename from employee;</span><br></pre></td></tr></table></figure><ul><li>一次性插入多个数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名  (字段名) values (对应值1),(对应值2),(对应值3); </span><br></pre></td></tr></table></figure></li><li><p>删改</p><ul><li>修改</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段名1&#x3D;值1 where 字段名&#x3D;值;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 字段名&#x3D;值;</span><br><span class="line"></span><br><span class="line"> truncate table 表名;</span><br><span class="line"> delete from 表名;</span><br><span class="line"> drop table 表名;</span><br></pre></td></tr></table></figure><ul><li>attention</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在删除重要数据之前应当先备份</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete与truncate与drop 这三种删除数据的的不同点:</span><br><span class="line"></span><br><span class="line">delele 会把删除的操作记录给记录起来，以便数据回退，不会释放空间，而且不会删除定义。</span><br><span class="line">truncate不会记录删除操作，会把表占用的空间恢复到最初，不会删除定义</span><br><span class="line">drop会删除整张表，释放表占用的空间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除速度：</span><br><span class="line">drop &gt; truncate &gt; delete</span><br></pre></td></tr></table></figure></li></ul><h5 id="DQL数据查询语言"><a href="#DQL数据查询语言" class="headerlink" title="DQL数据查询语言"></a>DQL数据查询语言</h5><h6 id="where条件查询"><a href="#where条件查询" class="headerlink" title="where条件查询"></a>where条件查询</h6><ul><li><p>简单查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee;</span><br><span class="line">select empno,ename,job as ename_job from employee;</span><br></pre></td></tr></table></figure></li><li><p>精确条件查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee where ename&#x3D;&#39;后裔&#39;;</span><br><span class="line">select * from employee where sal !&#x3D; 50000;</span><br><span class="line">select * from employee where sal &lt;&gt; 50000;</span><br><span class="line">select * from employee where sal &gt; 10000;</span><br></pre></td></tr></table></figure></li><li><p>模糊条件查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%aracter%&#39;; </span><br><span class="line">select * from employee  where ename like &#39;林%&#39;;</span><br></pre></td></tr></table></figure></li><li><p>范围查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee where sal between 10000 and 30000;</span><br><span class="line">select * from employee where hiredate between &#39;2011-01-01&#39; and &#39;2017-12-1&#39;;</span><br></pre></td></tr></table></figure></li><li><p>离散查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee where ename in (&#39;猴子&#39;,&#39;林俊杰&#39;,&#39;小红&#39;,&#39;小胡&#39;);  </span><br></pre></td></tr></table></figure></li><li><p>清除重复值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct(job) from employee;</span><br></pre></td></tr></table></figure></li><li><p>统计查询（聚合函数）:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count(code)或者count(*)</span><br><span class="line">select count(*) from employee;</span><br><span class="line">select count(ename) from employee;</span><br><span class="line">        </span><br><span class="line">sum()  计算总和 </span><br><span class="line">select sum(sal) from employee;</span><br><span class="line">        </span><br><span class="line">max()    计算最大值</span><br><span class="line">select * from employee where sal&#x3D; (select  max(sal) from employee);</span><br><span class="line">        </span><br><span class="line">avg()   计算平均值</span><br><span class="line">select avg(sal) from employee;</span><br><span class="line">        </span><br><span class="line">min()   计算最低值</span><br><span class="line">select * from employee where sal&#x3D; (select  min(sal) from employee);</span><br><span class="line">        </span><br><span class="line">concat函数： 起到连接作用</span><br><span class="line">select concat(ename,&#39; 是 &#39;,job) as aaaa from employee;</span><br></pre></td></tr></table></figure></li></ul><h6 id="group-by分组查询-分组"><a href="#group-by分组查询-分组" class="headerlink" title="group by分组查询(分组)"></a>group by分组查询(分组)</h6><ul><li>作用：把行 按 字段 分组</li><li>语法：group by 列1，列2….列N</li><li>适用场合：常用于统计场合，一般和聚合函数连用</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">     select deptnu,count(*) from employee group by deptnu;</span><br><span class="line">     select deptnu,job,count(*) from employee group by deptnu,job;</span><br><span class="line">     select job,count(*) from employee group by job;</span><br></pre></td></tr></table></figure><h6 id="having条件查询-筛选"><a href="#having条件查询-筛选" class="headerlink" title="having条件查询(筛选)"></a>having条件查询(筛选)</h6><ul><li>作用：对查询的结果进行筛选操作</li><li>语法：having 条件 或者 having 聚合函数 条件</li><li>适用场合：一般跟在group by之后</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">    select job,count(*) from employee group by job having job &#x3D;&#39;文员&#39;;</span><br><span class="line">    select  deptnu,job,count(*) from employee group by deptnu,job having count(*)&gt;&#x3D;2;</span><br><span class="line">    select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;&#x3D;2;</span><br></pre></td></tr></table></figure><h6 id="order-by排序查询（排序）"><a href="#order-by排序查询（排序）" class="headerlink" title="order by排序查询（排序）"></a>order by排序查询（排序）</h6><ul><li>作用：对查询的结果进行排序操作</li><li>语法：order by 字段1,字段2 …..</li><li>适用场合：一般用在查询结果的排序</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">     select * from employee order by sal;</span><br><span class="line">     select * from employee order by hiredate;</span><br><span class="line">     select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;&#x3D;2 order by deptnu desc;</span><br><span class="line">     select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;&#x3D;2 order by deptnu asc;</span><br><span class="line">     select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;&#x3D;2 order by deptnu;</span><br><span class="line"></span><br><span class="line">     顺序：where ---- group by ----- having ------ order by </span><br></pre></td></tr></table></figure><h6 id="limit限制查询（限制）"><a href="#limit限制查询（限制）" class="headerlink" title="limit限制查询（限制）"></a>limit限制查询（限制）</h6><ul><li>作用：对查询结果起到限制条数的作用</li><li>语法：limit n，m n:代表起始条数值，不写默认为0；m代表：取出的条数</li><li>适用场合：数据量过多时，可以起到限制作用</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">    select * from XD.employee limit 4,5;</span><br></pre></td></tr></table></figure><h6 id="exists型子查询"><a href="#exists型子查询" class="headerlink" title="exists型子查询"></a>exists型子查询</h6><ul><li>exists型子查询后面是一个受限的select查询语句</li><li>exists子查询，如果exists后的内层查询能查出数据，则返回 TRUE 表示存在；为空则返回 FLASE则不存在。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分为俩种：exists跟 not exists</span><br><span class="line"></span><br><span class="line">select 1 from employee where 1&#x3D;1;</span><br><span class="line">select * from 表名 a where exists (select 1 from 表名2 where 条件);</span><br><span class="line"></span><br><span class="line">eg:查询出公司有员工的部门的详细信息</span><br><span class="line">select * from dept a where exists (select 1 from employee b where a.deptnu&#x3D;b.deptnu);</span><br><span class="line">select * from dept a where not exists (select 1 from employee b where a.deptnu&#x3D;b.deptnu);</span><br></pre></td></tr></table></figure><h6 id="左连接查询与右连接查询"><a href="#左连接查询与右连接查询" class="headerlink" title="左连接查询与右连接查询"></a>左连接查询与右连接查询</h6><ul><li>左连接称之为左外连接 右连接称之为右外连接 这俩个连接都是属于外连接</li><li>左连接关键字：left join 表名 on 条件 / left outer 表名 join on 条件 右连接关键字：right join 表名 on 条件/ right outer 表名 join on 条件</li><li>左连接说明： left join 是left outer join的简写，左(外)连接，左表(a_table)的记录将会全部表示出来， 而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。</li><li>右连接说明：right join是right outer join的简写，与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:列出部门名称和这些部门的员工信息，同时列出那些没有的员工的部门</span><br><span class="line">        dept，employee</span><br><span class="line">        select a.dname,b.* from dept a  left join employee b on a.deptnu&#x3D;b.deptnu;</span><br><span class="line">        select b.dname,a.* from employee a  right join  dept b on b.deptnu&#x3D;a.deptnu;</span><br></pre></td></tr></table></figure><h6 id="内连接查询与联合查询"><a href="#内连接查询与联合查询" class="headerlink" title="内连接查询与联合查询"></a>内连接查询与联合查询</h6><ul><li>内连接：获取两个表中字段匹配关系的记录</li><li>主要语法：INNER JOIN 表名 ON 条件;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:想查出员工张飞的所在部门的地址</span><br><span class="line">    select a.addr  from dept a inner join employee b on a.deptnu&#x3D;b.deptnu and b.ename&#x3D;&#39;张飞&#39;;</span><br><span class="line">    select a.addr from dept a,employee b where a.deptnu&#x3D;b.deptnu and b.ename&#x3D;&#39;张飞&#39;;</span><br></pre></td></tr></table></figure><ul><li>联合查询：就是把多个查询语句的查询结果结合在一起</li></ul><p>主要语法1：… UNION … （去除重复） 主要语法2：… UNION ALL …（不去重复）</p><ul><li><p>union查询的注意事项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)两个select语句的查询结果的“字段数”必须一致；</span><br><span class="line"></span><br><span class="line">(2)通常，也应该让两个查询语句的字段类型具有一致性；</span><br><span class="line"></span><br><span class="line">(3)也可以联合更多的查询结果；</span><br><span class="line"></span><br><span class="line">(4)用到order by排序时，需要加上limit（加上最大条数就行），需要对子句用括号括起来</span><br><span class="line"></span><br><span class="line">eg:对销售员的工资从低到高排序，而文员的工资从高到低排序</span><br><span class="line">    (select * from employee a where a.job &#x3D; &#39;销售员&#39;  order by a.sal limit 999999 ) union  (select * from employee b where b.job &#x3D; &#39;文员&#39; order by b.sal desc limit 999999);</span><br></pre></td></tr></table></figure></li></ul><h5 id="DCL数据控制语言"><a href="#DCL数据控制语言" class="headerlink" title="DCL数据控制语言"></a>DCL数据控制语言</h5><h6 id="限制root用户指定ip登录"><a href="#限制root用户指定ip登录" class="headerlink" title="限制root用户指定ip登录"></a>限制root用户指定ip登录</h6><ul><li>查看root用户可以在哪台机器登录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select user,host from mysql.user where user&#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure><ul><li>修改mysql库里边的user表</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update mysql.user set host&#x3D;&#39;localhost&#39; where user&#x3D;&#39;root&#39;</span><br></pre></td></tr></table></figure><ul><li>刷新权限</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h6 id="用户密码"><a href="#用户密码" class="headerlink" title="用户密码"></a>用户密码</h6><ul><li><p>修改用户密码分三种方法：</p><ul><li>第一种：set password for 用户@ip = password(‘密码’);</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password for root@localhost &#x3D; password(&#39;root&#39;);</span><br></pre></td></tr></table></figure><ul><li>第二种：mysqladmin -u用户 -p旧密码 password 新密码;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqladmin -urootmysqladmin -uroot -proot password;</span><br></pre></td></tr></table></figure><ul><li>第三种：update mysql.user set authentication_string=password(‘密码’) where user=’用户’ and host=’ip’;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update mysql.user set authentication_string&#x3D;password(&#39;root&#39;) where user&#x3D;&#39;root&#39; and host&#x3D;&#39;localhost&#39;;</span><br></pre></td></tr></table></figure></li><li><p>忘记密码:</p><ul><li>第一步：修改配置文件my.cnf (默认在/etc/my.cnf)，在[mysqld]下面加上 skip-grant-tables （跳过权限的意思）</li><li>第二步：重启mysql服务</li><li>第三步：mysql -uroot -p 无需密码登录进入</li><li>第四步：修改密码</li></ul></li></ul><h6 id="创建新用户并限制ip网段登录"><a href="#创建新用户并限制ip网段登录" class="headerlink" title="创建新用户并限制ip网段登录"></a>创建新用户并限制ip网段登录</h6><ul><li>创建用户的语法：create user ‘username’@’host’ identified by ‘password’;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username：你将创建的用户名</span><br><span class="line"></span><br><span class="line">host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</span><br><span class="line"></span><br><span class="line">password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</span><br></pre></td></tr></table></figure><ul><li>创建用户语法：</li></ul><p>创建一个pig用户，并指定登录密码：123456，可以在任何一台远程主机都可以登录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &#39;pig&#39;@&#39;%&#39; identified by &#39;123456&#39;;</span><br></pre></td></tr></table></figure><p>创建一个pig用户，并指定登录密码：为空，指定在120网段的机器登录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &#39;pig&#39;@&#39;120.%.%.%&#39; identified by &#39;&#39;;</span><br></pre></td></tr></table></figure><ul><li>查看权限：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from mysql.user where user&#x3D;&#39;pig&#39;\G</span><br><span class="line"> mysql&gt; show grants for &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line"> +---------------------------------+</span><br><span class="line"> | Grants for pig@%                |</span><br><span class="line"> +---------------------------------+</span><br><span class="line"> | GRANT USAGE ON *.* TO &#39;pig&#39;@&#39;%&#39; |</span><br><span class="line"> +---------------------------------+</span><br><span class="line"> USAGE：无权限的意思</span><br><span class="line"> mysql&gt; show grants for &#39;root&#39;@&#39;localhost&#39;;</span><br><span class="line"> +---------------------------------------------------------------------+</span><br><span class="line"> | Grants for root@localhost                                           |</span><br><span class="line"> +---------------------------------------------------------------------+</span><br><span class="line"> | GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION |</span><br><span class="line"> +---------------------------------------------------------------------+</span><br><span class="line"> WITH GRANT OPTION:表示这个用户拥有grant权限，即可以对其他用户授权</span><br></pre></td></tr></table></figure><ul><li>删除用户语法：drop user ‘username’@’host’;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">delete from mysql.user where user&#x3D;&#39;pig&#39;;</span><br></pre></td></tr></table></figure><h6 id="库表权限授权与回收"><a href="#库表权限授权与回收" class="headerlink" title="库表权限授权与回收"></a>库表权限授权与回收</h6><ul><li><p>授权语法：grant 权限1,权限2….. on 数据库对象 to ‘用户’</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant 权限1,权限2..... on 数据库对象 to &#39;用户&#39;@&#39;host&#39; identified by &#39;password&#39;;</span><br></pre></td></tr></table></figure><ul><li>all privileges:代表所有权限</li><li><em>.</em> :代表所有库所有表</li></ul></li><li><p>对现有用户进行授权</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#对现有用户pig授予所有库所有表所有权限。</span><br><span class="line">grant all privileges on *.*  to &#39;pig&#39;;</span><br></pre></td></tr></table></figure><ul><li>对没有的用户进行授权：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建一个新用户dog授予XD库的所有权限，登录密码123456，任何一台主机登录</span><br><span class="line">grant all privileges on XD.* to &#39;dog&#39;@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line"></span><br><span class="line">#创建一个新用户cat授予XD库的employee表 查与修改权限，登录密码123456，任何一台主机登录</span><br><span class="line">grant select,update on XD.employee to &#39;cat&#39;@&#39;%&#39; identified by &#39;123456&#39;</span><br><span class="line"></span><br><span class="line">#对用户cat授予XD库的employee表insert 权限，登录密码123456，任何一台主机登录</span><br><span class="line">grant insert on XD.employee to &#39;cat&#39;@&#39;%&#39; identified by &#39;123456&#39;;</span><br></pre></td></tr></table></figure><ul><li>回收语法：revoke 权限1,权限2….. on 数据库对象 from ‘用户‘@’host’;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#回收pig用户的所有权限（注意：并没有回收它的登录权限）</span><br><span class="line">revoke all privileges on *.*  from &#39;pig&#39; @ &#39;%&#39;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">#回收pig用户的所有权限（并回收它的登录权限）</span><br><span class="line">delete from mysql.user where user&#x3D;&#39;pig&#39;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">#回收cat用户对XD库的employee的查与修改权限</span><br><span class="line">revoke select,update on XD.employee from &#39;cat&#39;@&#39;%&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞"></a>起飞</h3><h4 id="事务-amp-视图-amp-触发器-amp-存储过程"><a href="#事务-amp-视图-amp-触发器-amp-存储过程" class="headerlink" title="事务&amp;视图&amp;触发器&amp;存储过程"></a>事务&amp;视图&amp;触发器&amp;存储过程</h4><h6 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h6><ul><li><p>什么是事务?</p><ul><li>数据库事务通常指对数据库进行读或写的一个操作过程。有两个目的，第一个是为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法；第二个是当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li></ul></li><li><p>事务的特性（ACID）：</p><ul><li>原子性(Atomicity)：事务必须是原子工作单元，一个事务中的所有语句，应该做到：要么全做，要么一个都不做；</li><li>一致性(Consistency):让数据保持逻辑上的“合理性”，比如：小明给小红打10000块钱，既要让小明的账户减少10000，又要让小红的账户上增加10000块钱；隔离性(Isolation)：如果多个事务同时并发执行，但每个事务就像各自独立执行一样。</li><li>持久性(Durability)：一个事务执行成功，则对数据来说应该是一个明确的硬盘数据更改（而不仅仅是内存中的变化）。</li><li>你要使用事务的话，表的引擎要为innodb引擎</li></ul></li><li><p>事务的开启与提交：</p><ul><li>事务的开启：begin; start transaction;</li><li>事务的提交：commit;</li><li>事务的回滚：rollback;</li></ul></li><li><p>开启autocommit（临时生效）：</p><p>OFF（0）：表示关闭 ON （1）：表示开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set autocommit&#x3D;0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#39;autocommit&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | OFF   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">mysql&gt; set autocommit&#x3D;1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; show variables like &#39;autocommit&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br></pre></td></tr></table></figure></li><li><p>开启autocommit（永久生效）：</p><p>修改配置文件：vi /etc/my.cnf 在[mysqld]下面加上：autocommit=1 记得重启服务才会生效</p></li></ul><h6 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h6><ul><li><p>什么是视图？视图的作用是什么？</p><ul><li>视图（view）是一种虚拟存在的表，是一个逻辑表，它本身是不包含数据的。作为一个select语句保存在数据字典中的。</li><li>通过视图，可以展现基表（用来创建视图的表叫做基表base table）的部分数据，说白了视图的数据就是来自于基表</li></ul></li><li><p>视图的优点是：</p><ul><li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li><li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响;源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li><li>不占用空间：视图是逻辑上的表，不占用内存空间</li><li>总而言之，使用视图的大部分情况是为了保障数据安全性，提高查询效率。</li></ul></li><li><p>视图的创建以及修改</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建的基本语法是：</span><br><span class="line">    create view &lt;视图名称&gt; as select 语句;</span><br><span class="line">    create view &lt;视图名称&gt; (字段) as select 语句;</span><br><span class="line">    create or replace view &lt;视图名称&gt;;</span><br><span class="line">    </span><br><span class="line">#修改的语法是：</span><br><span class="line">alter view &lt;视图名称&gt; as select 语句;</span><br><span class="line"></span><br><span class="line">#视图删除语法：</span><br><span class="line">drop view &lt;视图名称&gt; ;</span><br></pre></td></tr></table></figure><ul><li><p>视图的缺点</p><ul><li><p>性能差：sql server必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，sql server也要把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制：当用户试图修改试图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的试图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的</p></li></ul></li></ul><h6 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h6><ul><li>什么是触发器？</li></ul><p>触发器就是监视某种情况，并触发某种操作</p><ul><li>创建触发器的语法:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger 触发器名称  after&#x2F;before   insert&#x2F;update&#x2F;delete on 表名  </span><br><span class="line">        for each row</span><br><span class="line">        begin</span><br><span class="line">        sql语句;</span><br><span class="line">        end</span><br><span class="line">            </span><br><span class="line">#after&#x2F;before:可以设置为事件发生前或后</span><br><span class="line">#insert&#x2F;update&#x2F;delete:它们可以在执行insert、update或delete的过程中触发</span><br><span class="line">#for each row:每隔一行执行一次动作</span><br></pre></td></tr></table></figure><ul><li><p>删除触发器的语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop trigger 触发器名称;</span><br></pre></td></tr></table></figure></li><li><p>演示：</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#   创建一个员工迟到表：</span><br><span class="line"> create table work_time_delay(</span><br><span class="line">            empno int not null comment &#39;雇员编号&#39;,</span><br><span class="line">            ename varchar(50) comment &#39;雇员姓名&#39;,</span><br><span class="line">            status int comment &#39;状态&#39;</span><br><span class="line">            );</span><br><span class="line">delimiter &#x2F;&#x2F; 自定义语句的结束符号</span><br><span class="line"></span><br><span class="line">    mysql&gt; delimiter &#x2F;&#x2F;</span><br><span class="line">    mysql&gt; </span><br><span class="line">    mysql&gt; create trigger trig_work after insert on work_time_delay</span><br><span class="line">        -&gt; for each row</span><br><span class="line">        -&gt; begin</span><br><span class="line">        -&gt; update employee set sal&#x3D;sal-100 where empno&#x3D;new.empno;</span><br><span class="line">        -&gt; end</span><br><span class="line">        -&gt; &#x2F;&#x2F;</span><br><span class="line">    Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">#new：指的是事件发生before或者after保存的新数据</span><br></pre></td></tr></table></figure><h6 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h6><ul><li>什么是存储过程？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储过程就是把复杂的一系列操作，封装成一个过程。类似于shell，python脚本等。</span><br></pre></td></tr></table></figure><ul><li>存储过程的优缺点</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优点是：</span><br><span class="line">1)复杂操作，调用简单</span><br><span class="line">    2)速度快</span><br><span class="line">缺点是：</span><br><span class="line">    1）封装复杂</span><br><span class="line">    2) 没有灵活性</span><br></pre></td></tr></table></figure><ul><li>创建存储过程语法：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure 名称 (参数....)</span><br><span class="line">        begin</span><br><span class="line">         过程体;</span><br><span class="line">         过程体;</span><br><span class="line">         end</span><br><span class="line">参数：in|out|inout 参数名称 类型（长度）</span><br><span class="line">        in：表示调用者向过程传入值（传入值可以是字面量或变量）</span><br><span class="line">        out：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）</span><br><span class="line">        inout：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）</span><br></pre></td></tr></table></figure><ul><li><p>声明变量：declare 变量名 类型(长度) default 默认值;</p></li><li><p>给变量赋值：set @变量名=值;</p></li><li><p>调用存储命令：call 名称(@变量名);</p></li><li><p>删除存储过程命令：drop procedure 名称;</p></li><li><p>查看创建的存储过程命令：</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure 名称\G;</span><br></pre></td></tr></table></figure><ul><li>创建一个简单的存储过程：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  mysql&gt; delimiter &#x2F;&#x2F;</span><br><span class="line">  mysql&gt; create procedure  name(in n int)</span><br><span class="line">      -&gt;             begin</span><br><span class="line">      -&gt;             select * from employee limit n;</span><br><span class="line">      -&gt;             end</span><br><span class="line">      -&gt; &#x2F;&#x2F;</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; set @n&#x3D;5;</span><br><span class="line">      -&gt; &#x2F;&#x2F;</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; </span><br><span class="line">  mysql&gt; call name(@n);</span><br><span class="line">  </span><br><span class="line">mysql&gt;         create procedure  name()</span><br><span class="line">      -&gt;             begin</span><br><span class="line">      -&gt;             declare  n int default 6;</span><br><span class="line">      -&gt;             select * from employee limit n;</span><br><span class="line">      -&gt;             end</span><br><span class="line">      -&gt; &#x2F;&#x2F;</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; call name();</span><br></pre></td></tr></table></figure><h4 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h4><ul><li><p>数据库引擎</p><p>数据库引擎是数据库底层软件组件，不同的存储引擎提供不同的存储机制，索引技巧，锁定水平等功能，使用不同的数据库引擎，可以获得特定的功能</p></li><li><p>查看引擎</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#看数据库支持的引擎</span><br><span class="line">show engines;</span><br><span class="line"></span><br><span class="line">#查看当前数据的引擎：</span><br><span class="line">show create table 表名\G</span><br><span class="line"></span><br><span class="line">#查看当前库所有表的引擎：</span><br><span class="line">show table status\G</span><br></pre></td></tr></table></figure></li><li><p>建表时指定引擎</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table yingqin (id int,name varchar(20)) engine&#x3D;&#39;InnoDB&#39;;</span><br></pre></td></tr></table></figure></li><li><p>修改表的引擎</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 engine&#x3D;&#39;MyiSAm&#39;;</span><br><span class="line"></span><br><span class="line">修改默认引擎</span><br><span class="line">    vi &#x2F;etc&#x2F;my.cnf</span><br><span class="line">    [mysqld]下面</span><br><span class="line">    default-storage-engine&#x3D;MyIsAM</span><br><span class="line">    记得保存后重启服务</span><br></pre></td></tr></table></figure></li><li><p>MyISAM与InnoDB的区别</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyISAM：支持全文索引（full text）;不支持事务;表级锁;保存表的具体行数;奔溃恢复不好</span><br><span class="line"></span><br><span class="line">Innodb：支持事务;以前的版本是不支持全文索引，但在5.6之后的版本就开始支持这个功能了;行级锁（并非绝对，当执行sql语句时不能确定范围时，也会进行锁全表例如： update table set id&#x3D;3 where name like &#39;a%&#39;;）;不保存表的具体行数;奔溃恢复好</span><br></pre></td></tr></table></figure></li><li><p>总结：什么时候选择什么引擎比较好</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyISAM：</span><br><span class="line">    一般来说MyISAM不需要用到事务的时候</span><br><span class="line">    做很多count计算</span><br><span class="line"></span><br><span class="line">InnoDB：</span><br><span class="line">    可靠性要求高的，或者要求支持事务</span><br><span class="line">    想要用到外键约束的时候（讲外键的时候会讲）</span><br><span class="line"></span><br><span class="line">推荐：</span><br><span class="line">    推荐用InnoDB</span><br></pre></td></tr></table></figure></li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><ul><li>什么是索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引是一个单独的，存储在磁盘中上的数据库结构，它们包含着对数据表里的所有记录的引用指针。使用索引可以快速的找出在某列或多列中有特定值的行。</span><br></pre></td></tr></table></figure><ul><li>索引的优点：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过创建唯一索引，来保证数据库表中的每一行数据的唯一性。</span><br><span class="line">可以加快数据的检索速度。</span><br><span class="line">可以保证表数据的完整性与准确性</span><br></pre></td></tr></table></figure><ul><li>索引的缺点：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引需要占用物理空间。</span><br><span class="line">对表中的数据进行改动时，索引也需要跟着动态维护，降低了数据的维护速度。</span><br></pre></td></tr></table></figure><ul><li>索引的常见类型：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index：普通索引</span><br><span class="line"></span><br><span class="line">unique：唯一索引</span><br><span class="line"></span><br><span class="line">primary key：主键索引</span><br><span class="line"></span><br><span class="line">foreign key：外键索引</span><br><span class="line"></span><br><span class="line">fulltext: 全文索引</span><br><span class="line"></span><br><span class="line">组合索引</span><br></pre></td></tr></table></figure><ul><li>创建表的sql语句：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test (</span><br><span class="line">    id int(7) zerofill auto_increment not null,</span><br><span class="line">    username varchar(20),</span><br><span class="line">    servnumber varchar(30),</span><br><span class="line">    password varchar(20),</span><br><span class="line">    createtime datetime,</span><br><span class="line">    primary key (id)</span><br><span class="line">)DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ul><li>生成百万甚至千万级别表的sql 语句 shell脚本：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">echo &quot;请输入字段servnumber的值：&quot;</span><br><span class="line">read serber</span><br><span class="line">echo &quot;请输入创建sql语句的数量：&quot;</span><br><span class="line">read number</span><br><span class="line"></span><br><span class="line"># char&#x3D;&#96;head &#x2F;dev&#x2F;urandom | tr -dc 0-9 | head -c 11&#96;</span><br><span class="line"></span><br><span class="line">for (( i&#x3D;0;i&lt;$number;i++ ))</span><br><span class="line">        do</span><br><span class="line">        pass&#x3D;&#96;head &#x2F;dev&#x2F;urandom | tr -dc a-z | head -c 8&#96;</span><br><span class="line">        let serber&#x3D;serber+1</span><br><span class="line">        echo &quot;insert into test(id,username,servnumber,password,createtime) values(&#39;$i&#39;,&#39;user$&#123;i&#125;&#39;,&#39;$&#123;serber&#125;&#39;,&#39;$pass&#39;,now());&quot; &gt;&gt;sql.txt</span><br><span class="line"></span><br><span class="line">    done</span><br></pre></td></tr></table></figure><p>vi test.sh</p><p>执行shell脚本：sh test.sh</p><p>进行插数操作：source /home/dazhu/sql.txt</p><h5 id="普通索引-amp-唯一索引"><a href="#普通索引-amp-唯一索引" class="headerlink" title="普通索引&amp;唯一索引"></a>普通索引&amp;唯一索引</h5><ul><li>什么是普通索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通索引（index）顾名思义就是各类索引中最为普通的索引，主要任务就是提高查询速度。其特点是允许出现相同的索引内容，允许空（null）值</span><br></pre></td></tr></table></figure><ul><li>什么是唯一索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">唯一索引：（unique）顾名思义就是不可以出现相同的索引内容，但是可以为空（null）值</span><br></pre></td></tr></table></figure><ul><li><p>如何创建普通索引或者唯一索引？</p><ul><li>创建表的时候创建</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test (</span><br><span class="line">                        id int(7) zerofill auto_increment not null,</span><br><span class="line">                        username varchar(20),</span><br><span class="line">                        servnumber varchar(30),</span><br><span class="line">                        password varchar(20),</span><br><span class="line">                        createtime datetime,</span><br><span class="line">                        unique (id)</span><br><span class="line">                  )DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ul><li>直接为表添加索引</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">     alter table 表名 add index 索引名称 (字段名称);</span><br><span class="line"> eg: </span><br><span class="line">     alter table test add unique unique_username (username);</span><br><span class="line"></span><br><span class="line">注意：假如没有指定索引名称时，会以默认的字段名为索引名称</span><br></pre></td></tr></table></figure><ul><li>直接创建索引</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：create index 索引 on 表名 (字段名);</span><br><span class="line">eg：create index index_createtime on test (createtime);</span><br></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：show index from 表名\G</span><br><span class="line">eg: show index from test\G</span><br></pre></td></tr></table></figure></li><li><p>如何删除索引</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：drop index 索引名称 on 表名;</span><br><span class="line">eg：drop index unique_username on test;</span><br><span class="line"></span><br><span class="line">语法：alter table 表名 drop index 索引名;</span><br><span class="line">eg：alter table test drop index createtime;</span><br></pre></td></tr></table></figure><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><ul><li>什么是主键索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把主键添加索引就是主键索引，它是一种特殊的唯一索引，不允许有空值，而唯一索引（unique是允许为空值的）。指定为“PRIMARY KEY”</span><br><span class="line">主键：主键是表的某一列，这一列的值是用来标志表中的每一行数据的。</span><br><span class="line">注意：每一张表只能拥有一个主键</span><br></pre></td></tr></table></figure><ul><li>创建主键：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建表的时候创建</span><br><span class="line"></span><br><span class="line">#直接为表添加主键索引</span><br><span class="line">   语法：alter table 表名 add primary key (字段名);</span><br><span class="line">   eg：alter table test add primary key (id);</span><br></pre></td></tr></table></figure><ul><li>删除主键：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">alter table 表名 drop primary key;</span><br><span class="line">eg： </span><br><span class="line">alter table test drop primary key;</span><br><span class="line"></span><br><span class="line">注意：在有自增的情况下，必须先删除自增，才可以删除主键</span><br><span class="line"></span><br><span class="line">删除自增：alter table test change id id int(7) unsigned zerofill not null;</span><br></pre></td></tr></table></figure><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><ul><li><p>什么是全文索引？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全文索引是将存储在数据库中的文章或者句子等任意内容信息查找出来的索引，单位是词。全文索引也是目前搜索引擎使用的一种关键技术。指定为 fulltex</span><br></pre></td></tr></table></figure></li><li><p>添加全文索引</p><ul><li><p>创建表的时候创建全文索引</p></li><li><p>通过alter添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table command  add fulltext(instruction);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用全文索引：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from 表名 where match  (字段名) against (&#39;检索内容&#39;);</span><br><span class="line">select * from command where match(instruction) against (&#39;sections&#39;);</span><br></pre></td></tr></table></figure></li><li><p>查看匹配度：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from command where match(instruction) against (&#39;directory&#39;);</span><br></pre></td></tr></table></figure></li><li><p>停止词：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出现频率很高的词，将会使全文索引失效</span><br></pre></td></tr></table></figure></li><li><p>in boolean mode 模式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in boolean mode：意思是指定全文检索模式为布尔全文检索（简单可以理解为是检索方式）</span><br><span class="line">select * from 表名 where match (字段名) against (&#39;检索内容&#39; in boolean mode);</span><br></pre></td></tr></table></figure></li><li><p>注意点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用通配符*时，只能放在词的后边，不能放前边。</span><br></pre></td></tr></table></figure></li><li><p>删除全文索引：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table command drop index instruction;</span><br></pre></td></tr></table></figure></li><li><p>注意点总结：</p><ul><li>一般情况下创建全文索引的字段数据类型为 char、varchar、text 。其它字段类型不可以</li><li>全文索引不针对非常频繁的词做索引。比如is，no，not，you，me，yes这些，我们称之为停止词</li><li>对英文检索时忽略大小写</li></ul></li></ul><h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><ul><li>什么是外键？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外键就是作用于两个表数据之间的链接的一列或多列，用来保证表与表之间的数据的完整性和准确性。</span><br></pre></td></tr></table></figure><ul><li>添加外键约束：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：foreign key (字段名) references 关联的表名(关联表的字段名)</span><br><span class="line"></span><br><span class="line">注意：主键跟外键的字段类型一定要相</span><br><span class="line"></span><br><span class="line">create table的方法：</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;employee&#96; (</span><br><span class="line">  &#96;empno&#96; int(11) NOT NULL COMMENT &#39;雇员编号&#39;,</span><br><span class="line">  &#96;ename&#96; varchar(50) DEFAULT NULL COMMENT &#39;雇员姓名&#39;,</span><br><span class="line">  &#96;job&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">  &#96;mgr&#96; int(11) DEFAULT NULL COMMENT &#39;雇员上级编号&#39;,</span><br><span class="line">  &#96;hiredate&#96; date DEFAULT NULL COMMENT &#39;雇佣日期&#39;,</span><br><span class="line">  &#96;sal&#96; decimal(7,2) DEFAULT NULL COMMENT &#39;薪资&#39;,</span><br><span class="line">  &#96;deptnu&#96; int(11) DEFAULT NULL COMMENT &#39;部门编号&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;empno&#96;),</span><br><span class="line"> foreign key (deptnu) references dept(deptnu)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"> alter table的方法：</span><br><span class="line"> alter table employee add foreign key (deptnu) references dept(deptnu);</span><br></pre></td></tr></table></figure><ul><li>删除外键约束：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：在干掉外键索引之前必须先把外键约束删除，才能删除索引</span><br><span class="line">mysql&gt; alter table employee drop index deptnu;</span><br><span class="line">ERROR 1553 (HY000): Cannot drop index &#39;deptnu&#39;: needed in a foreign key constraint</span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; alter table employee drop foreign key employee_ibfk_1;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; alter table employee drop index deptnu;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><ul><li>注意点总结：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）俩个表，主键跟外键的字段类型一定要相同</span><br><span class="line"></span><br><span class="line">（2）要使用外键约束表的引擎一定得是InnoDB引擎，MyISAM是不起作用的</span><br><span class="line"></span><br><span class="line">（3）在干掉外键索引之前必须先把外键约束删除，才能删除索引</span><br></pre></td></tr></table></figure><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><ul><li>什么是联合索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">联合索引又称组合索引或者复合索引，是建立在俩列或者多列以上的索引。</span><br></pre></td></tr></table></figure><ul><li>怎么来创建联合索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add index(字段1,字段2,字段3);</span><br><span class="line"></span><br><span class="line">alter table test add index(username,servnumber,password);</span><br></pre></td></tr></table></figure><ul><li>怎么删除联合索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table test drop index username;</span><br></pre></td></tr></table></figure><ul><li>为什么要使用联合索引，而不使用多个单列索引？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">联合索引的效率远远高于单列索引</span><br></pre></td></tr></table></figure><ul><li>联合索引的最左原则</li><li>注意点总结：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引并非越多越好，过多的索引会增加数据的维护速度还有磁盘空间的浪费。</span><br><span class="line"></span><br><span class="line">当表的数据量很大的时候，可以考虑建立索引。</span><br><span class="line"></span><br><span class="line">表中经常查数据的字段，可以考虑建立索引。</span><br><span class="line"></span><br><span class="line">想要保证表中数据的唯一性，可以考虑建立唯一索引。</span><br><span class="line"></span><br><span class="line">想要保证俩张表中的数据的完整性跟准确性，可以考虑建立外键约束。</span><br><span class="line"></span><br><span class="line">经常对多列数据进行查询时，可以考虑建立联合索引。</span><br></pre></td></tr></table></figure><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><h5 id="二进制日志mysqlbinlog备份"><a href="#二进制日志mysqlbinlog备份" class="headerlink" title="二进制日志mysqlbinlog备份"></a>二进制日志mysqlbinlog备份</h5><h5 id="二进制日志mysqlbinlog恢复"><a href="#二进制日志mysqlbinlog恢复" class="headerlink" title="二进制日志mysqlbinlog恢复"></a>二进制日志mysqlbinlog恢复</h5><h3 id="升天"><a href="#升天" class="headerlink" title="升天"></a>升天</h3><h4 id="调优思路"><a href="#调优思路" class="headerlink" title="调优思路"></a>调优思路</h4><h5 id="开启慢查询日志与问题定位"><a href="#开启慢查询日志与问题定位" class="headerlink" title="开启慢查询日志与问题定位"></a>开启慢查询日志与问题定位</h5><ul><li>第一步：查看是否已经开启了慢查询日志</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;slow%&#39;;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_launch_time    | 2                                    |</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | &#x2F;data&#x2F;mydata&#x2F;xdclass-public-slow.log |</span><br><span class="line">+---------------------+--------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>第二步：开启慢查询日志</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log &#x3D; on ;</span><br><span class="line"></span><br><span class="line">日志路径也可以自定义：</span><br><span class="line"></span><br><span class="line">set global slow_query_log_file &#x3D; &#39;路径&#39;;</span><br></pre></td></tr></table></figure><ul><li>第三步：查看慢查询的时间临界值</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%long%&#39;;</span><br></pre></td></tr></table></figure><ul><li>第四步：设置慢查询的时间标准</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set long_query_time&#x3D;0.4;</span><br></pre></td></tr></table></figure><ul><li>注意：重启mysql服务会让在交互界面设置的慢查询恢复到默认</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">永久生效的设置方法：修改配置文件 vi &#x2F;etc&#x2F;my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; 1</span><br><span class="line">long_query_time &#x3D; 0.1</span><br><span class="line">slow_query_log_file &#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql_slow.log</span><br><span class="line"></span><br><span class="line">最后必须重启服务才能生效！</span><br></pre></td></tr></table></figure><h5 id="开启性能详情"><a href="#开启性能详情" class="headerlink" title="开启性能详情"></a>开启性能详情</h5><ul><li>第一步：查看性能详情是否开启</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%profiling%&#39;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+------------------------+-------+</span><br></pre></td></tr></table></figure><ul><li>第二步：开启性能记录功能</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set profiling &#x3D; on ;</span><br></pre></td></tr></table></figure><ul><li>第三步：查看性能的记录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                             |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">|        1 | 0.00177775 | show variables like &#39;%profiling%&#39;                 |</span><br><span class="line">|        2 | 0.00037900 | select * from test where id&#x3D;&#39;087878&#39;              |</span><br><span class="line">|        3 | 0.34618025 | select * from test where servnumber&#x3D;&#39;1367008787&#39;  |</span><br><span class="line">|        4 | 0.31986825 | select * from test where servnumber&#x3D;&#39;13670087879&#39; |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>第四步：查看语句的执行性能详情</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profile for query 4;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000100 |</span><br><span class="line">| checking permissions | 0.000010 |</span><br><span class="line">| Opening tables       | 0.000023 |</span><br><span class="line">| init                 | 0.000045 |</span><br><span class="line">| System lock          | 0.000015 |</span><br><span class="line">| optimizing           | 0.000016 |</span><br><span class="line">| statistics           | 0.000028 |</span><br><span class="line">| preparing            | 0.000020 |</span><br><span class="line">| executing            | 0.000006 |</span><br><span class="line">| Sending data         | 0.319489 |</span><br><span class="line">| end                  | 0.000037 |</span><br><span class="line">| query end            | 0.000012 |</span><br><span class="line">| closing tables       | 0.000012 |</span><br><span class="line">| freeing items        | 0.000040 |</span><br><span class="line">| cleaning up          | 0.000017 |</span><br><span class="line">+----------------------+----------+</span><br></pre></td></tr></table></figure><h5 id="sql语句建议"><a href="#sql语句建议" class="headerlink" title="sql语句建议"></a>sql语句建议</h5><ul><li>第一个注意点：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">尽量避免使用select *from ，尽量精确到想要的结果字段</span><br></pre></td></tr></table></figure><ul><li>第二个注意点：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">尽量避免条件使用or</span><br></pre></td></tr></table></figure><ul><li>第三个注意点：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记得加上limit 限制行数，避免数据量过大消耗性能</span><br></pre></td></tr></table></figure><ul><li>第四个注意点：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用模糊查询时，%放在前面是会使索引失效</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from test where servnumber like &#39;%1367000%&#39;\G</span><br></pre></td></tr></table></figure><ul><li>第五个注意点：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要小心条件字段类型的转换</span><br></pre></td></tr></table></figure><h3 id="BUG机"><a href="#BUG机" class="headerlink" title="BUG机"></a>BUG机</h3><h4 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h4><ul><li><p>查看当前mysql使用的字符集：show variables like ‘character%’;</p></li><li><p>character_set_client：客户端请求数据的字符集</p></li><li><p>character_set_connection：客户端与服务器连接的字符集</p></li><li><p>character_set_database：数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将默认使用配置上的字符集</p></li><li><p>character_set_results：返回给客户端的字符集(从数据库读取到的数据是什么编码的)</p></li><li><p>character_set_server：为服务器安装时指定的默认字符集设定。</p></li><li><p>character_set_system：系统字符集(修改不了的，就是utf8)</p></li><li><p>character_sets_dir：mysql字符集文件的保存路径</p></li><li><p>临时：set names gbk;</p></li><li><p>永久：修改配置文件my.cnf里边的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;gbk</span><br><span class="line">作用于外部的显示</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;gbk</span><br><span class="line">作用于内部，会作用于创建库表时默认字符集</span><br></pre></td></tr></table></figure></li><li><p>修改库的字符集编码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database xiaoxiao default character set gbk;</span><br></pre></td></tr></table></figure></li><li><p>修改表的字符集编码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table employee default character set utf8;</span><br></pre></td></tr></table></figure></li></ul><h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AlibabaCloud-docker</title>
      <link href="2020/11/10/AlibabaCloud-docker/"/>
      <url>2020/11/10/AlibabaCloud-docker/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="微服务架构常见核心组件"><a href="#微服务架构常见核心组件" class="headerlink" title="微服务架构常见核心组件"></a>微服务架构常见核心组件</h4><ul><li>网关<ul><li>路由+过滤器</li></ul></li><li>服务注册发现<ul><li>调用和被调用方的信息维护</li></ul></li><li>配置中心<ul><li>管理配置，动态更新 application.properties</li></ul></li><li>链路追踪<ul><li>分析调用链路耗时，保存数据库</li></ul></li><li>负载均衡器<ul><li>分发流量到多个节点，降低压力</li></ul></li><li>熔断<ul><li>保护自己和被调用方</li></ul></li></ul><h4 id="微服务架构常见解决方案"><a href="#微服务架构常见解决方案" class="headerlink" title="微服务架构常见解决方案"></a>微服务架构常见解决方案</h4><ul><li>ServiceComb<ul><li>华为内部的CSE(Cloud Service Engine)框架开源, 一个微服务的开源解决方案,社区相对于下面几个比较小</li><li>文档不多，通信领域比较强</li></ul></li><li>dubbo<ul><li>zookeeper + dubbo + springmvc/springboot</li><li>官方地址：<a href="http://dubbo.apache.org/#!/?lang=zh-cn">http://dubbo.apache.org/#!/?lang=zh-cn</a></li><li>配套<ul><li>通信方式：rpc</li><li>注册中心：zookeper/redis/nacos</li><li>配置中心：diamond、nacos</li></ul></li></ul></li><li>SpringCloud<ul><li>全家桶+轻松嵌入第三方组件(Netflix 奈飞)</li><li>官网：<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></li><li>配套<ul><li>通信方式：http restful</li><li>注册中心：eruka</li><li>配置中心：config</li><li>断路器：hystrix</li><li>网关：zuul/gateway</li><li>分布式追踪系统：sleuth+zipkin</li></ul></li></ul></li><li>Spring Alibaba Cloud<ul><li>全家桶+阿里生态多个组件组合+SpringCloud支持</li><li>官网 <a href="https://spring.io/projects/spring-cloud-alibaba">https://spring.io/projects/spring-cloud-alibaba</a></li><li>配套<ul><li>通信方式：http restful</li><li>注册中心：nacos</li><li>配置中心：nacos</li><li>断路器：sentinel</li><li>网关：gateway</li><li>分布式追踪系统：sleuth+zipkin</li></ul></li></ul></li></ul><h4 id="微服务核心组件图"><a href="#微服务核心组件图" class="headerlink" title="微服务核心组件图"></a>微服务核心组件图</h4><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20201110200336527.png" alt="image-20201110200336527"></p><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><ul><li><p>创建聚合工程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;net.company&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud-dmeo&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;module-common&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;module1&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;module2&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;module3r&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 一般来说父级项目的packaging都为pom，packaging默认类型jar类型--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">     &lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建子项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">  </span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;net.company&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;module-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置数据库连接（注意 端口、应用名称、数据库名称）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: module1</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;cloud_video?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line"># 控制台输出sql、下划线转驼峰</span><br><span class="line">mybatis:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">    map-underscore-to-camel-case: true</span><br></pre></td></tr></table></figure></li></ul><h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞"></a>起飞</h3><h4 id="Think-about-it"><a href="#Think-about-it" class="headerlink" title="Think  about it"></a>Think  about it</h4><ul><li><p>服务间的调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RPC:</span><br><span class="line">  远程过程调用，像调用本地服务(方法)一样调用服务器的服务</span><br><span class="line">  支持同步、异步调用</span><br><span class="line">  客户端和服务器之间建立TCP连接，可以一次建立一个，也可以多个调用复用一次链接</span><br><span class="line">  RPC数据包小</span><br><span class="line">    protobuf</span><br><span class="line">    thrift</span><br><span class="line">  rpc：编解码，序列化，链接，丢包，协议</span><br><span class="line">  </span><br><span class="line">Rest(Http):</span><br><span class="line">  http请求，支持多种协议和功能</span><br><span class="line">  开发方便成本低</span><br><span class="line">  http数据包大</span><br><span class="line">  java开发：resttemplate或者httpclient</span><br></pre></td></tr></table></figure></li><li><p>用户间的调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RestTemplate getRestTemplate()&#123;</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Video video &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;localhost:9000&#x2F;api&#x2F;v1&#x2F;video&#x2F;find_by_id?videoId&#x3D;&quot;+videoId,Video.class);</span><br></pre></td></tr></table></figure></li><li><p>存在的问题</p><ul><li>服务之间的IP信息写死</li><li>服务之间无法提供负载均衡</li><li>多个服务直接关系调用维护复杂</li></ul></li></ul><h4 id="nacos注册中心"><a href="#nacos注册中心" class="headerlink" title="nacos注册中心"></a>nacos注册中心</h4><h5 id="注册中心和常见的注册中心"><a href="#注册中心和常见的注册中心" class="headerlink" title="注册中心和常见的注册中心"></a>注册中心和常见的注册中心</h5><ul><li><p>注册中心（服务治理）</p><ul><li>服务注册：服务提供者provider，启动的时候向注册中心上报自己的网络信息<ul><li>服务发现：服务消费者consumer,启动的时候向注册中心上报自己的网络信息，拉取provider的相关网络信息</li></ul></li><li>核心:服务管理,是有个服务注册表，心跳机制动态维护，服务实例在启动时注册到服务注册表，并在关闭时注销。</li></ul></li><li><p>有什么用</p><ul><li>微服务应用和机器越来越多，调用方需要知道接口的网络地址，如果靠配置文件的方式去控制网络地址，对于动态新增机器，维护带来很大问题</li></ul></li><li><p>主流的注册中心：zookeeper、Eureka、consul、etcd、Nacos</p><table><thead><tr><th align="left"></th><th align="left"><strong>Nacos</strong></th><th align="left"><strong>Eureka</strong></th><th align="left"><strong>Consul</strong></th><th align="left"><strong>Zookeeper</strong></th></tr></thead><tbody><tr><td align="left">一致性协议</td><td align="left">CP+AP</td><td align="left">AP</td><td align="left">CP</td><td align="left">CP</td></tr><tr><td align="left">健康检查</td><td align="left">TCP/HTTP/MYSQL/Client Beat</td><td align="left">心跳</td><td align="left">TCP/HTTP/gRPC/Cmd</td><td align="left">Keep Alive</td></tr><tr><td align="left">雪崩保护</td><td align="left">有</td><td align="left">有</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">访问协议</td><td align="left">HTTP/DNS</td><td align="left">HTTP</td><td align="left">HTTP/DNS</td><td align="left">TCP</td></tr><tr><td align="left">SpringCloud集成</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr></tbody></table><ul><li>Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足</li><li>Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化</li></ul></li></ul><ul><li>结论：<ul><li>分布式系统中P,肯定要满足，所以只能在CA中二选一</li><li>没有最好的选择，最好的选择是根据业务场景来进行架构设计</li><li>如果要求一致性，则选择zookeeper/Nacos，如金融行业 CP</li><li>如果要求可用性，则Eureka/Nacos，如电商系统 AP</li><li>CP ： 适合支付、交易类，要求数据强一致性，宁可业务不可用，也不能出现脏数据</li><li>AP: 互联网业务，比如信息流架构，不要求数据强一致，更想要服务可用</li></ul></li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20201110200816781.png" alt="image-20201110200816781"></p><h5 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h5><ul><li><p>CAP定理: 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得</p><ul><li>一致性（C）：所有节点都可以访问到最新的数据</li><li>可用性（A）：每个请求都是可以得到响应的，不管请求是成功还是失败</li><li>分区容错性（P）：除了全部整体网络故障，其他故障都不能导致整个系统不可用</li></ul></li></ul><ul><li><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡</p><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20201110203816385.png" alt="image-20201110203816385"></p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CA： 如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的</span><br><span class="line"></span><br><span class="line">CP: 如果不要求A（可用），每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统</span><br><span class="line"></span><br><span class="line">AP：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</span><br></pre></td></tr></table></figure><h5 id="CAP的权衡结果-BASE理论"><a href="#CAP的权衡结果-BASE理论" class="headerlink" title="CAP的权衡结果 BASE理论"></a>CAP的权衡结果 BASE理论</h5><ul><li>什么是Base理论</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CAP 中的一致性和可用性进行一个权衡的结果，核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性, 来自 ebay 的架构师提出</span><br></pre></td></tr></table></figure><ul><li>Basically Available(基本可用)<ul><li>假设系统，出现了不可预知的故障，但还是能用, 可能会有性能或者功能上的影响</li></ul></li><li>Soft state（软状态）<ul><li>允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时 </li></ul></li><li>Eventually consistent（最终一致性）<ul><li>系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值</li></ul></li></ul><h5 id="Nacos搭建"><a href="#Nacos搭建" class="headerlink" title="Nacos搭建"></a>Nacos搭建</h5><ul><li><p>下载安装</p><p>官网：<a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></p></li><li><p>进入bin目录</p></li><li><p>启动 sh startup.sh -m standalone</p></li><li><p>访问 localhost:8848/nacos</p></li><li><p>默认账号密码 nacos/nacos</p></li></ul><h5 id="项目集成Nacos"><a href="#项目集成Nacos" class="headerlink" title="项目集成Nacos"></a>项目集成Nacos</h5><ul><li><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&#x2F;&#x2F; 所有子模块都需要添加</span><br></pre></td></tr></table></figure></li><li><p>配置Nacos地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: servicename</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li><li><p>启动类增加注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br></pre></td></tr></table></figure></li><li><p>服务之间的调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">  private DiscoveryClient discoveryClient;</span><br><span class="line">  </span><br><span class="line">@Autowired</span><br><span class="line">  private RestTemplate restTemplate;</span><br><span class="line">  </span><br><span class="line"> @RequestMapping(&quot;save&quot;)</span><br><span class="line">  public VideoOrder save(int videoId)&#123;</span><br><span class="line">  </span><br><span class="line">      VideoOrder videoOrder &#x3D; new VideoOrder();</span><br><span class="line">      videoOrder.setVideoId(videoId);</span><br><span class="line">  </span><br><span class="line">      List&lt;ServiceInstance&gt; list &#x3D; discoveryClient.getInstances(&quot;xdclass-video-service&quot;);</span><br><span class="line">  </span><br><span class="line">      ServiceInstance serviceInstance &#x3D; list.get(0);</span><br><span class="line">&#x2F;&#x2F;订单调视频</span><br><span class="line">      Video video &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;&quot;+serviceInstance.getHost()+&quot;:&quot;+serviceInstance.getPort()+</span><br><span class="line">              &quot;&#x2F;api&#x2F;v1&#x2F;video&#x2F;find_by_id?videoId&#x3D;&quot;+videoId,Video.class);</span><br><span class="line">  </span><br><span class="line">      videoOrder.setVideoTitle(video.getTitle());</span><br><span class="line">      videoOrder.setVideoId(video.getId());</span><br><span class="line">      return videoOrder;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Ribbon-Feign实现负载均衡"><a href="#Ribbon-Feign实现负载均衡" class="headerlink" title="Ribbon+Feign实现负载均衡"></a>Ribbon+Feign实现负载均衡</h4><h5 id="负载均衡和常见的解决方案"><a href="#负载均衡和常见的解决方案" class="headerlink" title="负载均衡和常见的解决方案"></a>负载均衡和常见的解决方案</h5><ul><li><p>什么是负载均衡（Load Balance）</p><ul><li>分布式系统中一个非常重要的概念，当访问的服务具有多个实例时，需要根据某种“均衡”的策略决定请求发往哪个节点，这就是所谓的负载均衡，原理是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，从而提高了数据的吞吐量。</li></ul></li><li><p>负载均衡的种类</p><ul><li>软硬件角度<ul><li>通过硬件来进行解决，常见的硬件有NetScaler、F5、Radware和Array等商用的负载均衡器，但比较昂贵的</li><li>通过软件来进行解决，常见的软件有LVS、Nginx等,它们是基于Linux系统并且开源的负载均衡策略</li></ul></li><li>端的角度<ul><li>服务端负载均衡</li><li>客户端负载均衡</li></ul></li></ul></li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20201110201930966.png" alt="image-20201110201930966"></p><ul><li>常见的负载均衡策略（看组件的支持情况）<ul><li>节点轮询<ul><li>简介：每个请求按顺序分配到不同的后端服务器</li></ul></li><li>weight 权重配置<ul><li>简介：weight和访问比率成正比，数字越大，分配得到的流量越高</li></ul></li><li>固定分发<ul><li>简介：根据请求按访问ip的hash结果分配，这样每个用户就可以固定访问一个后端服务器</li></ul></li><li>随机选择、最短响应时间等等</li></ul></li></ul><h5 id="AlibabaCloud集成Ribbon实现负载均衡"><a href="#AlibabaCloud集成Ribbon实现负载均衡" class="headerlink" title="AlibabaCloud集成Ribbon实现负载均衡"></a>AlibabaCloud集成Ribbon实现负载均衡</h5><ul><li>订单服务增加@LoadBalanced 注解</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">  return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用实战</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Video video &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;xdclass-video-service&#x2F;api&#x2F;v1&#x2F;video&#x2F;find_by_id?videoId&#x3D;&quot;+videoId, Video.class);</span><br><span class="line"></span><br><span class="line">注意：方便大家看到负载均衡效果，在video类增加这个字段，记录当前机器ip+端口</span><br></pre></td></tr></table></figure><ul><li><p>源码解析</p><p>@LoadBalanced 1）首先从注册中心获取provider的列表 2）通过一定的策略选择其中一个节点 3）再返回给restTemplate调用</p><p>其实采用的是轮询策略</p></li><li><p>自定义Ribbon负载均衡策略</p><ul><li>Ribbon支持的负载均衡策略</li></ul><table><thead><tr><th>RandomRule</th><th>随机策略</th><th align="left">随机选择server</th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>轮询策略</td><td align="left">按照顺序选择server（默认）</td></tr><tr><td>RetryRule</td><td>重试策略</td><td align="left">当选择server不成功，短期内尝试选择一个可用的server</td></tr><tr><td></td><td></td><td align="left"></td></tr><tr><td>AvailabilityFilteringRule</td><td>可用过滤策略</td><td align="left">过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值）</td></tr><tr><td>WeightedResponseTimeRule</td><td>响应时间加权重策略</td><td align="left">根据server的响应时间分配权重，以响应时间作为权重，响应时间越短的服务器被选中的概率越大，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间</td></tr><tr><td>ZoneAvoidanceRule</td><td>区域权重策略</td><td align="left">综合判断server所在区域的性能，和server的可用性，轮询选择server</td></tr></tbody></table><ul><li>负载均衡策略调整实战</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订单服务增加配置</span><br><span class="line"></span><br><span class="line">xdclass-video-service:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br><span class="line"> &#x2F;&#x2F;策略选择： 1、如果每个机器配置一样，则建议不修改策略 (推荐) 2、如果部分机器配置强，则可以改为 WeightedResponseTimeRule</span><br></pre></td></tr></table></figure><p>Open-Feign</p><h5 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h5><ul><li><p>什么是Feign:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SpringCloud提供的伪http客户端(本质还是用http)，封装了Http调用流程，更适合面向接口化</span><br><span class="line">让用Java接口注解的方式调用Http请求.</span><br><span class="line"></span><br><span class="line">不用像Ribbon中通过封装HTTP请求报文的方式调用 Feign默认集成了Ribbon</span><br><span class="line">Nacos支持Feign,可以直接集成实现负载均衡的效果</span><br></pre></td></tr></table></figure></li></ul><h5 id="集成Feign"><a href="#集成Feign" class="headerlink" title="集成Feign"></a>集成Feign</h5><ul><li><p>加入依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置注解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动类增加@EnableFeignClients</span><br></pre></td></tr></table></figure></li><li><p>增加一个接口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订单服务增加接口，服务名称记得和nacos保持一样</span><br><span class="line">@FeignClient(name&#x3D;&quot;xdclass-video-service&quot;) </span><br></pre></td></tr></table></figure></li></ul><h4 id="流控防卫兵Sentinel"><a href="#流控防卫兵Sentinel" class="headerlink" title="流控防卫兵Sentinel"></a>流控防卫兵Sentinel</h4><h5 id="高并发下的微服务容错方案"><a href="#高并发下的微服务容错方案" class="headerlink" title="高并发下的微服务容错方案"></a>高并发下的微服务容错方案</h5><ul><li><p>限流</p></li><li><p>漏斗，不管流量多大，均匀的流入容器，令牌桶算法，漏桶算法</p><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20200908182543365.png" alt="image-20200908182543365"></p></li><li><p>熔断：</p><ul><li>保险丝，熔断服务，为了防止整个系统故障，包含当前和下游服务 下单服务 -》商品服务-》用户服务 -》（出现异常-》熔断风控服务</li></ul></li><li><p>降级：</p><ul><li>抛弃一些非核心的接口和数据，返回兜底数据 旅行箱的例子：只带核心的物品，抛弃非核心的，等有条件的时候再去携带这些物品</li></ul></li><li><p>隔离：</p></li><li><p>服务和资源互相隔离，比如网络资源，机器资源，线程资源等，不会因为某个服务的资源不足而抢占其他服务的资源</p></li><li><p>熔断和降级互相交集</p><ul><li>相同点：<ul><li>从可用性和可靠性触发，为了防止系统崩溃</li><li>最终让用户体验到的是某些功能暂时不能用</li></ul></li><li>不同点<ul><li>服务熔断一般是下游服务故障导致的，而服务降级一般是从整体系统负荷考虑，由调用方控制</li></ul></li></ul></li><li><p>官网：<a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D</a></p></li></ul><h5 id="Sentinel控制台搭建"><a href="#Sentinel控制台搭建" class="headerlink" title="Sentinel控制台搭建"></a>Sentinel控制台搭建</h5><ul><li><p>引入Sentinel依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>注意：Sentinel 控制台目前仅支持单机部</p></li><li><p>启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本，</span><br><span class="line">&#x2F;&#x2F;-Dserver.port&#x3D;8080 用于指定 Sentinel 控制台端口为 8080 </span><br><span class="line">&#x2F;&#x2F;默认用户名和密码都是 sentinel</span><br><span class="line"></span><br><span class="line">java -Dserver.port&#x3D;8080 -Dcsp.sentinel.dashboard.server&#x3D;localhost:8080 -Dproject.name&#x3D;sentinel-dashboard -jar sentinel-dashboard-1.8.0.jar</span><br></pre></td></tr></table></figure></li><li><p>项目整合Sentinel</p><ul><li>接入sentinel</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: 127.0.0.1:8080 </span><br><span class="line">        port: 9999 </span><br><span class="line"></span><br><span class="line">#dashboard: 8080 控制台端口</span><br><span class="line">#port: 9999 本地启的端口，随机选个不能被占用的，与dashboard进行数据交互，会在应用对应的机器上启动一个 Http Server，该 Server 会与 Sentinel 控制台做交互, 若被占用,则开始+1一次扫描</span><br></pre></td></tr></table></figure><p>微服务注册上去后，由于Sentinel是懒加载模式，所以需要访问微服务后才会在控制台出现</p></li></ul><h5 id="流量控制规则"><a href="#流量控制规则" class="headerlink" title="流量控制规则"></a>流量控制规则</h5><ul><li><p>基于统计并发线程数的流量控制</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并发数控制用于保护业务线程池不被慢调用耗尽</span><br><span class="line"></span><br><span class="line">Sentinel 并发控制不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目（正在执行的调用数目）</span><br><span class="line"></span><br><span class="line">如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。</span><br></pre></td></tr></table></figure></li><li><p>基于统计QPS的流量控制</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 QPS 超过某个阈值的时候，则采取措施进行流量控制</span><br></pre></td></tr></table></figure></li></ul><h6 id="基于并发线程数限制流量控制"><a href="#基于并发线程数限制流量控制" class="headerlink" title="基于并发线程数限制流量控制"></a>基于并发线程数限制流量控制</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并发数控制用于保护业务线程池不被慢调用耗尽</span><br><span class="line"></span><br><span class="line">Sentinel 并发控制不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目（正在执行的调用数目）</span><br><span class="line"></span><br><span class="line">如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。并发数控制通常在调用端进行配</span><br></pre></td></tr></table></figure><ul><li><p>效果</p><ul><li><p>直接拒绝：默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝</p></li><li><p>Warm Up：冷启动/预热，如果系统在此之前长期处于空闲的状态，我们希望处理请求的数量是缓步的增多，经过预期的时间以后，到达系统处理请求个数的最大值</p><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20200908212417778.png" alt="image-20200908212417778"></p></li><li><p>匀速排队：严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法，主要用于处理间隔性突发的流量，如消息队列，想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求</p></li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/68292442-d4af3c00-00c6-11ea-8251-d0977366d9b4.png" alt="image"></p></li><li><p>注意：</p><ul><li>匀速排队等待策略是 Leaky Bucket 算法结合虚拟队列等待机制实现的。</li><li>匀速排队模式暂时不支持 QPS &gt; 1000 的场景</li></ul></li></ul><h5 id="Sentinel熔断降级规则"><a href="#Sentinel熔断降级规则" class="headerlink" title="Sentinel熔断降级规则"></a>Sentinel熔断降级规则</h5><ul><li><p>熔断降级（虽然是两个概念，基本都是互相配合）</p><ul><li>对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一</li><li>对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩</li><li>熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置</li></ul></li><li><p>Sentinel 熔断策略</p><ul><li><p>慢调用比例(响应时间): 选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用</p><ul><li>比例阈值</li><li>熔断时长：超过时间后会尝试恢复</li><li>最小请求数：熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断</li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20200909121342893.png" alt="image-20200909121342893"></p></li><li><p>异常比例：当单位统计时长内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断</p><ul><li>比例阈值</li><li>熔断时长：超过时间后会尝试恢复</li><li>最小请求数：熔断触发的最小请求数，请求数小于该值时，即使异常比率超出阈值也不会熔断</li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20200909121357918.png" alt="image-20200909121357918"></p></li><li><p>异常数：当单位统计时长内的异常数目超过阈值之后会自动进行熔断</p><ul><li>异常数:</li><li>熔断时长：超过时间后会尝试恢复</li><li>最小请求数：熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断</li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20200909121415806.png" alt="image-20200909121415806"></p></li></ul></li></ul><h5 id="Sentinel的熔断状态和恢复"><a href="#Sentinel的熔断状态和恢复" class="headerlink" title="Sentinel的熔断状态和恢复"></a>Sentinel的熔断状态和恢复</h5><ul><li><p>服务熔断一般有三种状态</p><ul><li><p>熔断关闭（Closed）</p><ul><li>服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制</li></ul></li><li><p>熔断开启（Open）</p><ul><li>后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法</li></ul></li><li><p>半熔断（Half-Open）</p><ul><li>所谓半熔断就是尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率</li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20200909171947975.png" alt="image-20200909171947975"></p></li></ul></li><li><p>熔断恢复：</p><ul><li>经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态）尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。</li><li>如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断状态</li></ul></li></ul><h5 id="Sentinel自定义异常-整合Open-Feign"><a href="#Sentinel自定义异常-整合Open-Feign" class="headerlink" title="Sentinel自定义异常-整合Open-Feign"></a>Sentinel自定义异常-整合Open-Feign</h5><p>v2.1.0到v2.2.0后，Sentinel里面依赖进行了改动，且不向下兼容</p><h6 id="自定义降级返回数据"><a href="#自定义降级返回数据" class="headerlink" title="自定义降级返回数据"></a>自定义降级返回数据</h6><ul><li>【旧版】实现UrlBlockHandler并且重写blocked方法</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class XdclassUrlBlockHandler implements UrlBlockHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void blocked(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws IOException &#123;</span><br><span class="line">       &#x2F;&#x2F;降级业务处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【新版】实现BlockExceptionHandler并且重写handle方法</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class XdclassUrlBlockHandler implements BlockExceptionHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws IOException &#123;</span><br><span class="line">        Map&lt;String,Object&gt; backMap&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        if (e instanceof FlowException)&#123;</span><br><span class="line">            backMap.put(&quot;code&quot;,-1);</span><br><span class="line">            backMap.put(&quot;msg&quot;,&quot;限流-异常啦&quot;);</span><br><span class="line">        &#125;else if (e instanceof DegradeException)&#123;</span><br><span class="line">            backMap.put(&quot;code&quot;,-2);</span><br><span class="line">            backMap.put(&quot;msg&quot;,&quot;降级-异常啦&quot;);</span><br><span class="line">        &#125;else if (e instanceof ParamFlowException)&#123;</span><br><span class="line">            backMap.put(&quot;code&quot;,-3);</span><br><span class="line">            backMap.put(&quot;msg&quot;,&quot;热点-异常啦&quot;);</span><br><span class="line">        &#125;else if (e instanceof SystemBlockException)&#123;</span><br><span class="line">            backMap.put(&quot;code&quot;,-4);</span><br><span class="line">            backMap.put(&quot;msg&quot;,&quot;系统规则-异常啦&quot;);</span><br><span class="line">        &#125;else if (e instanceof AuthorityException)&#123;</span><br><span class="line">            backMap.put(&quot;code&quot;,-5);</span><br><span class="line">            backMap.put(&quot;msg&quot;,&quot;认证-异常啦&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置返回json数据</span><br><span class="line">        httpServletResponse.setStatus(200);</span><br><span class="line">        httpServletResponse.setHeader(&quot;content-Type&quot;,&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);</span><br><span class="line">        httpServletResponse.getWriter().write(JSON.toJSONString(backMap));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Feign整合Sentinel配置"><a href="#Feign整合Sentinel配置" class="headerlink" title="Feign整合Sentinel配置"></a>Feign整合Sentinel配置</h6><ul><li><p>整合步骤</p><ul><li>加入依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>开启Feign对Sentinel的支持</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><ul><li>创建容错类, 实现对应的服务接口, 记得加注解 @Service</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class VideoServiceFallback implements VideoService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Video findById(int videoId) &#123;</span><br><span class="line">        Video video &#x3D; new Video();</span><br><span class="line">        video.setTitle(&quot;熔断降级数据&quot;);</span><br><span class="line">        return video;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Video saveVideo(Video video) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置feign容错类</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;xdclass-video-service&quot;, fallback &#x3D; VideoServiceFallback.class)</span><br></pre></td></tr></table></figure></li></ul><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><ul><li>网关<ul><li>API Gateway，是系统的唯一对外的入口，介于客户端和服务器端之间的中间层，处理非业务功能 提供路由请求、鉴权、监控、缓存、限流等功能</li><li>统一接入<ul><li>智能路由</li><li>AB测试、灰度测试</li><li>负载均衡、容灾处理</li><li>日志埋点（类似Nignx日志）</li></ul></li><li>流量监控<ul><li>限流处理</li><li>服务降级</li></ul></li><li>安全防护<ul><li>鉴权处理</li><li>监控</li><li>机器网络隔离</li></ul></li></ul></li><li>主流的网关<ul><li>zuul：是Netflix开源的微服务网关，和Eureka,Ribbon,Hystrix等组件配合使用，依赖组件比较多，性能教差</li><li>kong: 由Mashape公司开源的，基于Nginx的API gateway</li><li>nginx+lua：是一个高性能的HTTP和反向代理服务器,lua是脚本语言，让Nginx执行Lua脚本，并且高并发、非阻塞的处理各种请求</li><li>springcloud gateway: Spring公司专门开发的网关，替代zuul</li></ul></li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20201116185905741.png" alt="image-20201116185905741"></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul><li><p>加入依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes: #数组形式</span><br><span class="line">        - id: order-service  #路由唯一标识</span><br><span class="line">          uri: http:&#x2F;&#x2F;127.0.0.1:8000  #想要转发到的地址</span><br><span class="line">          order: 1 #优先级，数字越小优先级越高</span><br><span class="line">          predicates: #断言 配置哪个路径才转发</span><br><span class="line">            - Path&#x3D;&#x2F;order-server&#x2F;**</span><br><span class="line">          filters: #过滤器，请求在传递过程中通过过滤器修改</span><br><span class="line">            - StripPrefix&#x3D;1  #去掉第一层前缀</span><br><span class="line"></span><br><span class="line">#访问路径 http:&#x2F;&#x2F;localhost:8888&#x2F;order-server&#x2F;api&#x2F;v1&#x2F;video_order&#x2F;list</span><br><span class="line">#转发路径 http:&#x2F;&#x2F;localhost:8000&#x2F;order-server&#x2F;api&#x2F;v1&#x2F;video_order&#x2F;list  </span><br><span class="line">#需要过滤器去掉前面第一层</span><br></pre></td></tr></table></figure></li></ul><h5 id="gateway整合nacos"><a href="#gateway整合nacos" class="headerlink" title="gateway整合nacos"></a>gateway整合nacos</h5><ul><li><p>原先存在的问题</p><ul><li>微服务地址写死</li><li>负载均衡没做到</li></ul></li><li><p>添加Nacos服务治理配置</p><ul><li>网关添加naocs依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--添加nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>启动类开启支持</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line"></span><br><span class="line">    gateway:</span><br><span class="line">      routes: #数组形式</span><br><span class="line">        - id: order-service  #路由唯一标识</span><br><span class="line">          #uri: http:&#x2F;&#x2F;127.0.0.1:8000  #想要转发到的地址</span><br><span class="line">          uri: lb:&#x2F;&#x2F;xdclass-order-service  # 从nacos获取名称转发,lb是负载均衡轮训策略</span><br><span class="line"></span><br><span class="line">          predicates: #断言 配置哪个路径才转发</span><br><span class="line">            - Path&#x3D;&#x2F;order-server&#x2F;**</span><br><span class="line">          filters: #过滤器，请求在传递过程中通过过滤器修改</span><br><span class="line">            - StripPrefix&#x3D;1 #去掉第一层前缀</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true  #开启网关拉取nacos的服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 访问路径 http:&#x2F;&#x2F;localhost:8888&#x2F;order-server&#x2F;api&#x2F;v1&#x2F;video_order&#x2F;list</span><br></pre></td></tr></table></figure></li></ul><h5 id="断言-过滤"><a href="#断言-过滤" class="headerlink" title="断言+过滤"></a>断言+过滤</h5><p>业务流程</p><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/image-20201116191730944.png" alt="image-20201116191730944"></p><ul><li>需求：接口需要在指定时间进行下线，过后不可以在被访问<ul><li>使用Before ,只要当前时间小于设定时间，路由才会匹配请求</li><li>东8区的2020-09-11T01:01:01.000+08:00后，请求不可访问</li><li>为了方便测试，修改时间即可</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">  - Before&#x3D;2020-09-09T01:01:01.000+08:00</span><br></pre></td></tr></table></figure><ul><li><p>过滤器</p><ul><li>局部过滤器GatewayFilter：应用在某个路由上,每个过滤器工厂都对应一个实现类，并且这些类的名称必须以 GatewayFilterFactory 结尾</li><li>全局过滤器：作用全部路由上,</li></ul></li><li><p>自定义全局过滤器实现鉴权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserGlobalFilter implements GlobalFilter,Ordered &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line"></span><br><span class="line">        String token &#x3D; exchange.getRequest().getHeaders().getFirst(&quot;token&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(token);</span><br><span class="line">        if(StringUtils.isBlank(token))&#123;</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            return exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;继续往下执行</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数字越小，优先级越高</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>注意：网关不要加太多业务逻辑，否则会影响性能，务必记住</p></li></ul><h4 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h4><h5 id="追踪组件Sleuth"><a href="#追踪组件Sleuth" class="headerlink" title="追踪组件Sleuth"></a>追踪组件Sleuth</h5><ul><li>什么是Sleuth<ul><li>一个组件，专门用于记录链路数据的开源组件</li><li>文档：<a href="https://spring.io/projects/spring-cloud-sleuth">https://spring.io/projects/spring-cloud-sleuth</a></li><li>案例</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[order-service,96f95a0dd81fe3ab,852ef4cfcdecabf3,false]</span><br><span class="line"></span><br><span class="line">第一个值，spring.application.name的值</span><br><span class="line"></span><br><span class="line">第二个值，96f95a0dd81fe3ab ，sleuth生成的一个ID，叫Trace ID，用来标识一条请求链路，一条请求链路中包含一个Trace ID，多个Span ID</span><br><span class="line"></span><br><span class="line">第三个值，852ef4cfcdecabf3、spanid 基本的工作单元，获取元数据，如发送一个http</span><br><span class="line"></span><br><span class="line">第四个值：false，是否要将该信息输出到zipkin服务中来收集和展示。</span><br></pre></td></tr></table></figure><ul><li>各个微服务添加依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="链路追踪系统Zipkin"><a href="#链路追踪系统Zipkin" class="headerlink" title="链路追踪系统Zipkin"></a>链路追踪系统Zipkin</h5><ul><li><p>什么是zipkin</p><ul><li>官网<ul><li><a href="https://zipkin.io/">https://zipkin.io/</a></li><li><a href="https://zipkin.io/pages/quickstart.html">https://zipkin.io/pages/quickstart.html</a></li></ul></li><li>大规模分布式系统的APM工具（Application Performance Management）,基于Google Dapper的基础实现，和sleuth结合可以提供可视化web界面分析调用链路耗时情况</li></ul></li><li><p>同类产品</p><ul><li>鹰眼（EagleEye）</li><li>CAT</li><li>twitter开源zipkin，结合sleuth</li><li>Pinpoint，运用JavaAgent字节码增强技术</li></ul></li><li><p>StackDriver Trace (Google)</p></li></ul><ul><li><p>开始使用</p><ul><li>安装包在资料里面，启动服务</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar</span><br></pre></td></tr></table></figure><ul><li>访问入口：<a href="http://127.0.0.1:9411/zipkin/">http://127.0.0.1:9411/zipkin/</a></li><li>zipkin组成：Collector、Storage、Restful API、Web UI组成</li></ul></li></ul><p><img src="/2020/11/10/AlibabaCloud-docker/Users/tarena/AppData/Roaming/Typora/draftsRecover/AlibabaCloud-docker/architecture-1.png" alt="architecture-1"></p><h5 id="Zipkin-Sleuth整合"><a href="#Zipkin-Sleuth整合" class="headerlink" title="Zipkin+Sleuth整合"></a>Zipkin+Sleuth整合</h5><ul><li>sleuth收集跟踪信息通过http请求发送给zipkin server</li><li>zipkin server进行跟踪信息的存储以及提供Rest API即可</li><li>Zipkin UI调用其API接口进行数据展示默认存储是内存，可也用mysql 或者elasticsearch等存储</li><li>微服务加入依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>配置地址和采样百分比配置</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http:&#x2F;&#x2F;127.0.0.1:9411&#x2F; #zipkin地址</span><br><span class="line">    discovery-client-enabled: false  #不用开启服务发现</span><br><span class="line"></span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      probability: 1.0 #采样百分比</span><br><span class="line">默认为0.1，即10%，这里配置1，是记录全部的sleuth信息，是为了收集到更多的数据（仅供测试用）。</span><br><span class="line">在分布式系统中，过于频繁的采样会影响系统性能，所以这里配置需要采用一个合适的值。</span><br></pre></td></tr></table></figure><h5 id="链路追踪日志持久化"><a href="#链路追踪日志持久化" class="headerlink" title="链路追踪日志持久化"></a>链路追踪日志持久化</h5><ul><li><p>现存在的问题</p><ul><li>服务重启会导致链路追踪系统数据丢失</li></ul></li><li><p>持久化配置：mysql或者elasticsearch</p><ul><li>创建数据库表SQL脚本</li><li>启动命令</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE&#x3D;mysql --MYSQL_HOST&#x3D;127.0.0.1 --MYSQL_TCP_PORT&#x3D;3306 --MYSQL_DB&#x3D;zipkin_log --MYSQL_USER&#x3D;root --MYSQL_PASS&#x3D;xdclass.net</span><br></pre></td></tr></table></figure></li></ul><h4 id="nacos配置中心"><a href="#nacos配置中心" class="headerlink" title="nacos配置中心"></a>nacos配置中心</h4><h5 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h5><ul><li>配置中心：<ul><li>一句话：统一管理配置, 快速切换各个环境的配置</li></ul></li><li>相关产品：<ul><li>百度的disconf 地址:<a href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a></li><li>阿里的diamand 地址：<a href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a></li><li>springcloud的configs-server: 地址：<a href="http://cloud.spring.io/spring-cloud-config/">http://cloud.spring.io/spring-cloud-config/</a></li><li>阿里的Nacos:既可以当服务治理，又可以当配置中心，Nacos = Eureka + Config</li></ul></li></ul><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><ul><li>项目添加依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li><p>配置文件优先级讲解（坑）</p><ul><li>不能使用原先的application.yml, 需要使用bootstrap.yml作为配置文件</li><li>配置读取优先级 bootstrap.yml &gt; application.yml</li></ul></li><li><p>配置实操</p><ul><li>订单服务迁移配置</li><li>增加bootstrap.yml</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: xdclass-order-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        server-addr: 127.0.0.1:8848 #Nacos配置中心地址</span><br><span class="line">        file-extension: yaml #文件拓展格式</span><br><span class="line"></span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>启动微服务服务验证</p><ul><li>测试是否可以获取配置</li></ul></li></ul><h3 id="整合docker"><a href="#整合docker" class="headerlink" title="整合docker"></a>整合docker</h3><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><ul><li>父项目添加springboot版本依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;java.version&gt;11&lt;&#x2F;java.version&gt;</span><br><span class="line">       &lt;maven.compiler.source&gt;11&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">       &lt;maven.compiler.target&gt;11&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">       &lt;spring.boot.version&gt;2.3.3.RELEASE&lt;&#x2F;spring.boot.version&gt;</span><br><span class="line"> &lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><ul><li>每个子模块项目添加依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;配置文件增加</span><br><span class="line">&lt;docker.image.prefix&gt;PREFIX_ANYTHING&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;alibaba-cloud-gateway&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">                    &lt;addResources&gt;true&lt;&#x2F;addResources&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;dockerfile-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.4.10&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;repository&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;repository&gt;</span><br><span class="line">                    &lt;buildArgs&gt;</span><br><span class="line">                        &lt;JAR_FILE&gt;target&#x2F;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;JAR_FILE&gt;</span><br><span class="line">                    &lt;&#x2F;buildArgs&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><ul><li>Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;project.build.finalName&#125; 产出物名称，缺省为$&#123;project.artifactId&#125;-$&#123;project.version&#125;</span><br></pre></td></tr></table></figure><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><ul><li><p>创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径）</p></li><li><p>什么是Dockerfile</p><ul><li>由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM  adoptopenjdk&#x2F;openjdk11:ubi</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ARG JAR_FILE</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的，</span><br><span class="line">后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令</span><br><span class="line">      </span><br><span class="line">VOLUME  配置一个具有持久化功能的目录，主机 &#x2F;var&#x2F;lib&#x2F;docker 目录下创建了一个临时文件，并链接到容器的&#x2F;tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。</span><br><span class="line">&#x2F;tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用&#x2F;tmp作为工作目录 </span><br><span class="line"></span><br><span class="line">ARG  设置编译镜像时加入的参数， JAR_FILE 是设置容器的环境变量(maven里面配置的)</span><br><span class="line">COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点</span><br><span class="line">ENTRYPOINT 容器启动时执行的命令</span><br><span class="line"></span><br><span class="line">EXPOSE 8080 暴露镜像端口</span><br></pre></td></tr></table></figure></li><li><p>构建镜像( 去到子模块pom文件下，不然启动时会报错)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install -Dmaven.test.skip&#x3D;true dockerfile:build</span><br><span class="line">&#x2F;&#x2F;no main manifest attribute, in &#x2F;app.jar   xxx.jar中没有主清单属性</span><br></pre></td></tr></table></figure></li></ul><h5 id="推送仓库"><a href="#推送仓库" class="headerlink" title="推送仓库"></a>推送仓库</h5><ul><li><p><a href="https://cr.console.aliyun.com/repository/cn-beijing/zyaire-cloud/gateway/details">https://cr.console.aliyun.com/repository/cn-beijing/zyaire-cloud/gateway/details</a></p><p>自己阿里云容器镜像仓库有操作手册</p></li></ul><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><h5 id="docker部署nacos"><a href="#docker部署nacos" class="headerlink" title="docker部署nacos"></a>docker部署nacos</h5><ul><li>拉取特别慢</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路径&#x2F;etc&#x2F;docker&#x2F;daemon.json 增加下面的配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;pb5bklzr.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重启</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ul><li>docker拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure><ul><li>查看镜像</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>启动Nacos</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --env MODE&#x3D;standalone --name xdclass-nacos -d -p 8848:8848 ef8e53226440 (镜像id)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看日志</span><br><span class="line">docker logs -f </span><br></pre></td></tr></table></figure><ul><li>访问Nacos（记得开放阿里云的网络安全组）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;公网ip:8848&#x2F;nacos</span><br><span class="line"></span><br><span class="line"># 登录密码默认nacos&#x2F;nacos</span><br></pre></td></tr></table></figure><ul><li>注意docker要启动</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@zyaire ~]# docker pull nacos&#x2F;nacos-server</span><br><span class="line">Using default tag: latest</span><br><span class="line">Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><ul><li>机器配置，nacos安装在高配机器</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 vCPU 1 GiB (安装了Mysql&#x2F;Zipkin服务)</span><br><span class="line"></span><br><span class="line">2 vCPU 4 GiB（安装了Nacos、Sentinel、网关、视频服务、订单服务）</span><br></pre></td></tr></table></figure><h5 id="docker部署sentinel"><a href="#docker部署sentinel" class="headerlink" title="docker部署sentinel"></a>docker部署sentinel</h5><ul><li>docker拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull bladex&#x2F;sentinel-dashboard:latest</span><br></pre></td></tr></table></figure><ul><li>查看镜像</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>启动Sentinel</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel -d -p 8858:8858  镜像id</span><br></pre></td></tr></table></figure><ul><li>访问Sentinel（记得开放阿里云的网络安全组）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;公网ip:8858</span><br><span class="line"></span><br><span class="line"># 登录密码默认sentinel&#x2F;sentinel</span><br></pre></td></tr></table></figure><ul><li>机器配置, 安装在高配机器(就是微服务同个宿主机)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 vCPU 1 GiB (安装了Mysql&#x2F;Zipkin服务)</span><br><span class="line"></span><br><span class="line">2 vCPU 4 GiB（安装了Nacos、Sentinel、网关、视频服务、订单服务）</span><br></pre></td></tr></table></figure><h5 id="Docker部署Zipkin"><a href="#Docker部署Zipkin" class="headerlink" title="Docker部署Zipkin"></a>Docker部署Zipkin</h5><ul><li>docker拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull openzipkin&#x2F;zipkin:latest</span><br></pre></td></tr></table></figure><ul><li>查看镜像</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>启动Zipkin</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name xdclass-zipkin -d -p 9411:9411 镜像id</span><br></pre></td></tr></table></figure><ul><li>访问zipkin（记得开放阿里云的网络安全组）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;公网ip:9411&#x2F;zipkin&#x2F;</span><br></pre></td></tr></table></figure><ul><li>机器配置, 部署在低配服务器</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">120.24.216.117(公)</span><br><span class="line"></span><br><span class="line">2 vCPU 4 GiB（安装了Nacos、Sentinel、网关、视频服务、订单服务）</span><br></pre></td></tr></table></figure><h5 id="快速安装mysql"><a href="#快速安装mysql" class="headerlink" title="快速安装mysql"></a>快速安装mysql</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#下载mysql的Yum仓库</span><br><span class="line">wget -i -c http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line"></span><br><span class="line">#安装 mysql服务</span><br><span class="line">yum -y install mysql-community-server</span><br><span class="line"></span><br><span class="line">#启动数据库服务， systemctl 该命令可用于查看系统状态和管理系统及服务，centos7上开始使用</span><br><span class="line">systemctl start  mysqld.service</span><br><span class="line"></span><br><span class="line">#查看状态</span><br><span class="line">systemctl status mysqld.service</span><br><span class="line"></span><br><span class="line">#在日志文件中查看初始密码</span><br><span class="line">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line"></span><br><span class="line">#进入修改Mysql密码</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">#新密码设置必须由大小写字母、数字和特殊符号组成</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Xdclass.net168&#39;;</span><br><span class="line"></span><br><span class="line">#开启mysql的远程访问， %是指全部</span><br><span class="line">grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;Xdclass.net168&#39; with grant option;</span><br><span class="line"></span><br><span class="line">#刷新权限</span><br><span class="line">flush privileges; </span><br></pre></td></tr></table></figure><h5 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h5><ul><li>记得打开网关的端口</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AlibabaCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx整合openResty+lua+高可用解决方案</title>
      <link href="2020/11/07/nginx%E6%95%B4%E5%90%88openResty-lua-%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2020/11/07/nginx%E6%95%B4%E5%90%88openResty-lua-%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="入门介绍"><a href="#入门介绍" class="headerlink" title="入门介绍"></a>入门介绍</h3><ul><li><p>环境搭建:</p><p>Nginx-1.18版本 + openresty-1.17.8.2 + LVS</p><p>操作系统：阿里云Linux Centos7 64位 + 本地虚拟机Centos7 64位</p></li><li><p>大概内容</p><ul><li>搭建前端静态资源服务器、文件服务器、BAT大厂自研运维平台数据统计案例</li><li>负载均衡Upstream配置实战、后端节点高可用性探测、全局异常兜底数据配置</li><li>Nginx封禁恶意IP、配置跨域、location和rewrite实战</li><li>Websocket配置、后端业务数据缓存前置、静态资源压缩</li><li>阿里云ECS部署Nginx + HTTPS证书</li><li>高级拓展Nginx整合Openresty开发内网访问限制、文件资源下载限速实现原理</li><li>Nginx高可用解决访问 LVS + KeepAlived讲解+多节点配置实操</li><li>Nginx架构Master-Work多进程模型</li></ul></li><li><p>容易采坑的点：</p><ul><li>就是配置多，没有比较好的编辑器</li><li>很多错误配置，就是配置少加了 英文分号 ; 或者用了中文的； 或者防火墙问题，或者配置多了空格等特殊字符。</li></ul></li></ul><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><ul><li><p>Nginx介绍</p><ul><li>官网：<a href="http://nginx.org/">http://nginx.org/</a></li><li>是一个高性能的[HTTP]和[反向代理]web服务器</li><li>Nginx代码完全用[C语言]从头写成</li><li>系统：Mac/Windows/Linux</li></ul></li><li><p>市场上使用情况</p><ul><li>阿里、腾讯、百度等，全球反向代理服务器中排名</li><li>据统计，世界上每3个网站中就有一个使用Nginx </li></ul></li><li><p>为什么要用这个</p><ul><li>社区活跃</li><li>高性能-支持单机千万级连接</li><li>强大的第三方库支持</li><li>功能强大：负载均衡、静态文件服务器、支持多种协议https、POP3等等</li></ul></li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><ul><li><p>下载压缩包 并上传</p><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p></li><li><p>安装依赖</p></li><li><p>yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</p></li><li><p>创建一个文件夹，上传本地提供的nginx包</p><ul><li><p>tar -zxvf nginx-1.18.0.tar.gz</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure  </span><br><span class="line">#后面加上指定安装路径--prefix&#x3D;filepath</span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认安装路径</p><ul><li>/usr/local/nginx</li></ul></li><li><p>访问配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin   </span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure></li><li><p>访问80端口，如果没有显示注意防火墙是否关闭，或者打开端口并配置安全组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打开80端口</span><br><span class="line">firewall-cmd --permanent --add-port&#x3D;80&#x2F;tcp</span><br><span class="line">#重启防火墙</span><br><span class="line">firewall-cmd  --reload</span><br></pre></td></tr></table></figure></li></ul><h5 id="本地虚CentOS拟机"><a href="#本地虚CentOS拟机" class="headerlink" title="本地虚CentOS拟机"></a>本地虚CentOS拟机</h5><ol><li><p>安装</p><p>步骤大同小异，建议关闭防火墙</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.serivce</span><br></pre></td></tr></table></figure></li><li><p>本地域名映射虚拟机IP</p><ul><li>Windows :</li></ul><p><a href="https://www.cnblogs.com/spirit-ling/p/8646895.html">https://www.cnblogs.com/spirit-ling/p/8646895.html</a></p><p><a href="https://jingyan.baidu.com/article/5bbb5a1b15c97c13eba1798a.html">https://jingyan.baidu.com/article/5bbb5a1b15c97c13eba1798a.html</a></p><ul><li><p>Mac苹果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;private&#x2F;etc</span><br><span class="line">sudo vim hosts</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h5><ul><li><p>默认安装目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx</span><br></pre></td></tr></table></figure></li><li><p>目录核心介绍</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conf  #所有配置文件目录</span><br><span class="line">nginx.conf    #默认的主要的配置文件</span><br><span class="line">nginx.conf.default  #默认模板</span><br><span class="line">html  # 这是编译安装时Nginx的默认站点目录</span><br><span class="line"> 50x.html #错误页面</span><br><span class="line">  index.html #默认首页</span><br><span class="line">logs  # nginx默认的日志路径，包括错误日志及访问日志</span><br><span class="line"> error.log  #错误日志</span><br><span class="line"> nginx.pid  #nginx启动后的进程id</span><br><span class="line"> access.log #nginx访问日志</span><br><span class="line">sbin  #nginx命令的目录 </span><br><span class="line">   nginx  #启动命令 </span><br></pre></td></tr></table></figure></li><li><p>常见命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx  #默认配置文件启动</span><br><span class="line">.&#x2F;nginx -s reload #重启，加载默认配置文件</span><br><span class="line">.&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf #启动指定某个配置文件</span><br><span class="line">.&#x2F;nginx -s stop #停止</span><br><span class="line">#关闭进程，nginx有master process 和worker process,关闭master即可</span><br><span class="line">ps -ef | grep &quot;nginx&quot;</span><br><span class="line">kill -9 PID   </span><br></pre></td></tr></table></figure></li></ul><h5 id="配置文件剖析"><a href="#配置文件剖析" class="headerlink" title="配置文件剖析"></a>配置文件剖析</h5><ul><li>全局配置</li><li>server 主机设置</li><li>location（URL匹配特定位置的设置）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 每个配置项由配置指令和指令参数 2 个部分构成</span><br><span class="line">#user  nobody;  # 指定Nginx Worker进程运行以及用户组</span><br><span class="line">worker_processes  1;   # </span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;  # 错误日志的存放路径  和错误日志</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;   # 进程PID存放路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 事件模块指令，用来指定Nginx的IO模型，Nginx支持的有select、poll、kqueue、epoll 等。不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，对于Linux系统，epoll工作模式是首选</span><br><span class="line">events &#123; </span><br><span class="line">    use epoll;</span><br><span class="line">  # 定义Nginx每个进程的最大连接数， 作为服务器来说: worker_connections * worker_processes,</span><br><span class="line">  # 作为反向代理来说，最大并发数量应该是worker_connections * worker_processes&#x2F;2。因为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接</span><br><span class="line">    worker_connections  1024; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    # 自定义服务日志</span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    # 是否开启高效传输模式 on开启 off关闭</span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    #减少网络报文段的数量</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    # 客户端连接保持活动的超时时间，超过这个时间之后，服务器会关闭该连接</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    </span><br><span class="line">    # 虚拟主机的配置</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80; # 虚拟主机的服务端口</span><br><span class="line">        server_name  localhost; #用来指定IP地址或域名，多个域名之间用空格分开</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        #URL地址匹配</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;  # 服务默认启动目录</span><br><span class="line">            index  index.html index.htm; #默认访问文件，按照顺序找</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;   #错误状态码的显示页面</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/11/07/nginx%E6%95%B4%E5%90%88openResty-lua-%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200805165028902.png" alt="image-20200805165028902"></p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><h5 id="Nginx虚拟主机-搭建前端静态服务器"><a href="#Nginx虚拟主机-搭建前端静态服务器" class="headerlink" title="Nginx虚拟主机-搭建前端静态服务器"></a>Nginx虚拟主机-搭建前端静态服务器</h5><ul><li>Nginx虚拟主机配置</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  aabbcc.com;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html;</span><br><span class="line">            index  xdclass.html;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  aabbccdd.com;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  xdclass.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="nignx搭建图片-文件服务器"><a href="#nignx搭建图片-文件服务器" class="headerlink" title="nignx搭建图片-文件服务器"></a>nignx搭建图片-文件服务器</h5><ul><li><p>前端提交图片-&gt;后端处理-&gt;存储到图片服务器-&gt;拼接好访问路径存储到数据库和范围前端</p><p><img src="/2020/11/07/nginx%E6%95%B4%E5%90%88openResty-lua-%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200805170959885.png" alt="image-20200805170959885"></p></li><li><p>本地图片上传上去，配置专属访问路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  aabbccdd.com;</span><br><span class="line">location &#x2F;app&#x2F;img &#123;</span><br><span class="line">alias &#x2F;usr&#x2F;local&#x2F;software&#x2F;img&#x2F;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>在location / 中配置root目录</li><li>在location /path中配置alias虚拟目录， 目录后面的”/“符号一定要带上</li></ul></li></ul><h5 id="Nginx挖掘accessLog日志"><a href="#Nginx挖掘accessLog日志" class="headerlink" title="Nginx挖掘accessLog日志"></a>Nginx挖掘accessLog日志</h5><h6 id="日志的用处"><a href="#日志的用处" class="headerlink" title="日志的用处"></a>日志的用处</h6><ul><li><p>access.log日志用处</p><ul><li>统计站点访问ip来源、某个时间段的访问频率</li><li>查看访问最频的页面、Http响应状态码、接口性能</li><li>接口秒级访问量、分钟访问量、小时和天访问量</li></ul></li><li><p>默认配置解析</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">#                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">#                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br></pre></td></tr></table></figure></li><li><p>案例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">122.70.148.18 - - [04&#x2F;Aug&#x2F;2020:14:46:48 +0800] &quot;GET &#x2F;user&#x2F;api&#x2F;v1&#x2F;product&#x2F;order&#x2F;query_state?product_id&#x3D;1&amp;token&#x3D;xdclasseyJhbGciOJE HTTP&#x2F;1.1&quot; 200 48 &quot;https:&#x2F;&#x2F;xdclass.net&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.89 Safari&#x2F;537.36&quot;</span><br></pre></td></tr></table></figure></li><li><p>解析</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$remote_addr 对应的是真实日志里的122.70.148.18，即客户端的IP。</span><br><span class="line"></span><br><span class="line">$remote_user 对应的是第二个中杠“-”，没有远程用户，所以用“-”填充。</span><br><span class="line"></span><br><span class="line">［$time_local］对应的是[04&#x2F;Aug&#x2F;2020:14:46:48 +0800]。</span><br><span class="line"></span><br><span class="line">“$request”对应的是&quot;GET &#x2F;user&#x2F;api&#x2F;v1&#x2F;product&#x2F;order&#x2F;query_state?product_id&#x3D;1&amp;token&#x3D;xdclasseyJhbGciOJE HTTP&#x2F;1.1&quot;。</span><br><span class="line"></span><br><span class="line">$status对应的是200状态码，200表示正常访问。</span><br><span class="line"></span><br><span class="line">$body_bytes_sent对应的是48字节，即响应body的大小。</span><br><span class="line"></span><br><span class="line">“$http_referer” 对应的是”https:&#x2F;&#x2F;xdclass.net&#x2F;“，若是直接打开域名浏览的时，referer就会没有值，为”-“。</span><br><span class="line"></span><br><span class="line">“$http_user_agent” 对应的是”Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.12; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0”。</span><br><span class="line"></span><br><span class="line">“$http_x_forwarded_for” 对应的是”-“或者空。</span><br></pre></td></tr></table></figure></li></ul><h6 id="案例实战-统计站点访问量、高频url"><a href="#案例实战-统计站点访问量、高频url" class="headerlink" title="案例实战-统计站点访问量、高频url"></a>案例实战-统计站点访问量、高频url</h6><ul><li><p>查看访问最频繁的前100个IP</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#123;print $1&#125;&#39; access_temp.log | sort -n |uniq -c | sort -rn | head -n 100</span><br></pre></td></tr></table></figure></li><li><p>统计访问最多的url 前20名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat access_temp.log |awk &#39;&#123;print $7&#125;&#39;| sort|uniq -c| sort -rn| head -20 | more</span><br></pre></td></tr></table></figure></li><li><p>基础</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk 是文本处理工具，默认按照空格切分，$N 是第切割后第N个，从1开始</span><br><span class="line"></span><br><span class="line">sort命令用于将文本文件内容加以排序，-n 按照数值排，-r 按照倒序来排</span><br><span class="line"></span><br><span class="line">  案例的sort -n 是按照第一列的数值大小进行排序，从小到大，倒序就是 sort -rn</span><br><span class="line">uniq 去除重复出现的行列, -c 在每列旁边显示该行重复出现的次数。</span><br></pre></td></tr></table></figure></li></ul><h6 id="案例实战-自定义日志统计接口性能"><a href="#案例实战-自定义日志统计接口性能" class="headerlink" title="案例实战-自定义日志统计接口性能"></a>案例实战-自定义日志统计接口性能</h6><p><strong>简介 自定义日志格式，统计接口响应耗时</strong></p><ul><li><p>日志格式增加 <strong>$request_time</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从接受用户请求的第一个字节到发送完响应数据的时间，即包括接收请求数据时间、程序响应时间、输出响应数据时间</span><br><span class="line"></span><br><span class="line">$upstream_response_time：指从Nginx向后端建立连接开始到接受完数据然后关闭连接为止的时间</span><br><span class="line"></span><br><span class="line">$request_time一般会比upstream_response_time大，因为用户网络较差，或者传递数据较大时，前者会耗时大很多</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置自定义日志格式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line"></span><br><span class="line">                     &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line"></span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; $request_time&#39;;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">        listen       80;</span><br><span class="line"></span><br><span class="line">        server_name  aabbcc.com;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">            root   &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">            index  xdclass.html;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #</span><br><span class="line"></span><br><span class="line">        access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>统计耗时接口, 列出传输时间超过 2 秒的接口，显示前5条</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat time_temp.log|awk &#39;($NF &gt; 2)&#123;print $7&#125;&#39;|sort -n|uniq -c|sort -nr|head -5</span><br><span class="line"></span><br><span class="line">备注：$NF 表示最后一列, awk &#39;&#123;print $N</span><br><span class="line">F&#125;&#39;</span><br></pre></td></tr></table></figure></li></ul><h3 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h3><h4 id="Nginx配置集群应用-负载均衡策略"><a href="#Nginx配置集群应用-负载均衡策略" class="headerlink" title="Nginx配置集群应用-负载均衡策略"></a>Nginx配置集群应用-负载均衡策略</h4><h5 id="Linux安装JDK8环境"><a href="#Linux安装JDK8环境" class="headerlink" title="Linux安装JDK8环境"></a>Linux安装JDK8环境</h5><ul><li><p>安装JDK8环境</p><ul><li><p>官方地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p></li><li><p>配置全局环境变量</p><ul><li>解压：tar -zxvf jdk-8u171-linux-x64.tar.gz</li><li>重命名</li><li>vim /etc/profile</li><li>配置</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;software&#x2F;jdk&#x2F;jdk8</span><br><span class="line">CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>环境变量立刻生效</p><ul><li>source /etc/profile</li></ul></li><li><p>查看安装情况 java -version</p></li></ul></li></ul><h5 id="后端应用集群构建"><a href="#后端应用集群构建" class="headerlink" title="后端应用集群构建"></a>后端应用集群构建</h5><ul><li><p>准备两个一样的Jar包</p><ul><li>demo-1.jar监听8080端口</li><li>demo-2.jar监听8081端口 </li></ul></li><li><p>接口说明</p><ul><li>接口一<ul><li>GET请求，返回json数据，控制输出日志</li><li><a href="http://127.0.0.1:8080/api/v1/pub/info/check">http://127.0.0.1:8080/api/v1/pub/info/check</a></li></ul></li><li>接口二<ul><li>返回HTML页面，两个jar返回的HTML内容不一样，方便区分访问的是哪个jar</li><li><a href="http://localhost:8080/api/v1/pub/web">http://localhost:8080/api/v1/pub/web</a></li></ul></li></ul></li><li><p>直接启动</p><ul><li>java -jar demo-1.jar</li><li>java -jar demo-2.jar</li></ul></li><li><p>守护进程方式</p><ul><li>nohup java -jar demo-1.jar &amp;</li><li>nohup java -jar demo-2.jar &amp;</li></ul></li></ul><h5 id="Nginx负载均衡upstream"><a href="#Nginx负载均衡upstream" class="headerlink" title="Nginx负载均衡upstream"></a>Nginx负载均衡upstream</h5><h6 id="Nginx的upstream模板介绍"><a href="#Nginx的upstream模板介绍" class="headerlink" title="Nginx的upstream模板介绍"></a>Nginx的upstream模板介绍</h6><ul><li><p>负载均衡（Load Balance）</p><ul><li>分布式系统中一个非常重要的概念，当访问的服务具有多个实例时，需要根据某种“均衡”的策略决定请求发往哪个节点，这就是所谓的负载均衡，</li><li>原理是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，从而提高了数据的吞吐量</li></ul></li><li><p>负载均衡的种类</p><ul><li>通过硬件来进行解决，常见的硬件有NetScaler、F5、Radware和Array等商用的负载均衡器，但比较昂贵的</li><li>通过软件来进行解决，常见的软件有LVS、Nginx等,它们是基于Linux系统并且开源的负载均衡策略</li></ul></li><li><p>配置案例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream lbs &#123;</span><br><span class="line"></span><br><span class="line">   server 192.168.0.106:8080;</span><br><span class="line">   server 192.168.0.106:8081;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">location &#x2F;api&#x2F; &#123;</span><br><span class="line"></span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;lbs;</span><br><span class="line">    proxy_redirect default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="负载均衡策略解析"><a href="#负载均衡策略解析" class="headerlink" title="负载均衡策略解析"></a>负载均衡策略解析</h6><ul><li><p>Nginx常见的负载均衡策略</p><ul><li><p>节点轮询（默认）</p><ul><li>简介：每个请求按顺序分配到不同的后端服务器</li><li>场景：会造成可靠性低和负载分配不均衡，适合静态文件服务器</li></ul></li><li><p>weight 权重配置</p><ul><li>简介：weight和访问比率成正比，数字越大，分配得到的流量越高</li><li>场景：服务器性能差异大的情况使用</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream lbs &#123;</span><br><span class="line"></span><br><span class="line">   server 192.168.159.133:8080 weight&#x3D;5;</span><br><span class="line">   server 192.168.159.133:8081 weight&#x3D;10; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Nginx常见的负载均衡策略</p><ul><li><p>ip_hash（固定分发）</p><ul><li>简介：根据请求按访问ip的hash结果分配，这样每个用户就可以固定访问一个后端服务器</li><li>场景：服务器业务分区、业务缓存、Session需要单点的情况</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream lbs &#123;</span><br><span class="line">   ip_hash;</span><br><span class="line">   server 192.168.159.133:8080;</span><br><span class="line">   server 192.168.159.133:8081;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>upstream还可以为每个节点设置状态值</p><ul><li>down 表示当前的server暂时不参与负载</li></ul></li><li><p>server 192.168.159.133:8080 down;</p></li><li><p>backup 其它所有的非backup机器down的时候，会请求backup机器，这台机器压力会最轻，配置也会相对低</p><ul><li>server 192.168.159.133:8080 backup;</li></ul></li></ul><h6 id="Nginx后端节点可用性探测和配置"><a href="#Nginx后端节点可用性探测和配置" class="headerlink" title="Nginx后端节点可用性探测和配置"></a>Nginx后端节点可用性探测和配置</h6><ul><li>如果某个应用挂了，请求不应该继续分发过去<ul><li>max_fails 允许请求失败的次数，默认为1.当超过最大次数时就不会请求</li><li>fail_timeout : max_fails次失败后，暂停的时间，默认：fail_timeout为10s</li><li>参数解释<ul><li>max_fails=N 设定Nginx与后端节点通信的尝试失败的次数。</li><li>在fail_timeout参数定义的时间内，如果失败的次数达到此值，Nginx就这个节点不可用。</li><li>在下一个fail_timeout时间段到来前，服务器不会再被尝试。</li><li>失败的尝试次数默认是1，如果设为0就会停止统计尝试次数，认为服务器是一直可用的。</li></ul></li><li>具体什么是nginx认为的失败呢<ul><li>可以通过指令proxy_next_upstream来配置什么是失败的尝试。</li><li>注意默认配置时，http_404状态不被认为是失败的尝试。</li></ul></li></ul></li><li>配置实操</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream lbs &#123;</span><br><span class="line">                server 192.168.0.106:8080 max_fails&#x3D;2 fail_timeout&#x3D;60s ;</span><br><span class="line">                server 192.168.0.106:8081 max_fails&#x3D;2 fail_timeout&#x3D;60s;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F;api&#x2F; &#123;</span><br><span class="line">         proxy_pass http:&#x2F;&#x2F;lbs;</span><br><span class="line">         proxy_next_upstream error timeout http_500 http_503 http_404;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="玩转Nginx经典应用"><a href="#玩转Nginx经典应用" class="headerlink" title="玩转Nginx经典应用"></a>玩转Nginx经典应用</h4><h5 id="全局异常兜底数据返回"><a href="#全局异常兜底数据返回" class="headerlink" title="全局异常兜底数据返回"></a>全局异常兜底数据返回</h5><ul><li>任何接口都是可能出错，4xx、5xx等</li><li>如果业务没有做好统一的错误管理，直接暴露给用户，无疑是看不懂</li><li>所以假如后端某个业务出错，nginx层也需要进行转换</li><li>让前端知道Http响应是200，其实是将错误的状态码定向至200，返回了全局兜底数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;lbs;</span><br><span class="line">            proxy_redirect default;</span><br><span class="line">           </span><br><span class="line">            # 存放用户的真实ip</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;  </span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class="line">            </span><br><span class="line">            proxy_next_upstream error timeout http_503 non_idempotent;</span><br><span class="line"></span><br><span class="line">            #开启错误拦截配置,一定要开启</span><br><span class="line">            proxy_intercept_errors on;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># 不加 &#x3D;200，则返回的就是原先的http错误码；配上后如果出现500等错误都返回给用户200状态，并跳转至&#x2F;default_api</span><br><span class="line">  error_page  404 500 502 503 504  &#x3D;200  &#x2F;default_api;</span><br><span class="line">  location &#x3D; &#x2F;default_api &#123;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">    return 200 &#39;&#123;&quot;code&quot;:&quot;-1&quot;,&quot;msg&quot;:&quot;invoke fail, not found &quot;&#125;&#39;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="封禁恶意IP"><a href="#封禁恶意IP" class="headerlink" title="封禁恶意IP"></a>封禁恶意IP</h5><ul><li><p>网络攻击时有发生，</p><ul><li>TCP洪水攻击、注入攻击、DOS等</li><li>比较难防的有DDOS等</li></ul></li><li><p>数据安全，防止对手爬虫恶意爬取，封禁IP</p></li><li><p>一般就是封禁ip</p><ul><li><p>linux server的层面封IP：iptables</p></li><li><p>nginx的层面封IP ，方式多种 (但 req还是会打进来， 让nginx 返回 403, 占用资源)</p><ul><li>Nginx作为网关，可以有效的封禁ip</li><li>单独网站屏蔽IP的方法，把include xxx; 放到网址对应的在server{}语句块,虚拟主机</li><li>所有网站屏蔽IP的方法，把include xxx; 放到http {}语句块。</li></ul><p>nginx配置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    # ....</span><br><span class="line">    include blacklist.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;lbs;</span><br><span class="line">                proxy_redirect default;</span><br><span class="line">&#125;</span><br><span class="line">#blacklist.conf目录下文件内容</span><br><span class="line">deny 192.168.159.2;</span><br><span class="line">deny 192.168.159.32;</span><br></pre></td></tr></table></figure></li><li><p>./nginx -s reload #重新加载配置，不中断服务</p></li></ul></li></ul><ul><li><p>拓展-自动化封禁思路</p><ul><li>编写shell脚本</li><li>AWK统计access.log，记录每秒访问超过60次的ip，然后配合nginx或者iptables进行封禁</li><li>crontab定时跑脚本</li></ul></li></ul><h5 id="Nginx配置浏览器跨域"><a href="#Nginx配置浏览器跨域" class="headerlink" title="Nginx配置浏览器跨域"></a>Nginx配置浏览器跨域</h5><hr><ul><li><p>一句话：浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口不同</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器控制台跨域提示：</span><br><span class="line"></span><br><span class="line">No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access.</span><br></pre></td></tr></table></figure></li><li><p>解决方法</p><ul><li>JSONP</li><li>Http响应头配置允许跨域<ul><li>nginx层配置</li><li>程序代码中处理通过拦截器配置</li></ul></li></ul></li><li><p>Nginx开启跨域配置</p><ul><li><p>location下配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123; </span><br><span class="line"></span><br><span class="line">    add_header &#39;Access-Control-Allow-Origin&#39; $http_origin;</span><br><span class="line">    add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">    add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#39;;</span><br><span class="line"></span><br><span class="line">    add_header Access-Control-Allow-Methods &#39;GET,POST,OPTIONS&#39;;</span><br><span class="line"></span><br><span class="line">#如果预检请求则返回成功,不需要转发到后端</span><br><span class="line"></span><br><span class="line">  if ($request_method &#x3D; &#39;OPTIONS&#39;) </span><br><span class="line">      add_header &#39;Access-Control-Max-Age&#39; 1728000;</span><br><span class="line">      add_header &#39;Content-Type&#39; &#39;text&#x2F;plain; charset&#x3D;utf-8&#39;;</span><br><span class="line">      add_header &#39;Content-Length&#39; 0;</span><br><span class="line">      return 200;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="Nginx的location规则应用"><a href="#Nginx的location规则应用" class="headerlink" title="Nginx的location规则应用"></a>Nginx的location规则应用</h5><ul><li><p>正则</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ 以什么开始</span><br><span class="line">$ 以什么结束</span><br><span class="line">^&#x2F;api&#x2F;user$</span><br></pre></td></tr></table></figure></li><li><p>location 路径匹配</p><ul><li>语法 <strong>location [ = | ~ | <del>* | ^</del> ] uri { …… }</strong></li></ul></li><li><p>location = /uri</p></li><li><p>= 表示精准匹配，只要完全匹配上才能生效</p></li><li><p>location /uri</p><ul><li>不带任何修饰符，表示前缀匹配 </li></ul></li><li><p>location ^~ /uri/</p><ul><li>匹配任何已 /uri/ 开头的任何查询并且停止搜索 </li></ul></li><li><p>location /</p><ul><li>通用匹配，任何未匹配到其他location的请求都会匹配到 </li></ul></li><li><p>正则匹配</p><ul><li>区分大小写匹配（~）</li><li>不区分大小写匹配（~*）</li></ul></li><li><p>优先级(不要写复杂，容易出问题和遗忘)</p></li><li><p>精准匹配 &gt; 字符串匹配(若有多个匹配项匹配成功，那么选择匹配长的并记录) &gt; 正则匹配</p></li><li><p>案例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">   server_name xdclass.net;   </span><br><span class="line">   location ~^&#x2F;api&#x2F;pub$ &#123; </span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">^&#x2F;api&#x2F;pub$这个正则表达式表示字符串必须以&#x2F;开始，以b $结束，中间必须是&#x2F;api&#x2F;pub</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;xdclass.net&#x2F;api&#x2F;v1 匹配（完全匹配）</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;xdclass.net&#x2F;API&#x2F;PUB 不匹配，大小写敏感</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;xdclass.net&#x2F;api&#x2F;pub?key1&#x3D;value1 匹配</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;xdclass.net&#x2F;api&#x2F;pub&#x2F; 不匹配</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;xdclass.net&#x2F;api&#x2F;public 不匹配，不能匹配正则表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x3D; &#x2F;img&#x2F;test.png &#123;</span><br><span class="line">         return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   location  &#x2F;img&#x2F;test.png &#123;</span><br><span class="line">         return 2;</span><br><span class="line">   &#125;</span><br><span class="line">  location ^~&#x2F;img&#x2F; &#123;</span><br><span class="line">       return 3;</span><br><span class="line">    &#125;</span><br><span class="line">   location &#x3D; &#x2F; &#123;</span><br><span class="line">    return 4;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   location &#x2F; &#123;</span><br><span class="line">         return 5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="地址重定向-Nginx的rewrite规则应用"><a href="#地址重定向-Nginx的rewrite规则应用" class="headerlink" title="地址重定向-Nginx的rewrite规则应用"></a>地址重定向-Nginx的rewrite规则应用</h5><ul><li><p>重写-重定向</p></li><li><p>rewrite 地址重定向，实现URL重定向的重要指令，他根据regex(正则表达式)来匹配内容跳转到</p><ul><li>语法 rewrite regex replacement[flag]</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rewrite ^&#x2F;(.*)  https:&#x2F;&#x2F;xdclass.net&#x2F;$1 permanent</span><br><span class="line">#这是一个正则表达式，匹配完整的域名和后面的路径地址</span><br><span class="line">replacement部分是https:&#x2F;&#x2F;xdclass.net&#x2F;$1，$1是取自regex部分()里的内容</span><br></pre></td></tr></table></figure></li><li><p>常用正则表达式：</p></li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串的起始位置</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td></tr><tr><td>*</td><td>匹配前面的字符零次或者多次</td></tr><tr><td>+</td><td>匹配前面字符串一次或者多次</td></tr><tr><td>?</td><td>匹配前面字符串的零次或者一次</td></tr><tr><td>.</td><td>匹配除“\n”之外的所有单个字符</td></tr><tr><td>(pattern)</td><td>匹配括号内的pattern</td></tr></tbody></table><ul><li>rewrite 最后一项flag参数</li></ul><table><thead><tr><th>标记符号</th><th>说明</th></tr></thead><tbody><tr><td>last</td><td>本条规则匹配完成后继续向下匹配新的location URI规则</td></tr><tr><td>break</td><td>本条规则匹配完成后终止，不在匹配任何规则</td></tr><tr><td>redirect</td><td>返回302临时重定向</td></tr><tr><td>permanent</td><td>返回301永久重定向</td></tr></tbody></table><ul><li>应用场景<ul><li>非法访问跳转，防盗链</li><li>网站更换新域名</li><li>http跳转https</li><li>不同地址访问同一个虚拟主机的资源</li></ul></li></ul><h5 id="实时通信-Nginx配置Websocket反向代理"><a href="#实时通信-Nginx配置Websocket反向代理" class="headerlink" title="实时通信-Nginx配置Websocket反向代理"></a>实时通信-Nginx配置Websocket反向代理</h5><ul><li><p>配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  listen    80;</span><br><span class="line">  server_name xdclass.net;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;lbs;</span><br><span class="line">   proxy_read_timeout 300s; &#x2F;&#x2F;websocket空闲保持时长</span><br><span class="line"></span><br><span class="line">   proxy_set_header Host $host;</span><br><span class="line">   proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">   proxy_http_version 1.1;</span><br><span class="line"></span><br><span class="line">   proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">   proxy_set_header Connection $connection_upgrade;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>核心是下面的配置 其他和普通反向代理没区别, 表示请求服务器升级协议为WebSocket</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection $connection_upgrade;</span><br></pre></td></tr></table></figure></li><li><p>服务器处理完请求后，响应如下报文# 状态码为101</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: upgrade</span><br></pre></td></tr></table></figure></li></ul><h4 id="Nginx业务接口性能优化"><a href="#Nginx业务接口性能优化" class="headerlink" title="Nginx业务接口性能优化"></a>Nginx业务接口性能优化</h4><h5 id="服务端缓存前置"><a href="#服务端缓存前置" class="headerlink" title="服务端缓存前置"></a>服务端缓存前置</h5><ul><li><p>常见的开发人员控制的缓存分类</p><ul><li>数据库缓存</li><li>应用程序缓存</li><li>Nginx网关缓存</li><li>前端缓存</li></ul></li><li><p>让后端结果缓存离用户更进一步</p><ul><li><p>/root/cache</p><ul><li>本地路径，用来设置Nginx缓存资源的存放地址 </li></ul></li><li><p>levels=1:2</p><ul><li>默认所有缓存文件都放在上面指定的根路径中，可能影响缓存的性能，推荐指定为 2 级目录来存储缓存文件；1和2表示用1位和2位16进制来命名目录名称。第一级目录用1位16进制命名，如a；第二级目录用2位16进制命名，如3a。所以此例中一级目录有16个，二级目录有16*16=256个,总目录数为16 * 256=4096个。</li><li>当levels=1:1:1时，表示是三级目录，且每级目录数均为16个</li></ul></li></ul></li></ul><ul><li><p>key_zone</p><ul><li>在共享内存中定义一块存储区域来存放缓存的 key 和 metadata</li></ul></li></ul><ul><li><p>max_size</p><ul><li>最大 缓存空间, 如果不指定会使用掉所有磁盘空间。当达到 disk 上限后，会删除最少使用的 cache</li></ul></li></ul><ul><li><p><strong>inactive</strong></p><ul><li>某个缓存在inactive指定的时间内如果不访问，将会从缓存中删除</li></ul></li></ul><ul><li><p><strong>proxy_cache_valid</strong></p><ul><li>配置nginx cache中的缓存文件的缓存时间,proxy_cache_valid 200 304 2m 对于状态为200和304的缓存文件的缓存时间是2分钟</li></ul></li></ul><ul><li><p><strong>use_temp_path</strong></p><ul><li>建议为 off，则 nginx 会将缓存文件直接写入指定的 cache 文件中</li></ul></li></ul><ul><li><p><strong>proxy_cache</strong></p><ul><li>启用proxy cache，并指定key_zone，如果proxy_cache off表示关闭掉缓存</li></ul></li></ul><ul><li><p><strong>add_header Nging-Cache “$upstream_cache_status”</strong></p><ul><li><p>用于前端判断是否是缓存，miss、hit、expired(缓存过期)、updating(更新，使用旧的应答)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_cache_path &#x2F;root&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;xd_cache:10m max_size&#x3D;1g inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">      location &#x2F;&#123;</span><br><span class="line">        ...     </span><br><span class="line">        proxy_cache xd_cache;</span><br><span class="line">        proxy_cache_valid 200 304 10m;</span><br><span class="line">        proxy_cache_valid 404 1m; </span><br><span class="line">        proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">        add_header Nginx-Cache &quot;$upstream_cache_status&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>还原nginx配置，只保留upstream模块</p></li><li><p>配置实操</p><ul><li>请求后端json接口，通过控制台日志判断是否有到后端服务</li></ul></li><li><p>注意：</p><ul><li>nginx缓存过期影响的优先级进行排序为：inactvie &gt; 源服务器端Expires/max-age &gt; proxy_cache_valid</li><li>如果出现 Permission denied 修改nginx.conf，将第一行修改为 user root</li><li>默认情况下GET请求及HEAD请求会被缓存，而POST请求不会被缓存，并非全部都要缓存，可以过滤部分路径不用缓存</li></ul></li><li><p>缓存清空</p><ul><li>直接rm删除</li><li>ngx_cache_purge</li></ul></li><li><p>缓存命中率统计</p><ul><li>前端打点日志上报</li><li>nginx日志模板增加信息<ul><li>$upstream_cache_status</li></ul></li></ul></li></ul><h5 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h5><ul><li><p>压缩配置</p><ul><li>对文本、js和css文件等进行压缩，一般是压缩后的大小是原始大小的25%</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开启gzip,减少我们发送的数据量</span><br><span class="line"></span><br><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line">  gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">#4个单位为16k的内存作为压缩结果流缓存</span><br><span class="line"></span><br><span class="line">  gzip_buffers 4 16k;</span><br><span class="line"></span><br><span class="line">#gzip压缩比，可在1~9中设置，1压缩比最小，速度最快，9压缩比最大，速度最慢，消耗CPU</span><br><span class="line"></span><br><span class="line">  gzip_comp_level 4;</span><br><span class="line"></span><br><span class="line">#压缩的类型</span><br><span class="line"></span><br><span class="line">  gzip_types application&#x2F;javascript text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;xml    text&#x2F;javascript; </span><br><span class="line"></span><br><span class="line">#给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩</span><br><span class="line"></span><br><span class="line">  gzip_vary on;</span><br><span class="line"></span><br><span class="line">#禁用IE6以下的gzip压缩，IE某些版本对gzip的压缩支持很不好</span><br><span class="line"></span><br><span class="line">  gzip_disable &quot;MSIE [1-6].&quot;; </span><br></pre></td></tr></table></figure></li></ul><ul><li>压缩前后区别（上传js文件进行验证）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  location &#x2F;static &#123;</span><br><span class="line">            alias &#x2F;usr&#x2F;local&#x2F;software&#x2F;static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>面试题：压缩是时间换空间，还是空间换时间？</p><ul><li>web层主要涉及浏览器和服务器的网络交互，而网络交互显然是耗费时间的</li><li>要尽量减少交互次数</li><li>降低每次请求或响应数据量。</li><li>开启压缩<ul><li>在服务端是时间换空间的策略，服务端需要牺牲时间进行压缩以减小响应数据大小</li><li>压缩后的内容可以获得更快的网络传输速度，时间是得到了优化</li><li>所以是双向的</li></ul></li></ul></li></ul><h4 id="Nginx和Https实战"><a href="#Nginx和Https实战" class="headerlink" title="Nginx和Https实战"></a>Nginx和Https实战</h4><h5 id="新一代传输协议Https"><a href="#新一代传输协议Https" class="headerlink" title="新一代传输协议Https"></a>新一代传输协议Https</h5><ul><li><p>什么是Https，和http的区别</p><ul><li>HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是身披SSL外壳的HTTP</li><li>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。</li></ul></li><li><p>为什么要用呢</p><ul><li>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性 </li></ul></li><li><p>流程</p><ul><li>秘钥交换使用非对称加密，内容传输使用对称加密的方式</li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/366784-20160127222221785-258650029.png" alt="img"></p></li></ul><h5 id="阿里云免费https证书申请和准备"><a href="#阿里云免费https证书申请和准备" class="headerlink" title="阿里云免费https证书申请和准备"></a>阿里云免费https证书申请和准备</h5><ul><li><p>证书申请-&gt;审核等待</p><ul><li><a href="https://common-buy.aliyun.com/?commodityCode=cas">https://common-buy.aliyun.com/?commodityCode=cas</a></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200820165637897.png" alt="image-20200820165637897"></p></li><li><p>证书上传</p></li></ul><h5 id="阿里云Nginx配置Https证书"><a href="#阿里云Nginx配置Https证书" class="headerlink" title="阿里云Nginx配置Https证书"></a>阿里云Nginx配置Https证书</h5><p><strong>简介: 阿里云 Nginx配置https证书配置实操</strong></p><ul><li>删除原先的nginx，新增ssl模块</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line">  make</span><br><span class="line">make install</span><br><span class="line">  #查看是否成功</span><br><span class="line">  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V</span><br></pre></td></tr></table></figure><ul><li><p>Nginx配置https证书</p><pre><code>server &#123;        listen       443 ssl;      server_name  16web.net;     ssl_certificate      /usr/local/software/biz/key/4383407_16web.net.pem;  ssl_certificate_key  /usr/local/software/biz/key/4383407_16web.net.key;  ssl_session_cache    shared:SSL:1m;  ssl_session_timeout  5m;  ssl_ciphers  HIGH:!aNULL:!MD5;  ssl_prefer_server_ciphers  on;    location / &#123;        root   html;      index  index.html index.htm;    &#125;&#125;</code></pre></li><li><p>https访问实操</p><ul><li>杀掉原先进程</li></ul></li><li><p>防火墙关闭或者开放443端口</p><ul><li>service firewalld stop </li><li>网络安全组开放端口</li></ul></li></ul><h4 id="Nginx整合OpenResty"><a href="#Nginx整合OpenResty" class="headerlink" title="Nginx整合OpenResty"></a>Nginx整合OpenResty</h4><h5 id="OpenResty-Lua介绍"><a href="#OpenResty-Lua介绍" class="headerlink" title="OpenResty+Lua介绍"></a>OpenResty+Lua介绍</h5><ul><li><p>什么是OpenResty, 为什么要用OpenResty？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由章亦春发起，是基于Ngnix和Lua的高性能web平台，内部集成精良的LUa库、第三方模块、依赖, 开发者可以方便搭建能够处理高并发、扩展性极高的动态web应用、web服务、动态网关。 </span><br><span class="line"></span><br><span class="line">OpenResty将Nginx核心、LuaJIT、许多有用的Lua库和Nginx第三方模块打包在一起</span><br><span class="line"></span><br><span class="line">  Nginx是C语言开发，如果要二次扩展是很麻烦的，而基于OpenResty，开发人员可以使用 Lua 编程语言对 Nginx 核心模块进行二次开发拓展</span><br><span class="line"></span><br><span class="line">性能强大，OpenResty可以快速构造出1万以上并发连接响应的超高性能Web应用系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>官网：<a href="http://openresty.org/">http://openresty.org</a></p></li><li><p>阿里、腾讯、新浪、酷狗音乐等都是 OpenResty 的深度用户   </p></li></ul><ul><li><p>拓展</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">让Web 服务直接跑在 Nginx 服务内部,充分利用 Nginx 的非阻塞 I&#x2F;O 模型,不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL, Memcaches 以及 Redis 等都进行一致的高性能响应。所以对于一些高性能的服务来说，可以直接使用 OpenResty 访问 Mysql或Redis等，而不需要通过第三方语言（PHP、Python、Ruby）等来访问数据库再返回，这大大提高了应用的性能 </span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Lua脚本介绍</p><ul><li><p>官网：<a href="http://www.lua.org/start.html">http://www.lua.org/start.html</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Lua 由标准 C 编写而成,没有提供强大的库,但可以很容易的被 C&#x2F;C++ 代码调用，也可以反过来调用 C&#x2F;C++ 的函数。 </span><br><span class="line"></span><br><span class="line">在应用程序中可以被广泛应用，不过Lua是一种脚本&#x2F;动态语言，不适合业务逻辑比较重的场景，适合小巧的应用场景，代码行数保持在几十行到几千行。</span><br><span class="line"></span><br><span class="line">  LuaJIT 是采用 C 和汇编语言编写的 Lua 解释器与即时编译器</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>什么是ngx_lua</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，部署到Nginx中运行，</span><br><span class="line"></span><br><span class="line">即Nginx变成了一个Web容器；开发人员就可以使用Lua语言开发高性能Web应用了。 </span><br></pre></td></tr></table></figure></li></ul><ul><li><p>OpenResty提供了常用的ngx_lua开发模块</p><ul><li>lua-resty-memcached</li><li>lua-resty-mysql</li><li>lua-resty-redis</li><li>lua-resty-dns</li><li>lua-resty-limit-traffic</li></ul><p>通过上述的模块，可以用来操作 mysql数据库、redis、memcached等，也可以自定义模块满足其他业务需求，<br>很多经典的应用，比如开发缓存前置、数据过滤、API请求聚合、AB测试、灰度发布、降级、监控、限流、防火墙、黑白名单等</p></li></ul><h5 id="OpenResty-Lua相关环境准备"><a href="#OpenResty-Lua相关环境准备" class="headerlink" title="OpenResty + Lua相关环境准备"></a>OpenResty + Lua相关环境准备</h5><ul><li><p>OpenResty安装</p><ul><li>下载：<a href="http://openresty.org/en/linux-packages.html#centos">http://openresty.org/en/linux-packages.html#centos</a></li></ul></li></ul><p>add the yum repo:</p><pre><code>wget https://openresty.org/package/centos/openresty.reposudo mv openresty.repo /etc/yum.repos.d/</code></pre><p>  update the yum index:</p><pre><code>sudo yum check-updatesudo yum install openresty#安装命令行工具sudo yum install openresty-resty</code></pre><p>  列出所有 openresty 仓库里的软件包</p><pre><code>sudo yum --disablerepo=&quot;*&quot; --enablerepo=&quot;openresty&quot; list available</code></pre><p>  #查看版本<br>    resty -V</p><ul><li><p>Nginx+OpenRestry开发</p><p><strong>编辑：/usr/local/openresty/nginx/conf/nginx.conf</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    # 虚拟机主机块</span><br><span class="line">    server&#123;</span><br><span class="line">        # 监听端口</span><br><span class="line">        listen 80;</span><br><span class="line">        # 配置请求的路由</span><br><span class="line">        location &#x2F;&#123;</span><br><span class="line">            default_type text&#x2F;html;</span><br><span class="line">            content_by_lua_block&#123;</span><br><span class="line">                ngx.say(&quot;hello world; xdclass.net 小滴课堂&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用其他方式</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  http&#123;</span><br><span class="line">      # 虚拟机主机块,还需要配置lua文件扫描路径</span><br><span class="line">      lua_package_path &quot;$prefix&#x2F;lualib&#x2F;?.lua;;&quot;;</span><br><span class="line">      lua_package_cpath &quot;$prefix&#x2F;lualib&#x2F;?.so;;&quot;;</span><br><span class="line">      server&#123;</span><br><span class="line">          # 监听端口</span><br><span class="line">          listen 80;</span><br><span class="line">          # 配置请求的路由</span><br><span class="line">          location &#x2F;&#123;</span><br><span class="line">              default_type text&#x2F;html;</span><br><span class="line">              content_by_lua_file lua&#x2F;xdclass.lua;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动Nginx（直接用openresty里面的nginx即可，默认安装了多个模块）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">访问 curl 127.0.0.1</span><br><span class="line">如果浏览器访问会出现文件下载，因为没有Html头信息</span><br><span class="line"></span><br><span class="line">注意：如果需要指定配置文件 nginx -c 配置文件路径</span><br><span class="line">比如  .&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf </span><br></pre></td></tr></table></figure></li></ul><h5 id="Nginx内置变量-和-OpenResty-请求阶段划分"><a href="#Nginx内置变量-和-OpenResty-请求阶段划分" class="headerlink" title="Nginx内置变量 和 OpenResty 请求阶段划分"></a>Nginx内置变量 和 OpenResty 请求阶段划分</h5><ul><li><p>nginx内置变量</p><ul><li>提供丰富的内置变量, openresty里面使用参考下面的文档</li><li><a href="https://github.com/openresty/lua-nginx-module#ngxvarvariable">https://github.com/openresty/lua-nginx-module#ngxvarvariable</a></li><li>部分变量是可以被修改的，部分是不给修改</li></ul><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>$arg_name</td><td>请求中的name参数</td></tr><tr><td>$args</td><td>请求中的参数</td></tr><tr><td>$content_length</td><td>HTTP请求信息里的”Content-Length”</td></tr><tr><td>$content_type</td><td>请求信息里的”Content-Type”</td></tr><tr><td>$host</td><td>请求信息中的”Host”，如果请求中没有Host行，则等于设置的服务器名</td></tr><tr><td>$hostname</td><td>机器名使用 gethostname系统调用的值</td></tr><tr><td>$http_cookie</td><td>cookie 信息</td></tr><tr><td>$http_referer</td><td>引用地址</td></tr><tr><td>$http_user_agent</td><td>客户端代理信息</td></tr><tr><td>$http_via</td><td>最后一个访问服务器的Ip地址。</td></tr><tr><td>$http_x_forwarded_for</td><td>相当于网络访问路径</td></tr><tr><td>$is_args</td><td>如果请求行带有参数，返回“?”，否则返回空字符串</td></tr><tr><td>$limit_rate</td><td>对连接速率的限制</td></tr><tr><td>$nginx_version</td><td>当前运行的nginx版本号</td></tr><tr><td>$pid</td><td>worker进程的PID</td></tr><tr><td>$query_string</td><td>与$args相同</td></tr><tr><td>$remote_addr</td><td>客户端IP地址</td></tr><tr><td>$remote_port</td><td>客户端端口号</td></tr><tr><td>$request</td><td>用户请求</td></tr><tr><td>$request_method</td><td>请求的方法，比如”GET”、”POST”等</td></tr><tr><td>$request_uri</td><td>请求的URI，带参数</td></tr><tr><td>$scheme</td><td>所用的协议，比如http或者是https</td></tr><tr><td>$server_name</td><td>请求到达的服务器名</td></tr><tr><td>$server_port</td><td>请求到达的服务器端口号</td></tr><tr><td>$server_protocol</td><td>请求的协议版本，”HTTP/1.0”或”HTTP/1.1”</td></tr><tr><td>$uri</td><td>请求的URI，可能和最初的值有不同，比如经过重定向之类的</td></tr></tbody></table></li></ul><ul><li>nginx对于请求的处理分多个阶段,Nginx , 从而让第三方模块通过挂载行为在不同的阶段来控制, 大致如下<ul><li>初始化阶段（Initialization Phase）<ul><li>init_by_lua_file</li><li>init_worker_by_lua_file</li></ul></li><li>重写与访问阶段（Rewrite / Access Phase）<ul><li>rewrite_by_lua_file</li><li>access_by_lua_file</li></ul></li><li>内容生成阶段（Content Phase）<ul><li>content_by_lua_file</li></ul></li><li>日志记录阶段（Log Phase）</li></ul></li></ul><h5 id="Nginx-OpenResty-Lua开发内网访问限制"><a href="#Nginx-OpenResty-Lua开发内网访问限制" class="headerlink" title="Nginx+OpenResty +Lua开发内网访问限制"></a>Nginx+OpenResty +Lua开发内网访问限制</h5><ul><li>生产环境-管理后台一般需要指定的网络才可以访问，网段/ip等</li><li>Nginx+OpenRestry+Lua开发</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line"># 这里设置为 off，是为了避免每次修改之后都要重新 reload 的麻烦。</span><br><span class="line"># 在生产环境上需要 lua_code_cache 设置成 on。</span><br><span class="line"></span><br><span class="line">lua_code_cache off;</span><br><span class="line"></span><br><span class="line"># lua_package_path可以配置openresty的文件寻址路径，$PREFIX 为openresty安装路径</span><br><span class="line"># 文件名使用“?”作为通配符，多个路径使用“;”分隔，默认的查找路径用“;;”</span><br><span class="line"># 设置纯 Lua 扩展库的搜寻路径</span><br><span class="line">lua_package_path &quot;$prefix&#x2F;lualib&#x2F;?.lua;;&quot;;</span><br><span class="line"></span><br><span class="line"># 设置 C 编写的 Lua 扩展模块的搜寻路径(也可以用 &#39;;;&#39;)</span><br><span class="line">lua_package_cpath &quot;$prefix&#x2F;lualib&#x2F;?.so;;&quot;;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">     access_by_lua_file lua&#x2F;white_ip_list.lua;</span><br><span class="line">     proxy_pass http:&#x2F;&#x2F;lbs;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>lua/white_ip_list.lua</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local black_ips &#x3D; &#123;[&quot;127.0.0.1&quot;]&#x3D;true&#125;</span><br><span class="line"></span><br><span class="line">local ip &#x3D; ngx.var.remote_addr</span><br><span class="line">if true &#x3D;&#x3D; black_ips[ip] then</span><br><span class="line">    ngx.exit(ngx.HTTP_FORBIDDEN)</span><br><span class="line">    return;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>拓展<ul><li>如何做一个动态黑名单控制?</li><li>里面 /usr/local/openresty/lualib/resty 很多第三方模块</li></ul></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200822210816997.png" alt="image-20200822210816997"></p><h5 id="Nginx-OpenResty实现资源下载限速"><a href="#Nginx-OpenResty实现资源下载限速" class="headerlink" title="Nginx+OpenResty实现资源下载限速"></a>Nginx+OpenResty实现资源下载限速</h5><ul><li><p>限速限流应用场景</p><ul><li>下载限速：保护带宽及服务器的IO资源</li><li>请求限流：防止恶意攻击，保护服务器及资源安全<ul><li>限制某个用户在一个给定时间段内能够产生的HTTP请求数</li><li>限流用在保护上游应用服务器不被在同一时刻的大量用户访问</li></ul></li></ul></li><li><p>openResty下载限速案例实操</p><ul><li>Nginx 有一个 <code>$limit_rate</code>，这个反映的是当前请求每秒能响应的字节数, 该字节数默认为配置文件中 <code>limit_rate</code> 指令的设值</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#当前请求的响应上限是 每秒 300K 字节</span><br><span class="line">location &#x2F;download &#123;</span><br><span class="line">  access_by_lua_block &#123;</span><br><span class="line">     ngx.var.limit_rate &#x3D; &quot;300K&quot;</span><br><span class="line">&#125;</span><br><span class="line"> alias &#x2F;usr&#x2F;local&#x2F;software&#x2F;app;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="网盘静态资源下载限速实现原理"><a href="#网盘静态资源下载限速实现原理" class="headerlink" title="网盘静态资源下载限速实现原理"></a>网盘静态资源下载限速实现原理</h4><ul><li>下载限速实现原理<ul><li>目的：限制下载速度</li><li>常用的是漏桶原理和令牌桶原理</li></ul></li></ul><ul><li>什么是漏桶算法<ul><li>备注：如果是请求限流，请求先进入到漏桶里，漏桶以固定的速度出水，也就是处理请求，当水加的过快也就是请求过多，桶就会直接溢出，也就是请求被丢弃拒绝了，所以漏桶算法能强行限制数据的传输速率或请求数</li></ul></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200823174825345.png" alt="image-20200823174825345"></p><ul><li><p>什么是令牌桶算法</p><ul><li><p>备注：只要突发并发量不高于桶里面存储的令牌数据，就可以充分利用好机器网络资源。</p><p>如果桶内令牌数量小于被消耗的量，则产生的令牌的速度就是均匀处理请求的速度</p></li></ul></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200823174904826.png" alt="image-20200823174904826"></p><h4 id="Ngnix高可用解决方案LVS-KeepAlived"><a href="#Ngnix高可用解决方案LVS-KeepAlived" class="headerlink" title="Ngnix高可用解决方案LVS+KeepAlived"></a>Ngnix高可用解决方案LVS+KeepAlived</h4><h5 id="高可用Nginx基础架构问题分析"><a href="#高可用Nginx基础架构问题分析" class="headerlink" title="高可用Nginx基础架构问题分析"></a>高可用Nginx基础架构问题分析</h5><ul><li>全链路高可用之Nginx反向代理单点故障分析<ul><li>dns轮训多个ip，假如某个nginx挂了，怎么办</li></ul></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200810102128969.png" alt="image-20200810102128969"></p><ul><li>Nginx集群架构（vip ）</li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200810110142700.png" alt="image-20200810110142700"></p><ul><li><p>Nginx高可用解决方案-基础</p><p>国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从低到高分别是：</span><br><span class="line"></span><br><span class="line">  物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</span><br><span class="line"></span><br><span class="line">四层工作在OSI第四层 也就是传输层</span><br><span class="line"></span><br><span class="line">  七层工作在最高层，也就是应用层</span><br></pre></td></tr></table></figure><ul><li>F5、LVS（四层负载 <strong>tcp</strong>）<ul><li>用虚拟ip+port接收请求,再转发到对应的真实机器</li></ul></li><li>HAproxy、Nginx(七层负载)</li><li>用虚拟的url或主机名接收请求,再转向相应的处理服务器</li></ul><h5 id="业界主流的高可用方案-Linux虚拟服务器-LVS"><a href="#业界主流的高可用方案-Linux虚拟服务器-LVS" class="headerlink" title="业界主流的高可用方案 Linux虚拟服务器 LVS"></a>业界主流的高可用方案 Linux虚拟服务器 LVS</h5><ul><li>什么是LVS<ul><li>官网 <a href="http://www.linuxvirtualserver.org/">www.linuxvirtualserver.org</a></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LVS是Linux Virtual Server,Linux虚拟服务器，是一个虚拟的服务器集群系统</span><br><span class="line"></span><br><span class="line">项目是由章文嵩博士成立，是中国国内最早出现的自由软件项目之一</span><br><span class="line"></span><br><span class="line">Linux2.4 内核以后，LVS 已经是 Linux 标准内核的一部分</span><br><span class="line"></span><br><span class="line">软件负载解决的两个核心问题是：选谁、转发</span><br></pre></td></tr></table></figure><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200824224413529.png" alt="image-20200824224413529"></p><ul><li>提供了10多种调度算法： 轮询、加权轮询、最小连接、目标地址散列、源地址散列等</li></ul><ul><li>三种负载均衡转发技术<ul><li>NAT：数据进出都通过 LVS, 前端的Master既要处理客户端发起的请求，又要处理后台RealServer的响应信息，将RealServer响应的信息再转发给客户端, 容易成为整个集群系统性能的瓶颈; (支持任意系统且可以实现端口映射)</li><li>DR: 移花接木,最高效的负载均衡规则,前端的Master只处理客户端的请求，将请求转发给RealServer，由后台的RealServer直接响应客户端，不再经过Master, 性能要优于LVS-NAT; 需要LVS和RS集群绑定同一个VIP（支持多数系统，不可以实现端口映射)</li><li>TUNL：隧道技术，前端的Master只处理客户端的请求，将请求转发给RealServer，然后由后台的RealServer直接响应客户端，不再经过Master；（支持少数系统，不可以实现端口映射)）</li></ul></li></ul><h5 id="高可用方案-keepalived讲解"><a href="#高可用方案-keepalived讲解" class="headerlink" title="高可用方案 keepalived讲解"></a>高可用方案 keepalived讲解</h5><ul><li>什么是<strong>keepalived</strong><ul><li>核心：监控并管理 LVS 集群系统中各个服务节点的状态</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keepalived是一个类似于交换机制的软件,核心作用是检测服务器的状态，如果有一台web服务器工作出现故障，Keepalived将检测到并将有故障的服务器从系统中剔除，使用其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成。</span><br><span class="line"></span><br><span class="line">后来加入了vrrp(虚拟路由器冗余协议)，除了为lvs提供高可用还可以为其他服务器比如Mysql、Haproxy等软件提供高可用方案</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y keepalived</span><br><span class="line">#路径</span><br><span class="line">cd &#x2F;etc&#x2F;keepalived</span><br></pre></td></tr></table></figure><ul><li>启动和查看命令</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动</span><br><span class="line">service keepalived start</span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">service keepalived stop</span><br><span class="line"></span><br><span class="line">#查看状态</span><br><span class="line">service keepalived status</span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line">service keepalived restart</span><br><span class="line"></span><br><span class="line">#停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><ul><li>注意: 如果有缺少依赖可以执行下面的命令</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y gcc</span><br><span class="line">yum install -y openssl-devel</span><br><span class="line">yum install -y libnl libnl-devel</span><br><span class="line">yum install -y libnfnetlink-devel</span><br><span class="line">yum install -y net-tools</span><br><span class="line">yum install -y vim wget</span><br></pre></td></tr></table></figure><h5 id="Keepalived核心配置讲解"><a href="#Keepalived核心配置讲解" class="headerlink" title="Keepalived核心配置讲解"></a>Keepalived核心配置讲解</h5><ul><li>配置/etc/keepalived/keepalived.conf</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line"></span><br><span class="line">   router_id LVS_DEVEL # 设置lvs的id，在一个网络内应该是唯一的</span><br><span class="line">   enable_script_security #允许执行外部脚本</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置vrrp_script，主要用于健康检查及检查失败后执行的动作。</span><br><span class="line">vrrp_script chk_real_server &#123;</span><br><span class="line">#健康检查脚本，当脚本返回值不为0时认为失败</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;software&#x2F;conf&#x2F;chk_server.sh&quot;</span><br><span class="line">#检查频率，以下配置每2秒检查1次</span><br><span class="line">    interval 2</span><br><span class="line">#当检查失败后，将vrrp_instance的priority减小5</span><br><span class="line">    weight -5</span><br><span class="line">#连续监测失败3次，才认为真的健康检查失败。并调整优先级</span><br><span class="line">    fall 3</span><br><span class="line">#连续监测2次成功，就认为成功。但不调整优先级</span><br><span class="line">    rise 2</span><br><span class="line"></span><br><span class="line">user root</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#配置对外提供服务的VIP vrrp_instance配置</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line"></span><br><span class="line">#指定vrrp_instance的状态，是MASTER还是BACKUP主要还是看优先级。</span><br><span class="line">    state MASTER</span><br><span class="line"></span><br><span class="line">#指定vrrp_instance绑定的网卡，最终通过指定的网卡绑定VIP</span><br><span class="line">    interface ens33</span><br><span class="line"></span><br><span class="line">#相当于VRID，用于在一个网内区分组播，需要组播域内内唯一。</span><br><span class="line">    virtual_router_id 51</span><br><span class="line"></span><br><span class="line">#本机的优先级，VRID相同的机器中，优先级最高的会被选举为MASTER</span><br><span class="line">    priority 100</span><br><span class="line"></span><br><span class="line">#心跳间隔检查，默认为1s，MASTER会每隔1秒发送一个报文告知组内其他机器自己还活着。</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 1111</span><br><span class="line">&#125;\#定义虚拟IP(VIP)为192.168.159.100，可多设，每行一个</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.159.100</span><br><span class="line">    &#125;</span><br><span class="line">    #本vrrp_instance所引用的脚本配置，名称就是vrrp_script 定义的容器名</span><br><span class="line">    # 设置负载调度的算法为rr</span><br><span class="line">  track_script &#123;</span><br><span class="line">      chk_real_server</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义对外提供服务的LVS的VIP以及port</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.159.100 80 &#123;</span><br><span class="line">    # 设置健康检查时间，单位是秒</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr</span><br><span class="line"></span><br><span class="line"># 设置LVS实现负载的机制，有NAT、TUN、DR三个模式</span><br><span class="line">lb_kind NAT</span><br><span class="line"></span><br><span class="line"># 会话保持时间</span><br><span class="line">persistence_timeout 50</span><br><span class="line">   #指定转发协议类型(TCP、UDP)</span><br><span class="line">    protocol TCP</span><br><span class="line">    # 指定real server1的IP地址</span><br><span class="line"></span><br><span class="line">real_server 192.168.159.146 80 &#123;</span><br><span class="line">    # 配置节点权值，数字越大权重越高</span><br><span class="line">    weight 1</span><br><span class="line"></span><br><span class="line">    # 健康检查方式</span><br><span class="line">    TCP_CHECK &#123;                  # 健康检查方式</span><br><span class="line">        connect_timeout 10       # 连接超时</span><br><span class="line">        retry 3           # 重试次数</span><br><span class="line">        delay_before_retry 3     # 重试间隔</span><br><span class="line">        connect_port 80          # 检查时连接的端口</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200824224413529.png" alt="image-20200824224413529"></p><ul><li><p>配置注意</p><p>router_id后面跟的自定义的ID在同一个网络下是一致的</p></li></ul><p>state后跟的MASTER和BACKUP必须是大写；否则会造成配置无法生效的问题</p><p>  interface 网卡ID；要根据自己的实际情况来看，可以使用以下方式查询 ip a  查询</p><p>在BACKUP节点上，其keepalived.conf与Master上基本一致，修改state为BACKUP，priority值改小即可</p><p>  authentication主备之间的认证方式，一般使用PASS即可；主备的配置必须一致，不能超过8位</p><h5 id="Nginx高可用方案相关环境准备"><a href="#Nginx高可用方案相关环境准备" class="headerlink" title="Nginx高可用方案相关环境准备"></a>Nginx高可用方案相关环境准备</h5><ul><li>配置Nginx, 修改网页</li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200824224413529.png" alt="image-20200824224413529"></p><ul><li>启动keepalived</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动</span><br><span class="line">service keepalived start</span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">service keepalived stop</span><br><span class="line"></span><br><span class="line">#查看状态</span><br><span class="line">service keepalived status</span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line">service keepalived restart</span><br><span class="line"></span><br><span class="line">#停止防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h5 id="Nginx-LVS-KeepAlived方案实施"><a href="#Nginx-LVS-KeepAlived方案实施" class="headerlink" title="Nginx+LVS+KeepAlived方案实施"></a>Nginx+LVS+KeepAlived方案实施</h5><ul><li>根据需求配置多个节点</li><li>演示<ul><li>如果其中keepalived挂了，那就会vip就会分发到另外一个keepalived节点，响应正常</li><li>如果某个realServer挂了，比如是Nginx挂了，那对应keepalived节点存活依旧可以转发过去，但是响应失败</li></ul></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200824224413529.png" alt="image-20200824224413529"></p><ul><li>解决问题<ul><li>如果某个realServer挂了，比如是Nginx挂了，那对应keepalived节点存活依旧可以转发过去，但是响应失败</li></ul></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/image-20200824224540783.png" alt="image-20200824224540783"></p><ul><li>脚本监听</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置vrrp_script，主要用于健康检查及检查失败后执行的动作。</span><br><span class="line">vrrp_script chk_real_server &#123;</span><br><span class="line">#健康检查脚本，当脚本返回值不为0时认为失败</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;software&#x2F;conf&#x2F;chk_server.sh&quot;</span><br><span class="line">#检查频率，以下配置每2秒检查1次</span><br><span class="line">    interval 2</span><br><span class="line">#当检查失败后，将vrrp_instance的priority减小5</span><br><span class="line">    weight -5</span><br><span class="line">#连续监测失败3次，才认为真的健康检查失败。并调整优先级</span><br><span class="line">    fall 3</span><br><span class="line">#连续监测2次成功，就认为成功。但不调整优先级</span><br><span class="line">    rise 2</span><br><span class="line">    user root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>chk_server.sh脚本内容（需要 chmod +x chk_server.sh）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#检查nginx进程是否存在</span><br><span class="line">counter&#x3D;$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">if [ &quot;$&#123;counter&#125;&quot; -eq &quot;0&quot; ]; then</span><br><span class="line">    service keepalived stop</span><br><span class="line">    echo &#39;nginx server is died.......&#39;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>常见问题</li></ul><p>vip能ping通，vip监听的端口不通: 第一个原因:nginx1和nginx2两台服务器的服务没有正常启动</p><p>vip ping不通: 核对是否出现裂脑,常见原因为防火墙配置所致导致多播心跳失败,核对keepalived的配置是否正确</p><ul><li><p>特别注意： 需要关闭selinux，不然sh脚本可能不生效</p><ul><li>getenforce 查看</li><li>setenforce 0 关闭</li></ul></li><li><p>生产环境问题</p><ul><li>VIP : 阿里云(LBS)、华为云、腾讯云、AWS</li></ul></li></ul><h4 id="Nginx基础架构master-worker进程剖析"><a href="#Nginx基础架构master-worker进程剖析" class="headerlink" title="Nginx基础架构master-worker进程剖析"></a>Nginx基础架构master-worker进程剖析</h4><ul><li>master 进程负责管理 Nginx 本身和其他 worker 进程</li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/Fu7XncMxTzx8V4KaCaOZuNqUAplm.png" alt="img"></p><ul><li>高性能原理<ul><li>nginx 通过 多进程 + io多路复用（epoll） 实现了高并发</li><li>采用多个worker 进程实现对 多cpu 的利用 通过eopll 对 多个文件描述符 事件回调机制</li></ul></li></ul><p><img src="https://file.xdclass.net/note/2020/nginx/%E5%9B%BE%E7%89%87/ABUIABAEGAAg_sKrwAUojMPt1gIwgAU4mgM.png" alt="img"></p><ul><li>拓展：linux I/O多路复用有select，poll，epoll</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;O模式一般分为同步IO和异步IO。</span><br><span class="line"></span><br><span class="line">同步IO会阻塞进程，异步IO不会阻塞进程。</span><br><span class="line"></span><br><span class="line">目前linux上大部分用的是同步IO，异步IO在linux上还不太成熟(有部分)</span><br><span class="line"></span><br><span class="line">同步IO又分为阻塞IO，非阻塞IO，IO多路复用, 很多人对这个就有疑问了？？？？</span><br><span class="line"></span><br><span class="line">同步IO会阻塞进程，为什么也包括非阻塞IO？ 因为非阻塞IO虽然在请求数据时不阻塞，但真正数据来临时，也就是内核数据拷贝到用户数据时，此时进程是阻塞的。</span><br><span class="line"></span><br><span class="line">推荐书籍《Unix网络编程》</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro权限框架</title>
      <link href="2020/11/06/shiro%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/"/>
      <url>2020/11/06/shiro%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ul><li>什么是权限控制：<ul><li>忽略特别细的概念，比如权限能细分很多种，功能权限，数据权限，管理权限等</li><li>理解两个概念：用户和资源，让指定的用户，只能操作指定的资源（CRUD）</li></ul></li><li>初学javaweb时怎么做<ul><li>Filter接口中有一个doFilter方法，自己编写好业务Filter，并配置对哪个web资源进行拦截后</li><li>如果访问的路径命中对应的Filter，则会执行doFilter()方法，然后判断是否有权限进行访问对应的资源</li><li>/api/user/info?id=1</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        HttpServletRequest httpRequest&#x3D;(HttpServletRequest)request;</span><br><span class="line">        HttpServletResponse httpResponse&#x3D;(HttpServletResponse)response;</span><br><span class="line">        </span><br><span class="line">        HttpSession session&#x3D;httpRequest.getSession();</span><br><span class="line">        </span><br><span class="line">        if(session.getAttribute(&quot;username&quot;)!&#x3D;null)&#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            httpResponse.sendRedirect(httpRequest.getContextPath()+&quot;&#x2F;login.jsp&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ACL和RBCL</strong></p><ul><li><p>ACL: Access Control List 访问控制列表</p><ul><li>以前盛行的一种权限设计，它的核心在于用户直接和权限挂钩</li><li>优点：简单易用，开发便捷</li><li>缺点：用户和权限直接挂钩，导致在授予时的复杂性，比较分散，不便于管理</li><li>例子：常见的文件系统权限设计, 直接给用户加权限</li></ul></li><li><p>RBAC: Role Based Access Control </p><ul><li>基于角色的访问控制系统。权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限</li><li>优点：简化了用户与权限的管理，通过对用户进行分类，使得角色与权限关联起来</li><li>缺点：开发对比ACL相对复杂</li><li>例子：基于RBAC模型的权限验证框架与应用 Apache Shiro、spring Security</li></ul></li><li><p>BAT企业 ACL，一般是对报表系统，阿里的ODPS</p></li></ul><ul><li>总结：不能过于复杂，规则过多，维护性和性能会下降， 更多分类 ABAC、PBAC等</li></ul><h4 id="主流权限框架"><a href="#主流权限框架" class="headerlink" title="主流权限框架"></a>主流权限框架</h4><h5 id="pring-Security"><a href="#pring-Security" class="headerlink" title="pring Security"></a>pring Security</h5><ul><li>官网：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</span><br><span class="line"></span><br><span class="line">一句话：Spring Security 的前身是 Acegi Security ，是 Spring 项目组中用来提供安全认证服务的框架</span><br></pre></td></tr></table></figure><h5 id="Apache-Shiro"><a href="#Apache-Shiro" class="headerlink" title="Apache Shiro"></a>Apache Shiro</h5><ul><li><p><a href="https://github.com/apache/shiro">https://github.com/apache/shiro</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。</span><br><span class="line"></span><br><span class="line">一句话：Shiro是一个强大易用的Java安全框架,提供了认证、授权、加密和会话管理等功能</span><br></pre></td></tr></table></figure></li></ul><p>两个优缺点，应该怎么选择</p><ul><li><p>Apache Shiro比Spring Security , 前者使用更简单</p></li><li><p>Shiro 功能强大、 简单、灵活， 不跟任何的框架或者容器绑定，可以独立运行</p></li><li><p>Spring Security 对Spring 体系支持比较好，脱离Spring体系则很难开发</p></li><li><p>SpringSecutiry 支持Oauth鉴权 <a href="https://spring.io/projects/spring-security-oauth">https://spring.io/projects/spring-security-oauth</a>，Shiro需要自己实现</p></li><li><p>……</p><p><strong>总结：两个框架没有谁超过谁，大体功能一致，新手一般先推荐Shiro，学习会容易点</strong></p></li></ul><h4 id="Shiro基础概念知识和架构"><a href="#Shiro基础概念知识和架构" class="headerlink" title="Shiro基础概念知识和架构"></a>Shiro基础概念知识和架构</h4><h5 id="Shiro核心知识之架构图交互和四大模块"><a href="#Shiro核心知识之架构图交互和四大模块" class="headerlink" title="Shiro核心知识之架构图交互和四大模块"></a>Shiro核心知识之架构图交互和四大模块</h5><ul><li>直达Apache Shiro官网 <a href="http://shiro.apache.org/introduction.html">http://shiro.apache.org/introduction.html</a></li><li>身份认证<ul><li>Authentication，身份证认证，一般就是登录</li></ul></li><li>授权<ul><li>Authorization，给用户分配角色或者访问某些资源的权限</li></ul></li><li>会话管理<ul><li>Session Management, 用户的会话管理员，多数情况下是web session</li></ul></li><li>加密<ul><li>Cryptography, 数据加解密，比如密码加解密等</li></ul></li></ul><p><img src="/2020/11/06/shiro%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/ShiroFeatures.png" alt="img"></p><h5 id="Shrio权限控制运行流程"><a href="#Shrio权限控制运行流程" class="headerlink" title="Shrio权限控制运行流程"></a>Shrio权限控制运行流程</h5><ul><li><p>直达官网 ：<a href="http://shiro.apache.org/architecture.html">http://shiro.apache.org/architecture.html</a></p></li><li><p>Subject</p><ul><li>我们把用户或者程序称为主体（如用户，第三方服务，cron作业），主体去访问系统或者资源</li></ul></li><li><p>SecurityManager</p><ul><li>安全管理器，Subject的认证和授权都要在安全管理器下进行</li></ul></li><li><p>Authenticator</p><ul><li>认证器，主要负责Subject的认证</li></ul></li><li><p>Realm</p><ul><li>数据域，Shiro和安全数据的连接器，好比jdbc连接数据库； 通过realm获取认证授权相关信息</li></ul></li><li><p>Authorizer</p><ul><li>授权器，主要负责Subject的授权, 控制subject拥有的角色或者权限</li></ul></li><li><p>Cryptography</p><ul><li>加解密，Shiro的包含易于使用和理解的数据加解密方法，简化了很多复杂的api</li></ul></li><li><p>Cache Manager</p><ul><li>缓存管理器，比如认证或授权信息，通过缓存进行管理，提高性能</li></ul></li></ul><p><img src="/2020/11/06/shiro%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/ShiroArchitecture.png" alt="img"></p><h4 id="springboot整合shiro快速上手"><a href="#springboot整合shiro快速上手" class="headerlink" title="springboot整合shiro快速上手"></a>springboot整合shiro快速上手</h4><h5 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h5><ul><li><p>创建SpringBoot项目</p><p><a href="https://start.spring.io/">https://start.spring.io/</a></p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>整合Shiro相关jar包</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h5><ul><li>常见API</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;是否有对应的角色</span><br><span class="line">subject.hasRole(&quot;root&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取subject名</span><br><span class="line">subject.getPrincipal()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查是否有对应的角色，无返回值，直接在SecurityManager里面进行判断</span><br><span class="line">subject.checkRole(&quot;admin&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查是否有对应的角色</span><br><span class="line">subject.hasRole(&quot;admin&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;退出登录</span><br><span class="line">subject.logout();</span><br></pre></td></tr></table></figure><ul><li>//TODO</li></ul><h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞"></a>起飞</h3><h4 id="Shiro安全数据来源Realm"><a href="#Shiro安全数据来源Realm" class="headerlink" title="Shiro安全数据来源Realm"></a>Shiro安全数据来源Realm</h4><h5 id="shiro默认自带的realm和常见使用方法"><a href="#shiro默认自带的realm和常见使用方法" class="headerlink" title="shiro默认自带的realm和常见使用方法"></a>shiro默认自带的realm和常见使用方法</h5><ul><li><p>realm作用：Shiro 从 Realm 获取安全数据</p></li><li><p>默认自带的realm：idae查看realm继承关系，有默认实现和自定义继承的realm</p></li><li><p>两个概念</p><ul><li>principal : 主体的标示，可以有多个，但是需要具有唯一性，常见的有用户名，手机号，邮箱等</li><li>credential：凭证,  一般就是密码</li><li>所以一般我们说 principal + credential   就账号 + 密码</li></ul></li><li><p>开发中，往往是自定义realm , 即集成 AuthorizingRealm</p></li></ul><p><strong>快速上手Shiro内置IniRealm和权限验证api</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 格式 name&#x3D;password,role1,role2,..roleN</span><br><span class="line">[users]</span><br><span class="line"># user &#39;root&#39; with password &#39;secret&#39; and the &#39;admin&#39; role，</span><br><span class="line">jack &#x3D; 456, user</span><br><span class="line"></span><br><span class="line"># user &#39;guest&#39; with the password &#39;guest&#39; and the &#39;guest&#39; role</span><br><span class="line">xdcalss &#x3D; 123, root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 格式 role&#x3D;permission1,permission2...permissionN   也可以用通配符</span><br><span class="line"># 下面配置user的权限为所有video:find,video:buy，如果需要配置video全部操作crud 则 user &#x3D; video:*</span><br><span class="line">[roles]</span><br><span class="line">user &#x3D; video:find,video:buy</span><br><span class="line"># &#39;admin&#39; role has all permissions, indicated by the wildcard &#39;*&#39;</span><br><span class="line">admin &#x3D; *</span><br></pre></td></tr></table></figure><ul><li>//TODO</li></ul><p><strong>快速上手Shiro内置JdbcRealm</strong></p><ul><li>使用jdbcrealm.ini</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#注意 文件格式必须为ini，编码为ANSI</span><br><span class="line"></span><br><span class="line">#声明Realm，指定realm类型</span><br><span class="line">jdbcRealm&#x3D;org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line"></span><br><span class="line">#配置数据源</span><br><span class="line">#dataSource&#x3D;com.mchange.v2.c3p0.ComboPooledDataSource</span><br><span class="line"></span><br><span class="line">dataSource&#x3D;com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line"># mysql-connector-java 5 用的驱动url是com.mysql.jdbc.Driver，mysql-connector-java6以后用的是com.mysql.cj.jdbc.Driver</span><br><span class="line">dataSource.driverClassName&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">#避免安全警告</span><br><span class="line">dataSource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;120.76.62.13:3606&#x2F;xdclass_shiro?characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;UTC&amp;useSSL&#x3D;false</span><br><span class="line"></span><br><span class="line">dataSource.username&#x3D;test</span><br><span class="line"></span><br><span class="line">dataSource.password&#x3D;Xdclasstest</span><br><span class="line"></span><br><span class="line">#指定数据源</span><br><span class="line">jdbcRealm.dataSource&#x3D;$dataSource</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#开启查找权限, 默认是false，不会去查找角色对应的权限，坑！！！！！</span><br><span class="line">jdbcRealm.permissionsLookupEnabled&#x3D;true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定SecurityManager的Realms实现，设置realms，可以有多个，用逗号隔开</span><br><span class="line">securityManager.realms&#x3D;$jdbcRealm</span><br></pre></td></tr></table></figure><ul><li><p>方式二</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultSecurityManager securityManager &#x3D; new DefaultSecurityManager();</span><br><span class="line">  </span><br><span class="line">       DruidDataSource ds &#x3D; new DruidDataSource();</span><br><span class="line">       ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;120.76.62.13:3606&#x2F;xdclass_shiro?characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;UTC&amp;useSSL&#x3D;false&quot;);</span><br><span class="line">       ds.setUsername(&quot;test&quot;);</span><br><span class="line">       ds.setPassword(&quot;Xdclasstest&quot;);</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h5 id="Apache-Shiro-自定义Realm实战"><a href="#Apache-Shiro-自定义Realm实战" class="headerlink" title="Apache Shiro 自定义Realm实战"></a>Apache Shiro 自定义Realm实战</h5><p><strong>上手</strong></p><ul><li><p>步骤：</p><ul><li>创建一个类 ，继承AuthorizingRealm-&gt;AuthenticatingRealm-&gt;CachingRealm-&gt;Realm</li><li>重写授权方法 doGetAuthorizationInfo</li><li>重写认证方法 doGetAuthenticationInfo </li></ul></li><li><p>方法：</p><ul><li>当用户登陆的时候会调用 doGetAuthenticationInfo</li><li>进行权限校验的时候会调用: doGetAuthorizationInfo</li></ul></li><li><p>对象介绍</p><ul><li><p>UsernamePasswordToken ： 对应就是 shiro的token中有Principal和Credential</p><ul><li><pre><code>UsernamePasswordToken-》HostAuthenticationToken-》AuthenticationToken<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  *  SimpleAuthorizationInfo：代表用户角色权限信息</span><br><span class="line"></span><br><span class="line">  * SimpleAuthenticationInfo ：代表该用户的认证信息</span><br><span class="line"></span><br><span class="line">* &#x2F;&#x2F;TODO</span><br><span class="line"></span><br><span class="line">**Shiro源码解读认证授权流程**</span><br><span class="line"></span><br></pre></td></tr></table></figure>认证流程解读：subject.login(usernamePasswordToken);DelegatingSubject-&gt;login()DefaultSecurityManager-&gt;login()AuthenticatingSecurityManager-&gt;authenticate()AbstractAuthenticator-&gt;authenticate()ModularRealmAuthenticator-&gt;doAuthenticate()ModularRealmAuthenticator-&gt;doSingleRealmAuthentication()AuthenticatingRealm-&gt;getAuthenticationInfo()</code></pre></li></ul><p>补充：有些同学找不到密码验证方法 AuthenticatingRealm-&gt; assertCredentialsMatch()</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>授权流程解读：subject.checkRole(“admin”)</p><p>DelegatingSubject-&gt;checkRole()<br>AuthorizingSecurityManager-&gt;checkRole()<br>ModularRealmAuthorizer-&gt;checkRole()<br>AuthorizingRealm-&gt;hasRole()<br>AuthorizingRealm-&gt;doGetAuthorizationInfo()</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">####  Filter过滤器</span><br><span class="line"></span><br><span class="line">#####  Shiro内置的Filter过滤器</span><br><span class="line"></span><br><span class="line">* 核心过滤器类：DefaultFilter,  配置哪个路径对应哪个拦截器进行处理</span><br><span class="line"></span><br><span class="line">* authc：org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span><br><span class="line">  </span><br><span class="line">  * 需要认证登录才能访问</span><br><span class="line">* user：org.apache.shiro.web.filter.authc.UserFilter</span><br><span class="line">  </span><br><span class="line">  - 用户拦截器，表示必须存在用户。</span><br><span class="line">* anon：org.apache.shiro.web.filter.authc.AnonymousFilter</span><br><span class="line">  </span><br><span class="line">  - 匿名拦截器，不需要登录即可访问的资源，匿名用户或游客，一般用于过滤静态资源。</span><br><span class="line">* roles：org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</span><br><span class="line">  - 角色授权拦截器，验证用户是或否拥有角色。</span><br><span class="line">  - 参数可写多个，表示某些角色才能通过，多个参数时写 roles[&quot;admin,user&quot;]，当有多个参数时必须每个参数都通过才算通过</span><br><span class="line">* perms：org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</span><br><span class="line">  - 权限授权拦截器，验证用户是否拥有权限</span><br><span class="line">  - 参数可写多个，表示需要某些权限才能通过，多个参数时写 perms[&quot;user, admin&quot;]，当有多个参数时必须每个参数都通过才算可以</span><br><span class="line"></span><br><span class="line">* authcBasic：org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</span><br><span class="line"></span><br><span class="line">  * httpBasic 身份验证拦截器。</span><br><span class="line"></span><br><span class="line">* logout：org.apache.shiro.web.filter.authc.LogoutFilter</span><br><span class="line"></span><br><span class="line">  * 退出拦截器，执行后会直接跳转到&#96;shiroFilterFactoryBean.setLoginUrl();&#96; 设置的 url</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* port：org.apache.shiro.web.filter.authz.PortFilter</span><br><span class="line"></span><br><span class="line">  * 端口拦截器, 可通过的端口。</span><br><span class="line"></span><br><span class="line">* ssl：org.apache.shiro.web.filter.authz.SslFilter</span><br><span class="line"></span><br><span class="line">  * ssl拦截器，只有请求协议是https才能通过。</span><br><span class="line"></span><br><span class="line">##### Shiro的Filter配置路径讲解</span><br><span class="line"></span><br><span class="line">* &#x2F;admin&#x2F;video     &#x2F;user    &#x2F;pub</span><br><span class="line"></span><br><span class="line">* 路径通配符支持 ?、*、**，注意通配符匹配不 包括目录分隔符“&#x2F;”</span><br><span class="line"></span><br><span class="line">* 心 可以匹配所有，不加*可以进行前缀匹配，但多个冒号就需要多个 * 来匹配</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>URL权限采取第一次匹配优先的方式<br>? : 匹配一个字符，如 /user? , 匹配 /user3，但不匹配/user/;</p></li></ul></li><li><p>: 匹配零个或多个字符串，如 /add* ,匹配 /addtest，但不匹配 /user/1</p></li><li><ul><li>: 匹配路径中的零个或多个路径，如 /user/** 将匹 配 /user/xxx 或 /user/xxx/yyy</li></ul></li></ul><p>例子<br>/user/**=filter1<br>/user/add=filter2</p><p>请求 /user/add  命中的是filter1拦截器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 性能问题：通配符比字符串匹配会复杂点，所以性能也会稍弱，推荐是使用字符串匹配方式</span><br><span class="line"></span><br><span class="line">####  Shiro 数据安全之数据加解密</span><br><span class="line"></span><br><span class="line">- 为啥要加解密</span><br><span class="line"></span><br><span class="line">  - 明文数据容易泄露，比如密码明文存储，万一泄露则会造成严重后果   </span><br><span class="line">- 什么是散列算法</span><br><span class="line"></span><br><span class="line">  - 一般叫hash，简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，适合存储密码，比如MD5</span><br><span class="line">- 什么是salt(盐)   667788——》aabbcc</span><br><span class="line"></span><br><span class="line">  - 如果直接通过散列函数得到加密数据，容易被对应解密网站暴力破解，一般会在应用程序里面加特殊的自动进行处理，比如用户id，例子：加密数据 &#x3D; MD5(明文密码+用户id),  破解难度会更大，也可以使用多重散列，比如多次md5</span><br><span class="line"></span><br><span class="line">- Shiro里面 CredentialsMatcher，用来验证密码是否正确，</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">    源码：AuthenticatingRealm -&gt; assertCredentialsMatch()</span><br></pre></td></tr></table></figure><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般会自定义验证规则</span><br><span class="line">@Bean</span><br><span class="line">    public HashedCredentialsMatcher hashedCredentialsMatcher()&#123;</span><br><span class="line">        HashedCredentialsMatcher hashedCredentialsMatcher &#x3D; new HashedCredentialsMatcher();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;散列算法，使用MD5算法;</span><br><span class="line">        hashedCredentialsMatcher.setHashAlgorithmName(&quot;md5&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;散列的次数，比如散列两次，相当于 md5(md5(&quot;xxx&quot;));</span><br><span class="line">        hashedCredentialsMatcher.setHashIterations(2);</span><br><span class="line">        </span><br><span class="line">        return hashedCredentialsMatcher;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="Shiro权限控制注解和编程方式讲解"><a href="#Shiro权限控制注解和编程方式讲解" class="headerlink" title="Shiro权限控制注解和编程方式讲解"></a>Shiro权限控制注解和编程方式讲解</h4><p><strong>配置文件的方式</strong></p><p>​    使用ShiroConfig</p><p><strong>注解方式</strong></p><ul><li>@RequiresRoles(value={“admin”, “editor”}, logical= Logical.AND) <ul><li>需要角色 admin 和 editor两个角色 AND表示两个同时成立</li></ul></li><li>@RequiresPermissions (value={“user:add”, “user:del”}, logical= Logical.OR)<ul><li>需要权限 user:add 或 user:del权限其中一个，OR是或的意思。</li></ul></li></ul><ul><li>@RequiresAuthentication<ul><li>已经授过权，调用Subject.isAuthenticated()返回true</li></ul></li><li>@RequiresUser<ul><li>身份验证或者通过记 住我登录的</li></ul></li></ul><p><strong>编程方式</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subject subject &#x3D; SecurityUtils.getSubject(); </span><br><span class="line">&#x2F;&#x2F;基于角色判断</span><br><span class="line">if(subject.hasRole(“admin”)) &#123;</span><br><span class="line">&#x2F;&#x2F;有角色，有权限</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;无角色，无权限</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;或者权限判断</span><br><span class="line">if(subject.isPermitted(&quot;&#x2F;user&#x2F;add&quot;))&#123;</span><br><span class="line">    &#x2F;&#x2F;有权限</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F;无权限</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>常见API <ul><li>subject.hasRole(“xxx”);</li><li>subject.isPermitted(“xxx”);</li><li>subject. isPermittedAll(“xxxxx”,”yyyy”);</li><li>subject.checkRole(“xxx”);  // 无返回值，可以认为内部使用断言的方式</li></ul></li></ul><h4 id="Shiro-缓存模块"><a href="#Shiro-缓存模块" class="headerlink" title="Shiro 缓存模块"></a>Shiro 缓存模块</h4><ul><li><p>什么是shiro缓存</p><ul><li>shiro中提供了对认证信息和授权信息的缓存。<ul><li>默认是关闭认证信息缓存的，对于授权信息的缓存shiro默认开启的(因为授权的数据量大)</li></ul></li></ul></li><li><p>AuthenticatingRealm 及 AuthorizingRealm 分别提供了对AuthenticationInfo 和 AuthorizationInfo 信息的缓存。</p></li></ul><h4 id="Shiro-Session模块"><a href="#Shiro-Session模块" class="headerlink" title="Shiro Session模块"></a>Shiro Session模块</h4><ul><li><p>什么是会话session</p><ul><li>用户和程序直接的链接，程序可以根据session识别到哪个用户，和javaweb中的session类似</li></ul></li><li><p>什么是会话管理器SessionManager</p><ul><li><p>会话管理器管理所有subject的所有操作，是shiro的核心组件</p></li><li><p>核心方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;开启一个session</span><br><span class="line">Session start(SessionContext context);</span><br><span class="line">&#x2F;&#x2F;指定Key获取session</span><br><span class="line">Session getSession(SessionKey key)</span><br></pre></td></tr></table></figure></li><li><p>shiro中的会话管理器有多个实现</p></li></ul></li><li><p>SessionDao 会话存储/持久化</p><ul><li><p>SessionDAO</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  AbstractSessionDAO</span><br><span class="line">   CachingSessionDAO</span><br><span class="line">EnterpriseCacheSessionDAO</span><br><span class="line">  MemorySessionDAO</span><br></pre></td></tr></table></figure></li><li><p>核心方法</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;创建</span><br><span class="line">   Serializable create(Session session);</span><br><span class="line">&#x2F;&#x2F;获取</span><br><span class="line">  Session readSession(Serializable sessionId) throws UnknownSessionException;</span><br><span class="line">  &#x2F;&#x2F;更新</span><br><span class="line">  void update(Session session) </span><br><span class="line">  &#x2F;&#x2F;删除，会话过期时会调用</span><br><span class="line">  void delete(Session session);</span><br><span class="line">  &#x2F;&#x2F;获取活跃的session</span><br><span class="line">  Collection&lt;Session&gt; getActiveSessions();</span><br></pre></td></tr></table></figure></li></ul><ul><li>会话存储有多个实现</li></ul><p>附属资料：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> RememberMe</span><br><span class="line">  1、 Cookie 写到客户端并 保存</span><br><span class="line">2、 通过调用subject.login()前，设置 token.setRememberMe(true);</span><br><span class="line">  3、 关闭浏览器再重新打开;会发现浏览器还是记住你的</span><br><span class="line">  4、 注意点：</span><br><span class="line">    - subject.isAuthenticated() 表示用户进行了身份验证登录的，即Subject.login 进行了登录</span><br><span class="line">    - subject.isRemembered() 表示用户是通过RememberMe登录的</span><br><span class="line">    - subject.isAuthenticated()&#x3D;&#x3D;true，则 subject.isRemembered()&#x3D;&#x3D;false， 两个互斥</span><br><span class="line">    - 总结：特殊页面或者API调用才需要authc进行验证拦截，该拦截器会判断用户是否是通过 subject.login()登录，安全性更高，其他非核心接口或者页面则通过user拦截器处理即可</span><br></pre></td></tr></table></figure></li></ul><h3 id="升天"><a href="#升天" class="headerlink" title="升天"></a>升天</h3><h4 id="自定义Shiro-Filter过滤器"><a href="#自定义Shiro-Filter过滤器" class="headerlink" title="自定义Shiro Filter过滤器"></a>自定义Shiro Filter过滤器</h4><ul><li><p>背景知识：</p><ul><li>/admin/order= roles[“admin, root”] ，表示 /admin/order 这个接口需要用户同时具备 admin 与 root 角色才可访问,  相当于hasAllRoles() 这个判断方法</li></ul></li><li><p>我们的需求：</p><ul><li><p>订单信息，可以由角色 普通管理员 admin 或者 超级管理员 root 查看</p></li><li><p>只要用户具备其中一个角色即可</p></li></ul></li><li><p>自定义Filter </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; mappedValue -》roles[admin,root]</span><br><span class="line">public class CustomRolesOrAuthorizationFilter extends AuthorizationFilter &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest req, ServletResponse resp, Object mappedValue) throws Exception &#123;  </span><br><span class="line">        </span><br><span class="line">        Subject subject &#x3D; getSubject(req, resp);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取当前访问路径所需要的角色集合  </span><br><span class="line">        String[] rolesArray &#x3D; (String[]) mappedValue;  </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;没有角色限制，有权限访问  </span><br><span class="line">        if (rolesArray &#x3D;&#x3D; null || rolesArray.length &#x3D;&#x3D; 0) &#123; </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;当前subject是rolesArray中的任何一个，则有权限访问  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; rolesArray.length; i++) &#123;  </span><br><span class="line">            if (subject.hasRole(rolesArray[i])) &#123; </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FactoryBean配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Filter&gt; filtersMap &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">filtersMap.put(&quot;roleOrFilter&quot;,new CustomRolesOrAuthorizationFilter());</span><br><span class="line">filterChainDefinitionMap.put(&quot;&#x2F;admin&#x2F;**&quot;,&quot;roleOrFilter[admin,root]&quot;);</span><br><span class="line">shiroFilterFactoryBean.setFilters(filtersMap);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置不同的角色，验证自定义过滤器是否有效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录(post)</span><br><span class="line">localhost:8080&#x2F;pub&#x2F;login</span><br><span class="line"></span><br><span class="line">管理员查看后台信息(get)</span><br><span class="line">localhost:8080&#x2F;admin&#x2F;video&#x2F;order</span><br></pre></td></tr></table></figure></li></ul><h4 id="Redis整合CacheManager"><a href="#Redis整合CacheManager" class="headerlink" title="Redis整合CacheManager"></a>Redis整合CacheManager</h4><ul><li><p>使用原因？</p><ul><li>授权的时候每次都去查询数据库，对于频繁访问的接口，性能和响应速度比较慢，所以使用缓存</li></ul></li><li><p>步骤</p><ul><li>加依赖</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- shiro+redis缓存插件 --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.crazycake&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;3.1.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置bean</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用自定义的cacheManager</span><br><span class="line"> securityManager.setCacheManager(cacheManager());</span><br><span class="line">      </span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 配置redisManager</span><br><span class="line">   *</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public RedisManager getRedisManager()&#123;</span><br><span class="line">      RedisManager redisManager &#x3D; new RedisManager();</span><br><span class="line">      redisManager.setHost(&quot;localhost&quot;);</span><br><span class="line">      redisManager.setPort(6379);</span><br><span class="line">      return redisManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 配置具体cache实现类</span><br><span class="line">   * @return</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public RedisCacheManager cacheManager()&#123;</span><br><span class="line">      RedisCacheManager redisCacheManager &#x3D; new RedisCacheManager();</span><br><span class="line">      redisCacheManager.setRedisManager(getRedisManager());</span><br><span class="line">       &#x2F;&#x2F;设置过期时间，单位是秒，20s,</span><br><span class="line">      redisCacheManager.setExpire(20);</span><br><span class="line">  </span><br><span class="line">      return redisCacheManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li><p>安装redis</p><ul><li>建议本地安装，默认是不能外网访问的，然后不是守护进程方式</li><li><a href="https://www.cnblogs.com/it-cen/p/4295984.html">https://www.cnblogs.com/it-cen/p/4295984.html</a></li></ul></li><li><p>原有的问题</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.String must has getter for field: authCacheKey or id\nWe need a field to identify this Cache Object in Redis. So you need to defined an id field which you can get unique id to identify this principal. For example, if you use UserInfo as Principal class, the id field maybe userId, userName, email, etc. For example, getUserId(), getUserName(), getEmail(), etc.\nDefault value is authCacheKey or id, that means your principal object has a method called \&quot;getAuthCacheKey()\&quot; or \&quot;getId()\&quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>改造原有的逻辑，修改缓存的唯一key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doGetAuthorizationInfo 方法</span><br><span class="line">原有：</span><br><span class="line">String username &#x3D; (String)principals.getPrimaryPrincipal();</span><br><span class="line">User user &#x3D; userService.findAllUserInfoByUsername(username);</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">User newUser &#x3D; (User)principals.getPrimaryPrincipal();</span><br><span class="line">    User user &#x3D; userService.findAllUserInfoByUsername(newUser.getUsername());</span><br><span class="line"></span><br><span class="line">doGetAuthenticationInfo方法</span><br><span class="line">原有：</span><br><span class="line">return new SimpleAuthenticationInfo(username, user.getPassword(), this.getClass().getName());</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line">return new SimpleAuthenticationInfo(user, user.getPassword(), this.getClass().getName());</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Redis整合SessionManager"><a href="#Redis整合SessionManager" class="headerlink" title="Redis整合SessionManager"></a>Redis整合SessionManager</h4><ul><li><p>为啥session也要持久化？</p><ul><li>重启应用，用户无感知，可以继续以原先的状态继续访问</li></ul></li><li><p>怎么持久化？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> &#x2F;&#x2F;配置session持久化</span><br><span class="line"> customSessionManager.setSessionDAO(redisSessionDAO());</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">   * 自定义session持久化</span><br><span class="line">   * @return</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public RedisSessionDAO redisSessionDAO()&#123;</span><br><span class="line">      RedisSessionDAO redisSessionDAO &#x3D; new RedisSessionDAO();</span><br><span class="line">      redisSessionDAO.setRedisManager(getRedisManager());</span><br><span class="line">      return redisSessionDAO;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li><p>DO对象需要实现序列化接口  Serializable</p></li><li><p>logout接口和以前一样调用，请求logout后会删除redis里面的对应的key,即删除对应的token</p></li></ul></li></ul><h4 id="ShiroConfig常用bean类配置"><a href="#ShiroConfig常用bean类配置" class="headerlink" title="ShiroConfig常用bean类配置"></a>ShiroConfig常用bean类配置</h4><ul><li><p>LifecycleBeanPostProcessor</p><ul><li>作用：管理shiro一些bean的生命周期 即bean初始化 与销毁</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123;</span><br><span class="line">return new LifecycleBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AuthorizationAttributeSourceAdvisor</p><ul><li>作用：加入注解的使用，不加入这个AOP注解不生效(shiro的注解 例如 @RequiresGuest)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line"> public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() &#123;</span><br><span class="line">  AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor &#x3D; new AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager());</span><br><span class="line">        return authorizationAttributeSourceAdvisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DefaultAdvisorAutoProxyCreator</p><ul><li>作用: 用来扫描上下文寻找所有的Advistor(通知器), 将符合条件的Advisor应用到切入点的Bean中，需要在LifecycleBeanPostProcessor创建后才可以创建</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@DependsOn(&quot;lifecycleBeanPostProcessor&quot;)</span><br><span class="line">public  DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator()&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator&#x3D;new DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        defaultAdvisorAutoProxyCreator.setUsePrefix(true);</span><br><span class="line">        return defaultAdvisorAutoProxyCreator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="分布式应用的鉴权方式"><a href="#分布式应用的鉴权方式" class="headerlink" title="分布式应用的鉴权方式"></a>分布式应用的鉴权方式</h4><p>**分布式应用下的鉴权方式 **</p><ul><li>分布式session</li><li>UUID</li><li>JWT<ul><li><a href="https://www.cnblogs.com/cjsblog/p/9277677.html">https://www.cnblogs.com/cjsblog/p/9277677.html</a></li></ul></li><li>Oauth2.0<ul><li><a href="https://www.cnblogs.com/flashsun/p/7424071.html">https://www.cnblogs.com/flashsun/p/7424071.html</a></li></ul></li></ul><p><strong>Shiro整合SpringBoot下自定义SessionId</strong></p><ul><li><p>Shiro 默认的sessionid生成 类名 SessionIdGenerator</p></li><li><p>创建一个类，实现 SessionIdGenerator 接口的方法</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 自定义session持久化</span><br><span class="line">   * @return</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public RedisSessionDAO redisSessionDAO()&#123;</span><br><span class="line">      RedisSessionDAO redisSessionDAO &#x3D; new RedisSessionDAO();</span><br><span class="line">      redisSessionDAO.setRedisManager(getRedisManager());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;设置sessionid生成器</span><br><span class="line">      redisSessionDAO.setSessionIdGenerator(new CustomSessionIdGenerator());</span><br><span class="line"></span><br><span class="line">      return redisSessionDAO;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>没有100%可靠的算法，暴力破解，穷举<ul><li>限制时间内ip登录错误次数</li><li>增加图形验证码，不能过于简单，常用的OCR可以识别验证码</li></ul></li><li>建议：微服务里面，特别是对C端用户的应用，不要做过于复杂的权限校验，特别是影响性能这块LL</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot shiro 鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>葵花宝典</title>
      <link href="2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/"/>
      <url>2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<p>打工人，打工魂，打工都是人上人。</p><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ol><li><p><strong>String str = new String(“zyaire.net”); 创建了了⼏几个对象？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个对象：常量池存在，则直接new⼀个对象；</span><br><span class="line">创建两个对象：常量池不存在，则在常量池创建一个对象，也在堆里面创建一个对象</span><br></pre></td></tr></table></figure><p>ps：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s2 &#x3D; s1 + &quot;.net&quot;; &#x2F;&#x2F;变量 + 常量 &#x3D; 来自堆</span><br><span class="line">#把s1变为常量的方法：fianl String s1 &#x3D; &quot;zyaire&quot;</span><br><span class="line">#不管是new String(&quot;XXX&quot;)和直接常量赋值, 都会在字符串常量池创建.只是new String(&quot;XXX&quot;)方式会在堆中创建一个对象去指向常量池的对象, 普通的常量赋值是直接赋值给变量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s3 &#x3D; &quot;zyaire&quot; + &quot;.net&quot;; &#x2F;&#x2F;常量 + 常量 &#x3D; 来自常量池</span><br><span class="line">#javac编译可以对【字符串常量】直接相加的表达式进行优化，不用等到运行期再去进行加法运算处理，而是直接将其编译成⼀个这些常量相连的结果</span><br></pre></td></tr></table></figure></li><li><p><strong>接口是否可以继承接口？接口是否⽀支持多继承？类是否支持多继承？接口⾥里面是否可以有方法实现？</strong></p><ul><li>接⼝里可以有静态方法和方法体</li><li>接⼝中所有的方法必须是抽象方法（JDK8之后就不是）</li><li>接⼝不是被类继承了了，而是要被类实现</li><li>接⼝⽀持多继承, 类不支持多个类继承</li></ul></li><li><p><strong>JDK8接口新特性</strong></p><ul><li>interface中可以有static方法，但必须有方法实现体，该方法只属于该接口，接口名直接调用该方法</li><li>接口中新增default关键字修饰的方法，default方法只能定义在接口中，可以在子类或⼦子接口中被重写，default定义的方法必须有方法体</li><li>父接口的default方法如果在子接口或子类被重写，那么子接口实现对象、子类对象，调用该方法，以重写为准</li><li>本类、接口如果没有重写父类（即接口）的default方法，则在调用default方法时，使用父类（接口） 定义的default方法逻辑</li></ul></li><li><p><strong>如果需要保证线程安全，ArrayList应该怎么做，⽤用有几种⽅方式?</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：自己写个包装类，根据业务一般是add&#x2F;update&#x2F;remove加锁</span><br><span class="line">方式二：Collections.synchronizedList(new ArrayList&lt;&gt;())&#x2F;&#x2F;使用synchronized加锁</span><br><span class="line">方式三：CopyOnWriteArrayList&lt;&gt;()&#x2F;&#x2F;get()没有加锁</span><br><span class="line">&#x2F;&#x2F;add():使用ReentrantLock加锁----&gt;Arrays.copyOf()----&gt;unlock----&gt;拷贝引用地址</span><br><span class="line">&#x2F;&#x2F;通通给我锁上!!!</span><br></pre></td></tr></table></figure></li><li><p><strong>CopyOnWriteArrayList和Collections.synchronizedList实现线程安全有什么区别？</strong></p><ul><li>CopyOnWriteArrayList：执行修改操作时，会拷贝一份新的数组进行操作（add、set、remove等)，代价十分昂贵，在执行完修改后将原来集合指向新的集合来完成修改操作，源码里面用ReentrantLock可重入锁来保证不会有多个线程同时拷贝一份数组。</li><li>Collections.synchronizedList：线程安全的原因是因为它几乎在每个方法中都使用了synchronized同步锁</li></ul></li><li><p><strong>CopyOnWriteArrayList的设计思想是怎样的,有什么缺点？</strong></p><ul><li>优点：设计思想：读写分离+最终一致</li><li>缺点：内存占用问题，写时复制机制，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象,如果对象大则容易发生Yong GC和Full GC</li></ul></li><li><p><strong>ArrayList的扩容机制？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：JDK1.7之前ArrayList默认大小是10，JDk1.7之后是0</span><br><span class="line">未指定集合容量，默认是0，若已经指定大小则集合大小为指定的；</span><br><span class="line">当集合第一次添加元素的时候，集合大小扩容为10</span><br><span class="line">ArrayList的元素个数大于其容量，扩容的大小&#x3D; 原始大小+原始大小&#x2F;2</span><br></pre></td></tr></table></figure></li><li><p><strong>HashMap和Hashtable</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap：底层是基于数组+链表，非线程安全的，默认容量是16、允许有空的健和值</span><br><span class="line">Hashtable：基于哈希表实现，线程安全的(加了synchronized)，默认容量是11，不允许有null的健和值</span><br></pre></td></tr></table></figure></li><li><p><strong>HashMap和TreeMap</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashMap:散列桶(数组+链表)，可以实现快速的存储和检索，但是确实包含无序的元素，适⽤用于在map中插入删除和  定位元素</span><br><span class="line">treeMap:使用存储结构是一个平衡二叉树-&gt;红黑树，可以自定义排序规则，要实现Comparator接口，能便捷的实现内 部元素的各种排序，但是一般性能比HashMap差，适用于安装自然排序或者自定义排序规则(写过微信⽀付签  名工具类就用这个类)</span><br></pre></td></tr></table></figure></li><li><p><strong>什么是Hash碰撞？常⻅见的解决办法有哪些？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash碰撞的意思是不同key计算得到的Hash值相同，需要放到同个bucket中</span><br><span class="line">常见的解决办法：链表法、开发地址法、再哈希法等</span><br><span class="line">HashMap采用的是链表法</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么ConcurrentHashMap性能比hashtable高？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap线程安全的Map, hashtable类基本上所有的方法都是采用synchronized进行线程安全控制</span><br><span class="line">高并发情况下效率就降低</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap是采用了分段锁的思想提高性能，锁粒度更细化</span><br></pre></td></tr></table></figure></li><li><p><strong>jdk1.7和jdk1.8里面ConcurrentHashMap实现</strong>的区别</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;都不允许空值</span><br><span class="line">JDK8之前，ConcurrentHashMap使用锁分段技术，将数据分成一段段存储，每个数据段配置一把锁，即segment类，这个类继承ReentrantLock来保证线程安全</span><br><span class="line">技术点：Segment+HashEntry</span><br><span class="line"></span><br><span class="line">JKD8的版本取消Segment这个分段锁数据结构，底层也是使用Node数组+链表+红黑树，从而实现对每一段数据就行加锁，也减少了并发冲突的概率，CAS(读)+Synchronized(写)</span><br><span class="line">技术点：Node+Cas+Synchronized</span><br></pre></td></tr></table></figure></li><li><p><strong>ConcurrentHashMap的put的核心逻辑（JDK8以上版本）</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spread(key.hashCode())  重哈希，减少碰撞概率</span><br><span class="line">tabAt(i) 获取table中索引为i的Node元素</span><br><span class="line">casTabAt(i) 利用CAS操作获取table中索引为i的Node元素</span><br><span class="line"></span><br><span class="line">put的核心流程</span><br><span class="line">1、key进行重哈希spread(key.hashCode())</span><br><span class="line">2、对当前table进行无条件循环</span><br><span class="line">3、如果没有初始化table，则用initTable进行初始化</span><br><span class="line">4、如果没有hash冲突，则直接用cas插入新节点，成功后则直接判断是否需要扩容，然后结束</span><br><span class="line">5、(fh &#x3D; f.hash) &#x3D;&#x3D; MOVED 如果是这个状态则是扩容操作，先进行扩容</span><br><span class="line">6、存在hash冲突，利用synchronized (f) 加锁保证线程安全</span><br><span class="line">7、如果是链表，则直接遍历插入，如果数量大于8，则需要转换成红黑树</span><br><span class="line">8、如果是红黑树则按照红黑树规则插入</span><br><span class="line">9、最后是检查是否需要扩容addCount()</span><br><span class="line">&#x2F;&#x2F;令人头大</span><br></pre></td></tr></table></figure></li><li><p><strong>Spring里面 CGLib和JDK动态代理区别、选择策略</strong><br>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理，解耦和易维护</p><p>两种动态代理的区别：</p><ul><li><p>JDK动态代理：要求目标对象实现一个接口，但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以用CGLib动态代理</p></li><li><p>CGLib动态代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展</p></li><li><p>JDK动态代理是自带的，CGlib需要引入第三方包</p></li><li><p>CGLib动态代理基于继承来实现代理，所以无法对final类、private方法和static方法实现代理</p></li></ul></li></ol><pre><code>Spring AOP中的代理使用的默认策略：- 如果目标对象实现了接口，则默认采用JDK动态代理- 如果目标对象没有实现接口，则采用CgLib进行动态代理- 如果目标对象实现了接扣，程序里面依旧可以指定使用CGlib动态代理</code></pre><ol start="15"><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li></li></ol><h4 id="web"><a href="#web" class="headerlink" title="web"></a>web</h4><ol><li><p>servlet的生命周期</p><ul><li>实例化-&gt;使用构造方法创建对象</li><li>初始化-&gt;执行init方法：Servlet 的生命期中，仅执行一次 init() 方法，它是在服务器装入 Servlet 时执行的,即第一次访问这个Servlet才执行</li><li>服务-&gt;执行service方法，service() 方法是 Servlet 的核心。每当一个客户请求一个HttpServlet 对象，该对象的service() 方法就要被调用</li><li>销毁-&gt; 执行destroy方法,destroy() 方法仅执行一次，即在服务器停止且卸装 Servlet 时执行该方法</li></ul></li><li><p>Servlet API中forward()和redirect()的区别</p><ul><li>重定向会改变URL地址，请求转发不会改变URL地址</li><li>重定向不可以使用多个作用域的内容，请求转发可以</li><li>重定向可以用URL访问外部资源，请求转发只能跳转内部资源</li><li>重定向会触发多次请求；转发的话只在内部跳转</li></ul></li><li><p>Cookie和Session的区别和联系</p><ul><li>cookie数据保存在客户端，session数据保存在服务端</li><li>cookie不是很安全，容易泄露，不能直接明文存储信息</li><li>Cookie大小和数量存储有限制</li></ul></li><li><p>JDBC中的Statement 和PreparedStatement的区别</p><ul><li>PreparedStatement在执行之前会进行预编译</li><li>效率高于Statement,且能够有效防止SQL注入</li><li>PreparedStatement支持?占位符而不是直接拼接，提高可读性</li></ul></li><li><p>数据库连接池工作原理和优点</p><ul><li>先创建一定数量的连接对象存放在连接池</li><li>需要使用连接对象的时候，从连接池中请求一个空闲的连接</li><li>使用完毕之后，并不会把连接关闭，而是还给连接池</li><li>优点：<ul><li>系统响应速度加快</li><li>资源利用率高</li></ul></li></ul></li><li><p>为什么要用连接池</p><ul><li>数据库建立Connection比较耗时，频繁的创建和释放连接引起的大量性能开销</li><li>如果数据库连接得到重用，避免这些开销，也提高了系统稳定</li><li>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用，对于业务请求处理而言，直接利用现有可用连接，缩减了系统整体响应时间</li><li>统一的连接管理，避免数据库连接泄漏、超时占用等问题</li></ul></li><li><p>ttp请求 get和post的区别</p><ul><li>get是用来从服务器上获取数据，而post是用来向服务器上传递数据</li><li>get是不安全的，因为在传输过程中，数据被放在请求的URL中,post是放到body里面，对小白用户不可见</li><li>get传输的数据量小，主要是由于受URL长度的限制；post可以传输大量的数据，一般上传文件只能用post</li></ul></li><li><p>浏览器输入一个地址，到页面展示中间经历了哪些处理</p><ul><li>浏览器输入url, 解析url地址是否合法</li><li>浏览器检查是否有缓存, 如果有直接显示。如果没有跳到第三步。</li><li>在发送http请求前，需要域名解析（DNS解析），解析获取对应过的ip地址。</li><li>浏览器向服务器发起tcp链接，完成tcp三次握手</li><li>握手成功后，浏览器向服务器发送http请求</li><li>服务器收到处理的请求，将数据返回至浏览器</li><li>浏览器收到http响应。</li><li>浏览器解析响应。如果响应可以缓存，则存入缓存</li><li>浏览器进行页面渲染</li></ul></li><li><p>你知道HTTP有哪些状态码吗，列举下 </p><ul><li><p>200：成功</p></li><li><p>302：重定向</p></li><li><p>404：请求失败，基本都是路径拼接错误</p></li><li><p>400：请求没有进入到后台服务里，比如http报文有问题</p></li><li><p>502：无效的响应（基本上就是Tomcat没启好或者挂了）</p></li></ul></li><li><p>你知道http和https的区别</p><ul><li>HTTPS = HTTP + SSL</li><li>https有ca证书，http一般没有</li><li>http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议</li><li>http默认80端口，https默认443端口。</li></ul></li><li><p>解决内网与外网之间的切换烦恼</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：</span><br><span class="line">公司内网 子网192.168.43.0</span><br><span class="line">剩余可分配ip地址 192.168.43.30 ~ 192.168.43.60</span><br><span class="line"></span><br><span class="line">内网网关ip地址：192.168.43.1</span><br><span class="line">外网路由器的子网 192.168.1.0</span><br><span class="line">网关ip地址：192.168.190.1</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：先设置有线网卡的ip地址与网关，ip设置为192.168.43.30 ~ 192.168.43.60中的其中一个，网关192.168.43.1，子网掩码:255.255.255.0</span><br><span class="line">第二步：无线网卡的ip地址设置自动获取ip即可</span><br><span class="line">第三步：route delete 0.0.0.0 &quot;删除所有0.0.0.0的路由&quot;</span><br><span class="line">第四步：route add -p 0.0.0.0 mask 0.0.0.0 192.168.1.1 &quot;添加0.0.0.0网络路由&quot;</span><br><span class="line">第五步：route add -p 192.168.43.0 mask 255.255.255.0 192.168.43.1 &quot;添加192.168.43.0网络路由&quot;</span><br></pre></td></tr></table></figure></code></pre><ol start="12"><li><p>e</p></li><li><p>e</p></li></ol><h4 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h4><h5 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h5><ol><li><p><strong>线程、进程、协程的区别</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程: 本质上是一个独立执行的程序，进程是操作系统进行资源分配和调度的基本概念，操作系统进行资源分配和调度的一个独立单位</span><br><span class="line"></span><br><span class="line">线程:是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程执行不同的任务，切换受系统控制。</span><br><span class="line"></span><br><span class="line">协程: 又称为微线程，是一种用户态的轻量级线程，协程不像线程和进程需要进行系统内核上的上下文切换，协程的上下文切换是由用户自己决定的，有自己的上下文，所以说是轻量级的线程，也称之为用户级别的线程就叫协程，一个线程可以多个协程,线程进程都是同步机制，而协程则是异步 </span><br><span class="line">Java的原生语法中并没有实现协程,目前python、Lua和GO等语言支持</span><br><span class="line"></span><br><span class="line">关系：一个进程可以有多个线程，它允许计算机同时运行两个或多个程序。线程是进程的最小执行单位，CPU的调度切换的是进程和线程，进程和线程多了之后调度会消耗大量的CPU，CPU上真正运行的是线程，线程可以对应多个协程</span><br></pre></td></tr></table></figure></li><li><p><strong>协程对于多线程的优缺点</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">    非常快速的上下文切换，不用系统内核的上下文切换，减小开销</span><br><span class="line">    单线程即可实现高并发，单核CPU可以支持上万的协程</span><br><span class="line">    由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁</span><br><span class="line">缺点：</span><br><span class="line">    协程无法利用多核资源，本质也是个单线程</span><br><span class="line">    协程需要和进程配合才能运行在多CPU上</span><br><span class="line">    目前java没成熟的第三方库，存在风险</span><br><span class="line">    调试debug存在难度，不利于发现问题</span><br></pre></td></tr></table></figure></li><li><p><strong>并发和并行的区别</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并发 concurrency：</span><br><span class="line">一台处理器上同时处理任务, 这个同时实际上是交替处理多个任务，程序中可以同时拥有两个或者多个线程，当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行</span><br><span class="line"></span><br><span class="line">并行 parallellism：</span><br><span class="line">    多个CPU上同时处理多个任务，一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行</span><br><span class="line">        </span><br><span class="line">并发指在一段时间内宏观上去处理多个任务。  并行指同一个时刻，多个任务确实真的同时运行。    </span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">并发是一心多用，听课和看电影，但是CPU大脑只有一个，所以轮着来</span><br><span class="line">并行：火影忍者中的影分身，有多个你出现，可以分别做不同的事情</span><br><span class="line"></span><br><span class="line">一个项目经理A和3个程序B C D的故事</span><br><span class="line">单线程</span><br><span class="line">并发：A给B讲完需求，B自己去实现，期间A继续给C和D讲，不用等待某个程序员去完成，期间项目经理没空闲下来</span><br><span class="line">并行：直接找3个项目经理分别分配给3个程序员</span><br></pre></td></tr></table></figure></li><li><p><strong>java里面实现多线程有哪几种方式</strong></p><ul><li><p>继承Thread类</p></li><li><p>实现Runnable接口</p></li><li><p>通过Callable和FutureTask方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建callable接口的实现类，并实现call方法，结合FutureTask类包装Callable对象，实现多线程</span><br><span class="line">&#x2F;&#x2F;优点：有返回值，拓展性也高</span><br></pre></td></tr></table></figure></li><li><p>通过线程池创建线程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义Runnable接口，实现run方法，创建线程池，调用执行方法并传入对象</span><br><span class="line">&#x2F;&#x2F;优点：安全高性能，复用线程</span><br><span class="line">public class ThreadDemo4 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;通过线程池+runnable实现多线程，名称：&quot;+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            executorService.execute(new ThreadDemo4());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程名称:&quot;+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>java线程常见的基本状态有哪些</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK的线程状态分6种，JVM里面9种，我们一般说JDK的线程状态</span><br><span class="line"></span><br><span class="line">常见的5种状态</span><br><span class="line"></span><br><span class="line">创建(NEW): 生成线程对象，但是并没有调用该对象start(), new Thread()</span><br><span class="line"></span><br><span class="line">就绪(Runnable)：当调用线程对象的start()方法，线程就进入就绪状态，但是此刻线程调度还没把该线程设置为当前线程，就是没获得CPU使用权。   如果线程运行后，从等待或者睡眠中回来之后，也会进入就绪状态</span><br><span class="line">    注意:有些文档把就绪和运行两种状态统一称为 “运行中”</span><br><span class="line"></span><br><span class="line">运行(Running)</span><br><span class="line">    程序将处于就绪状态的线程设置为当前线程，即获得CPU使用权，这个时候线程进入运行状态，开始运行run里面的逻辑</span><br><span class="line"></span><br><span class="line">阻塞(Blocked)</span><br><span class="line">    等待阻塞：进入该状态的线程需要等待其他线程作出一定动作(通知或中断)，这种状态的话CPU不会分配过来，他们需要被唤醒，可能也会无限等待下去。比如调用wait(状态就会变成WAITING状态)，也可能通过调用sleep(状态就会变成TIMED_WAITING), join或者发出IO请求，阻塞结束后线程重新进入就绪状态</span><br><span class="line">    </span><br><span class="line">    同步阻塞：线程在获取synchronized同步锁失败，即锁被其他线程占用，它就会进入同步阻塞状态</span><br><span class="line">    </span><br><span class="line">    备注：相关资料会用细分下面的状态</span><br><span class="line">        等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</span><br><span class="line">        超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">死亡(TERMINATED):一个线程run方法执行结束，该线程就死亡了，不能进入就绪状态</span><br></pre></td></tr></table></figure></li><li><p><strong>多线程开发里面常用的API</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sleep</span><br><span class="line">    属于线程Thread的方法</span><br><span class="line">    让线程暂缓执行，等待预计时间之后再恢复</span><br><span class="line">    交出CPU使用权，不会释放锁</span><br><span class="line">    进入阻塞状态TIME_WAITGING，睡眠结束变为就绪Runnable</span><br><span class="line">    </span><br><span class="line">yield</span><br><span class="line">    属于线程Thread的方法</span><br><span class="line">    t1&#x2F;t2&#x2F;t3</span><br><span class="line">    暂停当前线程的对象，去执行其他线程</span><br><span class="line">    交出CPU使用权，不会释放锁，和sleep类似</span><br><span class="line">    作用：让相同优先级的线程轮流执行，但是不保证一定轮流</span><br><span class="line">    注意：不会让线程进入阻塞状态，直接变为就绪Runnable，只需要重新获得CPU使用权</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">join  </span><br><span class="line">    属于线程Thread的方法</span><br><span class="line">    在主线程上运行调用该方法，会让主线程休眠，不会释放已经持有的对象锁</span><br><span class="line">    让调用join方法的线程先执行完毕，在执行其他线程</span><br><span class="line">    类似让救护车警车优先通过</span><br><span class="line">    </span><br><span class="line">wait</span><br><span class="line">    属于Object的方法</span><br><span class="line">    当前线程调用对象的wait方法，会All唤醒，或者wait(timeout)时间自动唤醒</span><br><span class="line">    </span><br><span class="line">notify</span><br><span class="line">    属于Object的方法</span><br><span class="line">    唤醒在对象监视器上等待的单个线程，选择是任意的</span><br><span class="line">    </span><br><span class="line">notifyAll</span><br><span class="line">    属于Object的方法</span><br><span class="line">    唤醒在对象监视器上等待的全部线程</span><br></pre></td></tr></table></figure></li><li><p><strong>在Java中可以有哪些方法来保证线程安全</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加锁,比如synchronize&#x2F;ReentrantLock</span><br><span class="line">使用volatile声明变量，轻量级同步，不能保证原子性(需要解释)</span><br><span class="line">使用线程安全类(原子类AtomicXXX，并发容器，同步容器 CopyOnWriteArrayList&#x2F;ConcurrentHashMap等</span><br><span class="line">ThreadLocal本地私有变量&#x2F;信号量Semaphore等</span><br></pre></td></tr></table></figure></li><li><p><strong>volatile关键字</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile是轻量级的synchronized，保证了共享变量的可见性，被volatile关键字修饰的变量，如果值发生了变化，其他线程立刻可见，避免出现脏读现象</span><br><span class="line"></span><br><span class="line">volatile：保证可见性，但是不能保证原子性</span><br><span class="line">synchronized：保证可见性，也保证原子性</span><br><span class="line"></span><br><span class="line">使用场景</span><br><span class="line">1、不能修饰写入操作依赖当前值的变量，比如num++、num&#x3D;num+1,不是原子操作，肉眼看起来是，但是JVM字节码层面不止一步</span><br><span class="line"></span><br><span class="line">2、由于禁止了指令重排，所以JVM相关的优化没了，效率会偏弱</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么会出现脏读？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA内存模型简称 JVM</span><br><span class="line">JMM规定所有的变量存在主内存，每个线程有自己的工作内存,线程对变量的操作都在工作内存中进行，不能直接对主内存就行操作</span><br><span class="line"></span><br><span class="line">使用volatile修饰变量</span><br><span class="line">每次读取前必须从主内存属性最新的值</span><br><span class="line">每次写需要立刻写到主内存中</span><br><span class="line"></span><br><span class="line">volatile关键字修修饰的变量随时看到的自己的最新值，假如线程1对变量v进行修改，那么线程2是可以马上看见</span><br></pre></td></tr></table></figure><p><img src="/2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107093745135.png" alt="image-20201107093745135"></p></li><li><p><strong>什么是指令重排?</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指令重排序分两类 编译器重排序和运行时重排序</span><br><span class="line"></span><br><span class="line">JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(不改变程序结果的前提)</span><br><span class="line"></span><br><span class="line">int a &#x3D; 3 &#x2F;&#x2F;1</span><br><span class="line">int b &#x3D; 4 &#x2F;&#x2F;2</span><br><span class="line">int c &#x3D;5 &#x2F;&#x2F;3 </span><br><span class="line">int h &#x3D; a*b*c &#x2F;&#x2F;4</span><br><span class="line"></span><br><span class="line">定义顺序 1,2,3,4</span><br><span class="line">计算顺序  1,3,2,4 和 2,1,3,4 结果都是一样</span><br><span class="line"></span><br><span class="line">虽然指令重排序可以提高执行效率，但是多线程上可能会影响结果，有什么解决办法？</span><br><span class="line">解决办法：内存屏障</span><br><span class="line">解释：内存屏障是屏障指令，使CPU对屏障指令之前和之后的内存操作执行结果的一种约束</span><br></pre></td></tr></table></figure></li><li><p><strong>happens-before原则</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先行发生原则，volatile的内存可见性就提现了该原则之一</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">&#x2F;&#x2F;线程A操作</span><br><span class="line">int k &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程B操作</span><br><span class="line">int j &#x3D; k;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程C操作</span><br><span class="line">int k &#x3D; 2</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">假设线程A中的操作“k&#x3D;1”先行发生于线程B的操作“j&#x3D;k”，那确定在线程B的操作执行后，变量j的值一定等于1，依据有两个：一是先行发生原则，“k&#x3D;1”的结果可以被观察到；二是第三者线程C还没出现，线程A操作结束之后没有其他线程会修改变量k的值。</span><br><span class="line"></span><br><span class="line">但是考虑线程C出现了，保持线程A和线程B之间的先行发生关系，线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少？答案是1和2都有可能，因为线程C对变量k的影响可能会被线程B观察到，也可能不会，所以线程B就存在读取到不符合预期数据的风险，不具备多线程安全性</span><br><span class="line"></span><br><span class="line">八大原则</span><br><span class="line">1、程序次序规则</span><br><span class="line">2、管程锁定规则</span><br><span class="line">3、volatile变量规则</span><br><span class="line">4、线程启动规则</span><br><span class="line">5、线程中断规则</span><br><span class="line">6、线程终止规则</span><br><span class="line">7、对象终结规则</span><br><span class="line">8、传递性</span><br></pre></td></tr></table></figure></li><li><p><strong>并发编程三要素</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原子性:一个不可再被分割的颗粒，原子性指的是一个或多个操作要么全部执行成功要么全部执行失败，期间不能被中断，也不存在上下文切换，线程切换会带来原子性的问题</span><br><span class="line"></span><br><span class="line">有序性: 程序执行的顺序按照代码的先后顺序执行，因为处理器可能会对指令进行重排序</span><br><span class="line">JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(不改变程序结果的前提)</span><br><span class="line"></span><br><span class="line">可见性: 一个线程A对共享变量的修改,另一个线程B能够立刻看到</span><br></pre></td></tr></table></figure></li><li><p><strong>进程和线程间的调度算法</strong></p><p><img src="/2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107094651554.png" alt="image-20201107094651554"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先来先服务调度算法：</span><br><span class="line">    按照作业&#x2F;进程到达的先后顺序进行调度 ，即：优先考虑在系统中等待时间最长的作业</span><br><span class="line">    排在长进程后的短进程的等待时间长，不利于短作业&#x2F;进程</span><br><span class="line"></span><br><span class="line">短作业优先调度算法：</span><br><span class="line">    短进程&#x2F;作业（要求服务时间最短）在实际情况中占有很大比例，为了使得它们优先执行</span><br><span class="line">    对长作业不友好</span><br><span class="line"></span><br><span class="line">高响应比优先调度算法: </span><br><span class="line">    在每次调度时，先计算各个作业的优先权：优先权&#x3D;响应比&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间,</span><br><span class="line">    因为等待时间与服务时间之和就是系统对该作业的响应时间，所以 优先权&#x3D;响应比&#x3D;响应时间&#x2F;要求服务时间，选    择优先权高的进行服务需要计算优先权信息，增加了系统的开销</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">时间片轮转调度算法:</span><br><span class="line">    轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</span><br><span class="line">    由于高频率的进程切换，会增加了开销，且不区分任务的紧急程度</span><br><span class="line"></span><br><span class="line">优先级调度算法:</span><br><span class="line">    根据任务的紧急程度进行调度，高优先级的先处理，低优先级的慢处理</span><br><span class="line">    如果高优先级任务很多且持续产生，那低优先级的就可能很慢才被处理</span><br></pre></td></tr></table></figure><p><img src="/2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107094736862.png" alt="image-20201107094736862"></p><p>​    要求服务时间越短，优先级越高。</p></li><li><p><strong>常见的线程间的调度算法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程调度是指系统为线程分配CPU使用权的过程，主要分两种</span><br><span class="line"></span><br><span class="line">协同式线程调度(分时调度模式)：线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里</span><br><span class="line"></span><br><span class="line">抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞</span><br><span class="line"></span><br><span class="line">Java线程调度就是抢占式调度,优先让可运行池中优先级高的线程占用CPU,如果可运行池中的线程优先级相同,那就随机选择一个线程</span><br><span class="line"></span><br><span class="line">所以我们如果希望某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。</span><br><span class="line">JAVA的线程的优先级，以1到10的整数指定。当多个线程可以运行时，VM一般会运行最高优先级的线程（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）</span><br><span class="line"></span><br><span class="line">在两线程同时处于就绪runnable状态时，优先级越高的线程越容易被系统选择执行。但是优先级并不是100%可以获得，只不过是机会更大而已。</span><br><span class="line"></span><br><span class="line">有人会说，wait,notify不就是线程本身控制吗？</span><br><span class="line">其实不是，wait是可以让出执行时间，notify后无法获取执行时间，随机等待队列里面获取而已</span><br></pre></td></tr></table></figure></li></ol><h5 id="并发编程进阶"><a href="#并发编程进阶" class="headerlink" title="并发编程进阶"></a>并发编程进阶</h5><ol><li><p><strong>java里面中的锁</strong></p><ol><li><p>悲观锁：</p><p>当线程去操作数据的时候，总认为别的线程会去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞，比如synchronized</p></li><li><p>乐观锁：</p><p>每次去拿数据的时候都认为别人不会修改，更新的时候会判断是别人是否回去更新数据，通过版本来判断，如果数据被修改了（根据version号检查是否被修改）就拒绝更新，比如CAS是乐观锁，但严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现，CAS不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响</p><p>小结：悲观锁适合写操作多的场景，乐观锁适合读操作多的场景，乐观锁的吞吐量会比悲观锁多</p></li><li><p>公平锁：</p><p>指多个线程按照申请锁的顺序来获取锁，简单来说 如果一个线程组里，能保证每个线程都能拿到锁 比如ReentrantLock(底层是同步队列FIFO:First Input First Output来实现)</p></li><li><p>非公平锁：</p><p>获取锁的方式是随机获取的，保证不了每个线程都能拿到锁，也就是存在有线程饿死,一直拿不到锁，比如synchronized、ReentrantLock</p><p>小结：非公平锁性能高于公平锁，更能重复利用CPU的时间</p></li><li><p>自旋锁：</p><p>一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环,任何时刻最多只能有一个执行单元获得锁.<br>小结：不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU<br>常见的自旋锁：TicketLock,CLHLock,MSCLock</p></li><li><p>可重入锁：</p><p>也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;不可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁</span><br><span class="line"></span><br><span class="line">public class ReentrantLock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于记录是不是重入的线程</span><br><span class="line">    private Thread lockedOwner &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;累计加锁次数，加锁一次累加1，解锁一次减少1</span><br><span class="line">    private int lockedCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;进入lock加锁 &quot;+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断是否是同个线程获取锁, 引用地址的比较</span><br><span class="line">        while (isLocked &amp;&amp; lockedOwner !&#x3D; thread )&#123;</span><br><span class="line">            System.out.println(&quot;进入wait等待 &quot;+Thread.currentThread().getName());</span><br><span class="line">            System.out.println(&quot;当前锁状态 isLocked &#x3D; &quot;+isLocked);</span><br><span class="line">            System.out.println(&quot;当前count数量 lockedCount &#x3D;  &quot;+lockedCount);</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;进行加锁</span><br><span class="line">        isLocked &#x3D; true;</span><br><span class="line">        lockedOwner &#x3D; thread;</span><br><span class="line">        lockedCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line">        System.out.println(&quot;进入unlock解锁 &quot;+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;线程A加的锁，只能由线程A解锁，其他线程B不能解锁</span><br><span class="line">        if(thread &#x3D;&#x3D; this.lockedOwner)&#123;</span><br><span class="line">            lockedCount--;</span><br><span class="line">            if(lockedCount &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                isLocked &#x3D; false;</span><br><span class="line">                lockedOwner &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F;唤醒对象锁池里面的一个线程</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    &#x2F;&#x2F;private UnreentrantLock unreentrantLock &#x3D; new UnreentrantLock();</span><br><span class="line">    private ReentrantLock reentrantLock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;加锁建议在try里面，解锁建议在finally</span><br><span class="line">    public void  methodA()&#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            System.out.println(&quot;methodA方法被调用&quot;);</span><br><span class="line">            methodB();</span><br><span class="line"></span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.fillInStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void methodB()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            System.out.println(&quot;methodB方法被调用&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.fillInStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        for(int i&#x3D;0 ;i&lt;10;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;演示的是同个线程</span><br><span class="line">            new Main().methodA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="7"><li><p>不可重入锁：</p><p>若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞</p><p>可重入锁能一定程度的避免死锁 synchronized、ReentrantLock 重入锁</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UnreentrantLock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;进入lock加锁 &quot;+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断是否已经被锁，如果被锁则当前请求的线程进行等待</span><br><span class="line">        while (isLocked)&#123;</span><br><span class="line">            System.out.println(&quot;进入wait等待 &quot;+Thread.currentThread().getName());</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;进行加锁</span><br><span class="line">        isLocked &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line">        System.out.println(&quot;进入unlock解锁 &quot;+Thread.currentThread().getName());</span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;唤醒对象锁池里面的一个线程</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    private UnreentrantLock unreentrantLock &#x3D; new UnreentrantLock();</span><br><span class="line">    &#x2F;&#x2F;加锁建议在try里面，解锁建议在finally</span><br><span class="line">    public void  methodA()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            unreentrantLock.lock();</span><br><span class="line">            System.out.println(&quot;methodA方法被调用&quot;);</span><br><span class="line">            methodB();</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.fillInStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            unreentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void methodB()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            unreentrantLock.lock();</span><br><span class="line">            System.out.println(&quot;methodB方法被调用&quot;);</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.fillInStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            unreentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;演示的是同个线程</span><br><span class="line">        new Main().methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同一个线程，重复获取锁失败，形成死锁，这个就是不可重入锁 private void meathA()&#123;</span><br><span class="line">            &#x2F;&#x2F;获取锁 TODO</span><br><span class="line">        meathB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void meathB()&#123;</span><br><span class="line">           &#x2F;&#x2F;获取锁 TODO</span><br><span class="line">           &#x2F;&#x2F;其他操作</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;同一个线程，重复获取锁失败，形成死锁，这个就是不可重入锁</span><br></pre></td></tr></table></figure></li><li><p>共享锁：</p><p>也叫S锁/读锁，能查看但无法修改和删除的一种数据锁，加锁后其它用户可以并发读取、查询数据，但不能修改，增加，删除数据，该锁可被多个线程所持有，用于资源数据共享</p></li><li><p>互斥锁：</p><p>也叫X锁/排它锁/写锁/独占锁/独享锁/ 该锁每一次只能被一个线程所持有,加锁后任何线程试图再次加锁的线程会被阻塞，直到当前线程解锁。例子：如果 线程A 对 data1 加上排他锁后，则其他线程不能再对 data1 加任何类型的锁,获得互斥锁的线程即能读数据又能修改数据</p></li><li><p>死锁：</p><p>两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法让程序进行下去</p><p>死锁的4个必要条件</p><ul><li><p>互斥条件：资源不能共享，只能由一个线程使用</p></li><li><p>请求与保持条件：线程已经获得一些资源，但因请求其他资源发生阻塞，对已经获得的资源保持不释放</p></li><li><p>不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强行回收，只能由线程使用完自己释放</p></li><li><p>循环等待条件：多个线程形成环形链，每个都占用对方申请的下个资源</p><p>只要发生死锁，上面的条件都成立；只要一个不满足，就不会发生死锁</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;死锁的例子:</span><br><span class="line">public class DeadLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static String locka &#x3D; &quot;locka&quot;;</span><br><span class="line"></span><br><span class="line">    private static String lockb &#x3D; &quot;lockb&quot;;</span><br><span class="line"></span><br><span class="line">    public void methodA()&#123;</span><br><span class="line"></span><br><span class="line">        synchronized (locka)&#123;</span><br><span class="line">            System.out.println(&quot;我是A方法中获得了锁A &quot;+Thread.currentThread().getName() );</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;让出CPU执行权，不释放锁</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            synchronized(lockb)&#123;</span><br><span class="line">                System.out.println(&quot;我是A方法中获得了锁B &quot;+Thread.currentThread().getName() );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void methodB()&#123;</span><br><span class="line">        synchronized (lockb)&#123;</span><br><span class="line">            System.out.println(&quot;我是B方法中获得了锁B &quot;+Thread.currentThread().getName() );</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;让出CPU执行权，不释放锁</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            synchronized(locka)&#123;</span><br><span class="line">                System.out.println(&quot;我是B方法中获得了锁A &quot;+Thread.currentThread().getName() );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        System.out.println(&quot;主线程运行开始运行：&quot;+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        DeadLockDemo deadLockDemo &#x3D; new DeadLockDemo();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            deadLockDemo.methodA();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            deadLockDemo.methodB();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程运行结束：&quot;+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>死锁解决办法：</p><ul><li>调整申请锁的范围</li><li>调整申请锁的顺序</li></ul></li><li><p>下面三种是Jvm为了提高锁的获取与释放效率而做的优化 针对Synchronized的锁升级，锁的状态是通过对象监视器在对象头中的字段来表明，是不可逆的过程，</p><ul><li>偏向锁：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，获取锁的代价更低，</li><li>轻量级锁：当锁是偏向锁的时候，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，但不会阻塞，且性能会高点</li><li>重量级锁：当锁为轻量级锁的时候，其他线程虽然是自旋，但自旋不会一直循环下去，当自旋一定次数的时候且还没有获取到锁，就会进入阻塞，该锁升级为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能也会降低-</li></ul></li><li><p>分段锁、行锁、表锁</p></li></ol><ol start="2"><li><p><strong>对synchronized的了解</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized是解决线程安全的问题，常用在 同步普通方法、静态方法、代码块 中</span><br><span class="line"></span><br><span class="line">非公平、可重入</span><br><span class="line"></span><br><span class="line">每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出一个并唤醒，唤醒哪个线程是不确定的，不保证公平性</span><br><span class="line"></span><br><span class="line">两种形式：</span><br><span class="line">方法：生成的字节码文件中会多一个 ACC_SYNCHRONIZED 标志位，当一个线程访问方法时，会去检查是否存在ACC_SYNCHRONIZED标识，如果存在，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象，也叫隐式同步</span><br><span class="line"></span><br><span class="line">代码块：加了 synchronized 关键字的代码段，生成的字节码文件会多出 monitorenter 和 monitorexit 两条指令，每个monitor维护着一个记录着拥有次数的计数器, 未被拥有的monitor的该计数器为0，当一个线程获执行monitorenter后，该计数器自增1;当同一个线程执行monitorexit指令的时候，计数器再自减1。当计数器为0的时候,monitor将被释放.也叫显式同步</span><br><span class="line"></span><br><span class="line">两种本质上没有区别，底层都是通过monitor来实现同步, 只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看字节码 </span><br><span class="line">javac XXX.java</span><br><span class="line">javap -v XXX.class</span><br></pre></td></tr></table></figure><p>JVM中对象存在形式</p><p><img src="/2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107154251100.png" alt="image-20201107154251100"></p></li><li><p><strong>什么是CAS</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全称是Compare And Swap，即比较再交换，是实现并发应用到的一种技术</span><br><span class="line">底层通过Unsafe类实现原子性操作操作包含三个操作数 —— 内存地址（V）、预期原值（A）和新值(B)。 </span><br><span class="line">如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 ，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</span><br><span class="line"></span><br><span class="line">CAS这个是属于乐观锁，性能较悲观锁有很大的提高</span><br><span class="line">AtomicXXX 等原子类底层就是CAS实现，一定程度比synchonized好，因为后者是悲观锁</span><br></pre></td></tr></table></figure><p><img src="/2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107155044378.png" alt="image-20201107155044378"></p></li><li><p><strong>CAS会存在什么比较严重的问题?</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、自旋时间长CPU利用率增加，CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用</span><br><span class="line"></span><br><span class="line">2、存在ABA问题 </span><br></pre></td></tr></table></figure></li><li><p><strong>ABA问题</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个变量V初次读取是A值，并且在准备赋值的时候也是A值，那就能说明A值没有被修改过吗？其实是不能的，因为变量V可能被其他线程改回A值，结果就是会导致CAS操作误认为从来没被修改过，从而赋值给V</span><br><span class="line"></span><br><span class="line">给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。</span><br><span class="line">在java5中，已经提供了AtomicStampedReference来解决问题，检查当前引用是否等于预期引用，其次检查当前标志是否等于预期标志，如果都相等就会以原子的方式将引用和标志都设置为新值</span><br></pre></td></tr></table></figure><p><img src="C:/Users/tarena/AppData/Roaming/Typora/typora-user-images/image-20201107160211277.png" alt="image-20201107160211277"></p></li><li><p><strong>ReentrantLock和synchronized使用的场景是什么，实现机制有什么不同</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReentrantLock和synchronized都是独占锁</span><br><span class="line">synchronized：</span><br><span class="line">1、是悲观锁会引起其他线程阻塞，java内置关键字，</span><br><span class="line">2、无法判断是否获取锁的状态，锁可重入、不可中断、只能是非公平</span><br><span class="line">3、加锁解锁的过程是隐式的,用户不用手动操作,优点是操作简单但显得不够灵活</span><br><span class="line">4、一般并发场景使用足够、可以放在被递归执行的方法上,且不用担心线程最后能否正确释放锁</span><br><span class="line">5、synchronized操作的应该是对象头中mark word，参考原先原理图片</span><br><span class="line"></span><br><span class="line">ReentrantLock：</span><br><span class="line">1、是个Lock接口的实现类，是悲观锁，</span><br><span class="line">2、可以判断是否获取到锁，可重入、可判断、可公平可不公平</span><br><span class="line">3、需要手动加锁和解锁,且 解锁的操作尽量要放在finally代码块中,保证线程正确释放锁</span><br><span class="line">4、在复杂的并发场景中使用在重入时要却确保重复获取锁的次数必须和重复释放锁的次数一样，否则可能导致 其他线程无法获得该锁。</span><br><span class="line">5、创建的时候通过传进参数true创建公平锁,如果传入</span><br></pre></td></tr></table></figure></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li><p>e</p></li><li></li></ol><h5 id="并发编程底层原理"><a href="#并发编程底层原理" class="headerlink" title="并发编程底层原理"></a>并发编程底层原理</h5><ol><li><p>AQS</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它是一个Java提高的底层同步工具类，比如CountDownLatch、ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>w</p></li><li><p>w</p></li><li><p>w</p></li><li></li></ol><h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><ul><li><p><strong>mysql常用的功能索引有哪些分别在什么场景下使用</strong></p><p><img src="/2020/11/06/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201117142105960.png" alt="image-20201117142105960"></p></li><li><p><strong>Mysql搭建数据库主从复制,会有同步延迟问题，怎么解决</strong></p><ul><li>硬件提升</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">保证性能第一情况下，不能百分百解决主从同步延迟问题，只能增加缓解措施。</span><br><span class="line">现象：主从同步，大数据量场景下，会发现写入主库的数据，在从库没找到。</span><br><span class="line">原因：</span><br><span class="line">1、主从复制是单线程操作，当主库TPS高，产生的超过从库sql线程执行能力</span><br><span class="line">2、从库执行了大的sql操作，阻塞等待</span><br><span class="line">3、服务器硬件问题，如磁盘，CPU,还有网络延迟等</span><br><span class="line">解决办法：</span><br><span class="line">1、业务需要有一定的容忍度，程序和数据库直接增加缓存，降低读压力</span><br><span class="line">2、业务适合的话，写入主库后，再写缓存，读的时候可以读缓存，没命中再读从库</span><br><span class="line">3、读写分离，一主多从，分散主库和从库压力</span><br><span class="line">4、提高硬件配置，比如使用SSD固态硬盘、更好的CPU和网络</span><br><span class="line">5、进行分库分表，减少单机压力</span><br></pre></td></tr></table></figure><ul><li>业务侧解决，比如核心业务强制走主库，结合缓存使用</li></ul></li><li><p><strong>Mysql主从复制数据一致性校验方案怎么做</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mysql主从复制是基于binlog复制，难免出现复制数据不一致的风险，引起用户数据访问前后不一致的风险所以要定期开展主从复制数据一致性的校验并修复，避免这些问题</span><br><span class="line"></span><br><span class="line">解决方案之一，使用Percona公司下的工具</span><br><span class="line">pt-table-checksum工具进行一致性校验</span><br><span class="line"></span><br><span class="line">原理：</span><br><span class="line">主库利用表中的索引，将表的数据切割成一个个chunk(块)，然后进行计算得到checksum值。从库也执相应的操作，并在从库上计算相同数据块的checksum，然后对比主从中各个表的checksum是否一致并存储到数据库，最后通过存储校验结果的表就可以判断出哪些表的数据不一致</span><br><span class="line"></span><br><span class="line">pt-table-sync(在从库执行)工具进行修复不一致数据，可以修复主从结构数据的不一致，也可以修复非主从结构数据表的数据不一致</span><br><span class="line"></span><br><span class="line">原理：在主库上执行数据的更改，再同步到从库上，不会直接更改成从的数据。在主库上执行更改是基于主库现在的数据，也不会更改主库上的数据，可以同步某些表或整个库的数据，但它不同步表结构、索引，只同步不一致的数据</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">默认主库要检查的表在从库都存在，并且同主库表有相同的表结构</span><br><span class="line">如果表中没有索引，pt-table-checksum将没法处理，一般要求最基本都要有主键索引</span><br><span class="line">pt-table-sync工具会修改数据，使用前最好备份下数据，防止误操作</span><br></pre></td></tr></table></figure></li></ul><h5 id="jichu2"><a href="#jichu2" class="headerlink" title="jichu2"></a>jichu2</h5><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h5 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h5><ol><li>什么是正向代理服务器和反向代理服务器？<ul><li>正向代理服务器<ul><li>客户端和目标服务器之间的服务器，客户端向代理发送一个请求指定目标服务器，然后代理向目标服务器请求并获得内容，并返回给客户端，平时说的代理服务器一般是正向代理服务器</li><li>核心：用户知道自己访问的目标服务器</li><li>场景：跳板机、访问原来无法访问的网站, 比如国外的一些站点</li></ul></li><li><ul><li>反向代理服务器（Nginx）<ul><li>客户端和目标服务器之间的服务器，客户端向代理发送一个请求，然后代理向目标服务器请求并获得内容，并返回给客户端。反向代理隐藏了真实的服务器</li><li>核心：客户端不知道要访问的目标服务器是哪台服务器，代理会根据一定的策略选择一个真实的服务器进行请求</li><li>场景：访问淘宝，知道访问的域名是taobao.com， 但是后面提供数据的具体是什么域名或ip我们是不知道的</li></ul></li></ul></li></ul></li></ol><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h3 id="Es"><a href="#Es" class="headerlink" title="Es"></a>Es</h3><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul><li><p><strong>Dubbo的负载均衡策略有哪些？</strong><br>主要有random（随机，这种是默认的负载均衡策略）、RoundRobin （轮询）、LeastActive<br>（最少活跃数）、ConsistentHash（一致性hash）可以在暴露服务的时候使用loadbalance进行<br>指定。</p><ul><li>随机：在一个截面上碰撞的概率高，调用量越大分布越均匀，而且按概率使用权重后也比较均<br>匀，有利于动态调整提供者权重。</li><li>轮询：存在慢的提供者累积请求的问题，一台机器很慢，但没挂，当请求轮询到那台机子就卡在<br>那，久而久之，所有请求都卡在那台服务器上。<br>最少活跃数：使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li><li>一致性hash：当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供<br>者，不会引起剧烈变动。可以方便节点的增加及移除</li></ul></li><li><p><strong>Dubbo服务调用超时怎么办？</strong><br>dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时<br>时间时，就会有重复请求，此时在接口设计的时候，需要考虑接口的幂等性，避免重复调用导致<br>出现脏数据。</p></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p><strong>公司公网网站经常卡顿，经查有些ip对网站发起频繁访问，疑似被黑客攻击，请定位出问题，并解决</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">DATE&#x3D;$(date +%d&#x2F;%b&#x2F;%Y:%H:%M)</span><br><span class="line">NGINX_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log</span><br><span class="line"></span><br><span class="line">#先tail防止文件过大，读取慢，数字可调整每分钟最大的访问量。awk不能直接过滤日志，因为包含特殊字符。</span><br><span class="line"></span><br><span class="line">ABNORMAL_IP&#x3D;$(tail -n5000 $&#123;NGINX_PATH&#125; |grep $DATE |awk</span><br><span class="line">&#39;&#123;a[$1]++&#125;END&#123;for(i in a)if(a[i]&gt;200)print i&#125;&#39;)</span><br><span class="line"></span><br><span class="line">#执行防火墙</span><br><span class="line">if [ ! $ABNORMAL_IP ];then</span><br><span class="line">exit</span><br><span class="line">else</span><br><span class="line">for IP in $ABNORMAL_IP;</span><br><span class="line">do</span><br><span class="line">firewall-cmd --permanent --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source</span><br><span class="line">address&#x3D;&quot;$&#123;IP&#125;&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;80&quot; reject&quot; &amp;&amp; firewall-cmd -</span><br><span class="line">-reload</span><br><span class="line">echo -e &quot;$&#123;IP&#125;\n&quot;</span><br><span class="line">&gt;&gt;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;shell_script&#x2F;nginx_firewall_result.txt</span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#查看防火墙规则</span><br><span class="line">#firewall-cmd --zone&#x3D;public --list-rich-rules</span><br><span class="line">#放开防火墙对ip的限制</span><br><span class="line">#firewall-cmd --permanent --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source</span><br><span class="line">address&#x3D;&quot;$&#123;IP&#125;&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;80&quot; accept&quot; &amp;&amp; firewall-cmd -</span><br><span class="line">-reload</span><br><span class="line">#如果未生效，编辑配置文件</span><br><span class="line">#vi &#x2F;etc&#x2F;firewalld&#x2F;zones&#x2F;public.xml</span><br><span class="line">#重启防火墙服务</span><br><span class="line">#systemctl restart firewalld.service</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java从入门到入土</title>
      <link href="2020/11/05/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
      <url>2020/11/05/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h4 id="接口新特性和日期处理类"><a href="#接口新特性和日期处理类" class="headerlink" title="接口新特性和日期处理类"></a>接口新特性和日期处理类</h4><h5 id="人间迷惑之default关键字"><a href="#人间迷惑之default关键字" class="headerlink" title="人间迷惑之default关键字"></a>人间迷惑之default关键字</h5><ul><li>在jdk1.8以前接⼝⾥⾯是只能有抽象⽅法，不能有任何⽅法的实现。jdk1.8⾥⾯打破了这个规定，引⼊了新的关键字default，使⽤default修饰⽅法，可以在接⼝⾥⾯定义具体的⽅法实现 </li><li>默认⽅法： 接⼝⾥⾯定义⼀个默认⽅法，这个接⼝的实现类实现了这个接⼝之后，不⽤管这个 default修饰的⽅法就可以直接调⽤，即接⼝⽅法的默认实</li><li>静态⽅法: 接⼝名.静态⽅法来访问接⼝中的静态⽅法</li></ul><h5 id="用处不大之base64加解密API"><a href="#用处不大之base64加解密API" class="headerlink" title="用处不大之base64加解密API"></a>用处不大之base64加解密API</h5><ul><li><p>早期java要使⽤Base64的方法</p><ul><li>使⽤JDK⾥sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line"> BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line"> String text = <span class="string">&quot;⼩滴课堂&quot;</span>;</span><br><span class="line"> <span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> <span class="comment">//编码</span></span><br><span class="line"> String encodedText = encoder.encode(textByte);</span><br><span class="line"> System.out.println(encodedText);</span><br><span class="line"> <span class="comment">//解码</span></span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(decoder.decodeBuffer(encodedText),</span><br><span class="line"><span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>缺点：编码和解码的效率⽐较差，公开信息说以后的版本会取消这个⽅法 </p></li><li><p>Apache Commons Codec有提供Base64的编码与解码 </p><p>缺点：是需要引⽤Apache Commons Codec</p></li></ul></li><li><p>jdk8</p><p>不用引包，直接开干</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line">Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">String text = <span class="string">&quot;⼩小滴课堂&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line">String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decode(encodedText), <span class="string">&quot;UTF-</span></span><br><span class="line"><span class="string">8&quot;</span>));</span><br></pre></td></tr></table></figure></li></ul><h5 id="搞不明白之日期处理类"><a href="#搞不明白之日期处理类" class="headerlink" title="搞不明白之日期处理类"></a>搞不明白之日期处理类</h5><ul><li><p>核心类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate：不包含具体时间的⽇日期。</span><br><span class="line">LocalTime：不含⽇日期的时间。</span><br><span class="line">LocalDateTime：包含了日期及时间。</span><br></pre></td></tr></table></figure></li><li><p>常用API</p><p>太多，不po</p></li><li><p>时间日期格式化</p><ul><li>JDK8之前：SimpleDateFormat来进行格式化，但SimpleDateFormat并不是线程安全的</li><li>JDK8之后：引入线程安全的日期与时间DateTimeFormatter</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime ldt &#x3D; LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line">DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String ldtStr &#x3D; dtf.format(ldt);</span><br><span class="line">System.out.println(ldtStr);</span><br></pre></td></tr></table></figure></li><li><p>获取指定的日期时间对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime ldt &#x3D; LocalDateTime.of(2020, 11, 11, 8, 20, 30);</span><br><span class="line">System.out.println(ldt);</span><br></pre></td></tr></table></figure></li><li><p>计算日期时间差</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line">LocalDateTime changeDate = LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>);</span><br><span class="line">System.out.println(changeDate);</span><br><span class="line">Duration duration = Duration.between( today,changeDate);<span class="comment">//第二个参数减第⼀个参数</span></span><br><span class="line">System.out.println(duration.toDays());<span class="comment">//两个时间差的天数</span></span><br><span class="line">System.out.println(duration.toHours());<span class="comment">//两个时间差的⼩小时数</span></span><br><span class="line">System.out.println(duration.toMinutes());<span class="comment">//两个时间差的分钟数</span></span><br><span class="line">System.out.println(duration.toMillis());<span class="comment">//两个时间差的毫秒数</span></span><br><span class="line">System.out.println(duration.toNanos());<span class="comment">//两个时间差的纳秒数</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="我于人间全无敌之optional类"><a href="#我于人间全无敌之optional类" class="headerlink" title="我于人间全无敌之optional类"></a>我于人间全无敌之optional类</h5><ul><li>作用</li></ul><p>​    主要解决的问题是空指针异常（NullPointerException），本质是⼀一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空</p><ul><li><p>创建option实例</p><ul><li><p>of()</p><p>null 值作为参数传递进去,则会抛异常</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt &#x3D; Optional.of(user);</span><br></pre></td></tr></table></figure></li><li><p>ofNullable()</p><p>如果对象即可能是 null 也可能是非 null，应该使用 ofNullable() ⽅方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt &#x3D; Optional.ofNullable(user);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>访问 Optional 对象的值</p><ul><li><p>get() ⽅法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt &#x3D; Optional.ofNullable(student);</span><br><span class="line">Student s &#x3D; opt.get();</span><br></pre></td></tr></table></figure></li><li><p>如果值存在则isPresent()⽅法会返回true，调⽤get()⽅法会返回该对象⼀般使⽤get之前需要 先验证是否有值，不然还会报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Student student = <span class="keyword">null</span>;</span><br><span class="line"> test(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line"> Optional&lt;Student&gt; opt = Optional.ofNullable(student);</span><br><span class="line"> System.out.println(opt.isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>兜底 orElse⽅法 </p><ul><li><p>orElse()如果有值则返回该值，否则返回传递给它的参数值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student student1 &#x3D; null;</span><br><span class="line">Student student2 &#x3D; new Student(2);</span><br><span class="line">Student result &#x3D; Optional.ofNullable(student1).orElse(student2);</span><br><span class="line">System.out.println(result.getAge());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student student &#x3D; null;</span><br><span class="line">int result &#x3D; Optional.ofNullable(student).map(obj-</span><br><span class="line">&gt;obj.getAge()).orElse(4);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h4><ul><li><p>在JDK8之前，Java是不⽀持函数式编程的，所谓的函数编程，即可理解是将⼀个函数（也称为“行为”）作为⼀个参数进行传递， ⾯向对象编程是对数据的抽象（各种各样的POJO类），⽽函数式编 程则是对行为的抽象（将行为作为⼀个参数进行传递）</p></li><li><p>创建线程</p><ul><li><p>jdk8之前</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void run() &#123;</span><br><span class="line"> System.out.println(&quot;⼩滴课堂学习Java架构教程&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>jdk8</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(() -&gt; System.out.println(&quot;⼩滴课堂学习Java架构教程&quot;));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合容器里面的字符串排序 </p><ul><li><p>使用前</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D;Arrays.asList(&quot;aaa&quot;,&quot;ggg&quot;,&quot;ffff&quot;,&quot;ccc&quot;);</span><br><span class="line">Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(String a, String b) &#123;</span><br><span class="line">return b.compareTo(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">for (String string : list) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用后</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D;Arrays.asList(&quot;aaa&quot;,&quot;ggg&quot;,&quot;ffff&quot;,&quot;ccc&quot;);</span><br><span class="line">Collections.sort(list, (a,b)-&gt;b.compareTo(a)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">for (String string : list) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>lambda表达式 使⽤用场景(前提)：⼀一个接⼝口中只包含⼀一个⽅方法，则可以使⽤用Lambda表达式，这样<br>的接⼝口称之为“函数接⼝口” 语法： (params) -&gt; expression</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第⼀部分为括号内⽤逗号分隔的形式参数，参数是函数式接⼝⾥⾯⽅法的参数；第⼆部分为⼀个箭</span><br><span class="line">头符号：-&gt;；第三部分为⽅法体，可以是表达式和代码块</span><br><span class="line">参数列表 ：</span><br><span class="line"> 括号中参数列表的数据类型可以省略不写</span><br><span class="line"> 括号中的参数只有⼀个，那么参数类型和()都可以省略不写</span><br><span class="line">⽅法体：</span><br><span class="line"> 如果&#123;&#125;中的代码只有⼀⾏，⽆论有返回值，可以省略&#123;&#125;，return，分号，要⼀起省略，其他</span><br><span class="line">则需要加上</span><br></pre></td></tr></table></figure><p>​    好处： Lambda 表达式的实现⽅式在本质是以匿名内部类的⽅式进⾏实现，重构现有臃肿代码，更⾼的开发效率，尤其是集合Collection操作的时候，</p></li><li><p>自定义lambda接⼝编程</p><p>⾃定义lambda接⼝流程 </p><ul><li>定义⼀个函数式接⼝ 需要标注此接⼝ @FunctionalInterface，否则万⼀团队成员在接口上加 了其他⽅法则容易出故障 </li><li>编写⼀个⽅法，输⼊需要操做的数据和接口</li><li>在调用⽅法时传⼊数据 和 lambda 表达式，⽤来操作数据</li></ul><p>定义接口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface OperFunction&lt;R,T&gt; &#123;</span><br><span class="line"> R operator(T t1, T t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (Integer x, Integer y) -&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> x * y;</span><br><span class="line"> &#125;));</span><br><span class="line"> </span><br><span class="line"> System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x + y));</span><br><span class="line">System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x - y));</span><br><span class="line">System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x / y));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">operator</span><span class="params">(Integer x, Integer y,OperFunction&lt;Integer, Integer&gt; of)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> of.operator(x, y);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="JDK函数式编程"><a href="#JDK函数式编程" class="headerlink" title="JDK函数式编程"></a>JDK函数式编程</h4><ul><li><p>Lambda表达式必须先定义接⼝，创建相关⽅法之后才可使⽤，这样做⼗分不便，其实java8已经内置了许多接口, 例如下⾯四个功能型接⼝，所以⼀般很少会由⽤户去定义新的函数式接⼝</p></li><li><p>Java8的最⼤大特性就是函数式接口，所有标注了@FunctionalInterface注解的接口都是函数式接口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java8 内置的四⼤核⼼函数式接⼝</span><br><span class="line"></span><br><span class="line">Consumer&lt;T&gt; : 消费型接⼝：有⼊参，⽆返回值</span><br><span class="line"> void accept(T t);</span><br><span class="line"> </span><br><span class="line">Supplier&lt;T&gt; : 供给型接⼝：⽆⼊参，有返回值</span><br><span class="line"> T get();</span><br><span class="line"> </span><br><span class="line">Function&lt;T, R&gt; : 函数型接⼝：有⼊参，有返回值</span><br><span class="line"> R apply(T t);</span><br><span class="line"> </span><br><span class="line">Predicate&lt;T&gt; : 断⾔型接⼝：有⼊参，有返回值，返回值类型确定是boolean</span><br><span class="line"> boolean test(T t);</span><br></pre></td></tr></table></figure></li></ul><h5 id="函数式编程之Function"><a href="#函数式编程之Function" class="headerlink" title="函数式编程之Function"></a>函数式编程之Function</h5><ul><li><p>传⼊⼀个值经过函数的计算返回另⼀个值 </p><p>T：⼊参类型，R：出参类型 </p><p>调⽤⽅法：R apply(T t)</p></li></ul><h5 id="函数式编程之BiFunction"><a href="#函数式编程之BiFunction" class="headerlink" title="函数式编程之BiFunction"></a>函数式编程之BiFunction</h5><h5 id="函数式编程之Comsumer"><a href="#函数式编程之Comsumer" class="headerlink" title="函数式编程之Comsumer"></a>函数式编程之Comsumer</h5><h5 id="函数式编程之Supplier"><a href="#函数式编程之Supplier" class="headerlink" title="函数式编程之Supplier"></a>函数式编程之Supplier</h5><h5 id="函数式编程之Predictate"><a href="#函数式编程之Predictate" class="headerlink" title="函数式编程之Predictate"></a>函数式编程之Predictate</h5>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins持续集成-Git-Gitlab-Sonar</title>
      <link href="2020/11/05/Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-Git-Gitlab-Sonar/"/>
      <url>2020/11/05/Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-Git-Gitlab-Sonar/</url>
      
        <content type="html"><![CDATA[<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="git基本命令"><a href="#git基本命令" class="headerlink" title="git基本命令"></a>git基本命令</h4><h5 id="git入门命令"><a href="#git入门命令" class="headerlink" title="git入门命令"></a>git入门命令</h5><ul><li><p>git –help </p><p>调出Git的帮助文档 </p></li><li><p>git +命令 –help</p><p>查看某个具体命令的帮助文档 </p></li><li><p>git –version</p><p>查看git的版本 </p></li><li><p>git init </p><p>生成空的本地仓库 </p></li><li><p>git add </p><p>将文件添加到暂存区</p></li><li><p>git remote</p><p>用于管理远程仓库</p></li><li><p>git push -u origin master</p><p>往名字为origin的仓库的master分支上提交变更</p></li><li><p>git fetch </p><p>拉取远程仓库的变更到本地仓库</p></li><li><p>git merge origin/master </p><p>将远程的变更，合并到本地仓库的master分支</p></li><li><p>git pull</p><p>不建议使用 等同于fetch之后merge</p></li></ul><h5 id="git文件状态"><a href="#git文件状态" class="headerlink" title="git文件状态"></a>git文件状态</h5><ul><li><p>git status</p><p>用于查看git的状态</p></li><li><p>git rm</p><p>用于git文件的删除操作 如果只是 git rm –cache 仅删除暂存区里的文件 如果不加–cache 会删除工作区里的文件 并提交到暂存区</p></li><li><p>git checkout</p><p>直接加文件名 从暂存区将文件恢复到工作区，如果工作区已经有该文件，则会选择覆盖加了【分支名】 +文件名 则表示从分支名为所写的分支名中拉取文件 并覆盖工作区里的文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建文件---&gt;Untracked </span><br><span class="line">使用add命令将新建的文件加入到暂存区---&gt;Staged </span><br><span class="line">使用commit命令将暂存区的文件提交到本地仓库---&gt;Unmodified </span><br><span class="line">如果对Unmodified状态的文件进行修改---&gt; modified </span><br><span class="line">如果对Unmodified状态的文件进行remove操作---&gt;Untracked</span><br></pre></td></tr></table></figure></li></ul><h5 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h5><ul><li><p>git branch +分支名  </p><p>切换分支 。git branch 不加任何参数，列出所有的分支，分支前面有*号，代表该分支为当前所在分支</p></li><li><p>git branch -d 分支名</p><p>创建分支的时候，分支名不用使用特殊符号 ，不能删除当前所在的分支 </p></li><li><p>git branch -m 旧分支名 新分支名  </p><p>改名</p></li><li><p>git checkout 分支名 </p><p>切换分支，如果在分支上面对文件进行修改之后，没有commit就切换到另外一个分支b， 这个时候会报错，因为没有commit的文件在切换分支之后会不覆盖。所以Git 报错提示。</p></li><li><p>git checkout -f 分支名 </p><p>强制切换到分支，如果当前有为提交的变更，会直接丢弃 -f 参数一定一定要非常非常小心使用，一般情况下不建议使用，除非真的要强制去执行</p></li></ul><h5 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h5><ul><li><p>log命令的作用</p><p>用于查看git的提交历史</p></li><li><p>git log命令显示的信息的具体含义</p><p>commit 4a70ceb24b6849ad830d6af5126c9227b333d2d1 –SHA-1 校验和 commit id Author: wiggin <a href="mailto:&#x7a;&#121;&#x61;&#x69;&#x72;&#x65;&#48;&#48;&#48;&#49;&#64;&#49;&#54;&#51;&#46;&#99;&#111;&#109;">&#x7a;&#121;&#x61;&#x69;&#x72;&#x65;&#48;&#48;&#48;&#49;&#64;&#49;&#54;&#51;&#46;&#99;&#111;&#109;</a> –作者跟邮箱概要信息 Date: Fri Nov 6 11:51:02 2020 +0800 –提交时间</p><p>v2 –commit的时候，使用-m选项说写一段概要说明 日常在使用commit的时候，-m选项所写得内容一定不能随便写 “修改了登陆的bug”–》“新增用户管理中心”</p></li><li><p>git log -数字 </p><p>表示查看最近几次的提交</p></li><li><p>git log -p -2 </p><p>显示最近两次提交的不同点</p></li><li><p>git log –author </p><p>查看具体某个作者的提交</p></li><li><p>git log –oneline </p><p>输出简要的信息</p></li><li><p>git log –graph </p><p>以一个简单的线串联起整个提交历史</p></li><li><p>git log </p><p>输出信息的定制</p></li></ul><h5 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h5><h5 id="分支合并及冲突解决"><a href="#分支合并及冲突解决" class="headerlink" title="分支合并及冲突解决"></a>分支合并及冲突解决</h5><h5 id="git标签"><a href="#git标签" class="headerlink" title="git标签"></a>git标签</h5><h5 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h5><h3 id="Gitlab教程"><a href="#Gitlab教程" class="headerlink" title="Gitlab教程"></a>Gitlab教程</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p>在防火墙里开放http跟ssh端口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install lokkit -y</span><br><span class="line">#GitLab使用postfix发送邮件 </span><br><span class="line">yum install curl openssh-server openssh-clients postfix cronie -y</span><br><span class="line">#启动</span><br><span class="line">systemctl start postfix.service</span><br><span class="line">#设置开机自启动</span><br><span class="line">systemctl enable postfix.service</span><br></pre></td></tr></table></figure></li><li><p>添加gitlab仓库，并安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#下载rpm包(下载地址：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;)</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el7&#x2F;gitlab-ce-10.2.7-ce.0.el7.x86_64.rpm </span><br><span class="line">#安装</span><br><span class="line">rpm -i gitlab-ce-10.2.7-ce.0.el7.x86_64.rpm </span><br><span class="line">#如果报错 policycoreutils-python is needed by gitlab-ce-10.2.7-ce.0.el7.x86_64</span><br><span class="line">yum install policycoreutils-python -y</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置gitlab"><a href="#配置gitlab" class="headerlink" title="配置gitlab"></a>配置gitlab</h4><ol><li><p>基本配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</span><br><span class="line">#修改external_url为gitlab机子的ip+要使用的端口</span><br><span class="line">如：http:&#x2F;&#x2F;192.168.56.101:8888</span><br><span class="line">#修改nginx[&#39;listen_port&#39;] &#x3D; 8888</span><br><span class="line">#重启</span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br><span class="line">#可能配置防火墙</span><br></pre></td></tr></table></figure></li><li><p>配置邮件服务</p><ul><li><p>开启QQ邮箱的smtp服务(不建议使用163邮箱，发几次之后，就不能发送)</p><p>设置–》账户–》smtp–》密保验证–》验证成功返回一串字符串，形状如（ausdixersybgcgid）</p></li><li><p>修改gitlab配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</span><br><span class="line">#放开注释</span><br><span class="line">gitlab_rails[&#39;smtp_enable&#39;] &#x3D; true</span><br><span class="line">gitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.qq.com&quot; #照着改</span><br><span class="line">gitlab_rails[&#39;smtp_port&#39;] &#x3D; 465  #这里默认就行</span><br><span class="line">gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;1234@qq.com&quot;#填写自己的qq邮箱</span><br><span class="line">gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;ausdixersybgcgid&quot;#开通smtp返回的字符</span><br><span class="line">gitlab_rails[&#39;smtp_domain&#39;] &#x3D; &quot;qq.com&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; &quot;login&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; true</span><br><span class="line">gitlab_rails[&#39;smtp_tls&#39;] &#x3D; true</span><br><span class="line"></span><br><span class="line">user[&#39;git_user_email&#39;] &#x3D; &quot;1403780990@qq.com&quot;</span><br><span class="line">gitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &#39;1403780990@qq.com&#39;</span><br><span class="line">按esc退出到命令行模式</span><br><span class="line">之后:wq 保存并退出</span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li><li><p>测试邮件服务是否正常</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-rails console</span><br><span class="line">Notify.test_email(&#39;接收方邮件地址&#39;,&#39;邮件标题&#39;,&#39;邮件内容&#39;).deliver_now</span><br></pre></td></tr></table></figure><p>按回车，测试发送。</p></li></ul></li></ol><h4 id="gitlab分支及标签保护"><a href="#gitlab分支及标签保护" class="headerlink" title="gitlab分支及标签保护"></a>gitlab分支及标签保护</h4><h4 id="gitlab常用命令"><a href="#gitlab常用命令" class="headerlink" title="gitlab常用命令"></a>gitlab常用命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab常用命令：</span><br><span class="line"></span><br><span class="line">gitlab-ctl start    # 启动所有 gitlab 组件；</span><br><span class="line"></span><br><span class="line">gitlab-ctl stop        # 停止所有 gitlab 组件；</span><br><span class="line"></span><br><span class="line">gitlab-ctl restart        # 重启所有 gitlab 组件；</span><br><span class="line"></span><br><span class="line">gitlab-ctl status        # 查看服务状态；</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb        # 修改gitlab配置文件；</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure        # 重新编译gitlab的配置；</span><br><span class="line"></span><br><span class="line">gitlab-rake gitlab:check SANITIZE&#x3D;true --trace    # 检查gitlab；</span><br><span class="line"></span><br><span class="line">gitlab-ctl tail        # 查看日志；</span><br><span class="line"></span><br><span class="line">gitlab-ctl tail nginx&#x2F;gitlab_access.log</span><br><span class="line"></span><br><span class="line">cat &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails&#x2F;VERSION  #查看gitlab版本</span><br></pre></td></tr></table></figure><h4 id="gitlab的备份与恢复"><a href="#gitlab的备份与恢复" class="headerlink" title="gitlab的备份与恢复"></a>gitlab的备份与恢复</h4><ol><li><p>备份</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # 可以将此命令写入crontab，以实现定时备份</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure></li><li><p>恢复</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 停止unicorn和sidekiq，保证数据库没有新的连接，不会有写数据情况</span><br><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br><span class="line"># 进入备份目录进行恢复，1550640732_2019_02_20_11.7.5为备份文件的数字部分</span><br><span class="line">cd &#x2F;var&#x2F;opt&#x2F;gitlab&#x2F;backups</span><br><span class="line">gitlab-rake gitlab:backup:restore BACKUP&#x3D;1550640732_2019_02_20_11.7.5</span><br><span class="line">cd -</span><br><span class="line"># 启动unicorn和sidekiq</span><br><span class="line">gitlab-ctl start unicorn</span><br><span class="line">gitlab-ctl start sidekiq</span><br></pre></td></tr></table></figure></li></ol><h3 id="敏捷持续集成"><a href="#敏捷持续集成" class="headerlink" title="敏捷持续集成"></a>敏捷持续集成</h3><ul><li><p>什么是持续集成？</p><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p></li><li><p>好处</p><p>节省人力成本 加快软件开发进度 实时交付</p></li></ul><h4 id="安装JDK、Maven环境"><a href="#安装JDK、Maven环境" class="headerlink" title="安装JDK、Maven环境"></a>安装JDK、Maven环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">#jdk环境变量</span><br><span class="line">           JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_91</span><br><span class="line">           export JAVA_HOME</span><br><span class="line">           CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib</span><br><span class="line">           export CLASSPATH</span><br><span class="line">           PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$CLASSPATH</span><br><span class="line">           export PATH            </span><br><span class="line">#maven环境变量</span><br><span class="line">        vim &#x2F;etc&#x2F;profile</span><br><span class="line">        在最下面，按i进入insert模式，添加一下内容</span><br><span class="line">           MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.3</span><br><span class="line">           export MAVEN_HOME</span><br><span class="line">           PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin</span><br><span class="line">           export PATH</span><br><span class="line">#使生效</span><br><span class="line">           source &#x2F;etc&#x2F;profile</span><br><span class="line">#java -version 查看jdk是否配置成功</span><br><span class="line">#mvn --help查看Maven是否配置成功</span><br></pre></td></tr></table></figure><h4 id="Maven私服之Nexus安装"><a href="#Maven私服之Nexus安装" class="headerlink" title="Maven私服之Nexus安装"></a>Maven私服之Nexus安装</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><ul><li><p>官网</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.sonatype.com&#x2F;download-oss-sonatype</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>解压</p></li><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改对应的端口</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nexus-3.12.1-01&#x2F;etc&#x2F;nexus-default.properties</span><br><span class="line"># 修改防火墙</span><br><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure></li><li><p>准备</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#新增nexus用户</span><br><span class="line">useradd nexus</span><br><span class="line">#赋权(需要root用户)</span><br><span class="line">chown -R nexus:nexus 安装路径</span><br><span class="line">chown -R nexus:nexus sonatype-work&#x2F;</span><br><span class="line">#切换用户</span><br><span class="line">su nexus</span><br><span class="line">#启动</span><br><span class="line">cd bin&#x2F;.&#x2F;nexus start</span><br><span class="line">#.&#x2F;nexus run可以查看启动日志</span><br></pre></td></tr></table></figure></li><li><p>登陆</p><ul><li>登陆</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.56.102:8081&#x2F; #自己配置的端口</span><br><span class="line">#账号 admin</span><br><span class="line">#密码 admin123</span><br></pre></td></tr></table></figure><ul><li>修改ulimt</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br><span class="line">#新增(需要root用户)</span><br><span class="line">* soft nofile 65535</span><br><span class="line"># * 表示全部用户</span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure><ul><li>配置开机自启动</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br><span class="line">#添加</span><br><span class="line">su - nexus -c &#39;&#x2F;usr&#x2F;local&#x2F;nexus-3.12.1-01&#x2F;bin&#x2F;nexus start&#39;</span><br></pre></td></tr></table></figure></li></ol><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li><p>配置代理</p><p>选择阿里云<a href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a></p></li><li><p>本地maven配置</p><p>修改maven目录下的conf/setting.xml</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;settings xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;settings-1.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;pluginGroups&#x2F;&gt;</span><br><span class="line">  &lt;proxies&#x2F;&gt;</span><br><span class="line">  &lt;servers&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">      &lt;id&gt;xdclass-releases&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;username&gt;admin&lt;&#x2F;username&gt;</span><br><span class="line">      &lt;password&gt;admin123&lt;&#x2F;password&gt;</span><br><span class="line">    &lt;&#x2F;server&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">      &lt;id&gt;xdclass-snapshots&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;username&gt;admin&lt;&#x2F;username&gt;</span><br><span class="line">      &lt;password&gt;admin123&lt;&#x2F;password&gt;</span><br><span class="line">    &lt;&#x2F;server&gt;</span><br><span class="line">  &lt;&#x2F;servers&gt;</span><br><span class="line">  &lt;mirrors&#x2F;&gt;</span><br><span class="line">  &lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;xdclass&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;activation&gt;</span><br><span class="line">        &lt;activeByDefault&gt;false&lt;&#x2F;activeByDefault&gt;</span><br><span class="line">      &lt;&#x2F;activation&gt;</span><br><span class="line">      &lt;!-- 私有库地址--&gt;</span><br><span class="line">      &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">          &lt;id&gt;xdclass&lt;&#x2F;id&gt;</span><br><span class="line">          &lt;url&gt;http:&#x2F;&#x2F;192.168.56.101:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">          &lt;releases&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;&#x2F;enabled&gt;</span><br><span class="line">          &lt;&#x2F;releases&gt;</span><br><span class="line">          &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;&#x2F;enabled&gt;</span><br><span class="line">          &lt;&#x2F;snapshots&gt;</span><br><span class="line">        &lt;&#x2F;repository&gt;</span><br><span class="line">      &lt;&#x2F;repositories&gt;</span><br><span class="line">      &lt;!--插件库地址--&gt;</span><br><span class="line">      &lt;pluginRepositories&gt;</span><br><span class="line">        &lt;pluginRepository&gt;</span><br><span class="line">          &lt;id&gt;xdclass&lt;&#x2F;id&gt;</span><br><span class="line">          &lt;url&gt;http:&#x2F;&#x2F;192.168.56.101:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">          &lt;releases&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;&#x2F;enabled&gt;</span><br><span class="line">          &lt;&#x2F;releases&gt;</span><br><span class="line">          &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;&#x2F;enabled&gt;</span><br><span class="line">          &lt;&#x2F;snapshots&gt;</span><br><span class="line">        &lt;&#x2F;pluginRepository&gt;</span><br><span class="line">      &lt;&#x2F;pluginRepositories&gt;</span><br><span class="line">    &lt;&#x2F;profile&gt;</span><br><span class="line">  &lt;&#x2F;profiles&gt;</span><br><span class="line">  &lt;activeProfiles&gt;</span><br><span class="line">    &lt;activeProfile&gt;xdclass&lt;&#x2F;activeProfile&gt;</span><br><span class="line">  &lt;&#x2F;activeProfiles&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure><ul><li>修改编辑器中maven的配置，将配置指向setting.xml</li><li>修改pom</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--pom.xml 远程仓库的配置  id要跟本地maven的setting.xml相同 --&gt;</span><br><span class="line">  &lt;distributionManagement&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;xdclass-releases&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;name&gt;Ruizhi Release Repository&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;url&gt;http:&#x2F;&#x2F;192.168.56.101:8081&#x2F;repository&#x2F;maven-releases&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        &lt;&#x2F;repository&gt;</span><br><span class="line"></span><br><span class="line">        &lt;snapshotRepository&gt;</span><br><span class="line">            &lt;id&gt;xdclass-snapshots&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;name&gt;Ruizhi Snapshot Repository&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;url&gt;http:&#x2F;&#x2F;192.168.56.101:8081&#x2F;repository&#x2F;maven-snapshots&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        &lt;&#x2F;snapshotRepository&gt;</span><br><span class="line">    &lt;&#x2F;distributionManagement&gt;</span><br></pre></td></tr></table></figure><ul><li><p>测试是否nexus搭建成功</p><p>pom添加本地没有的依赖，看nexus会不会代理 mvn deploy 看是否成功推送至nexus</p></li></ul><p>编译安装mysql</p><ul><li><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install make cmake gcc gcc-c++ bison bison-devel ncurses ncurses-devel autoconf</span><br><span class="line">#下载boost</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;software&#x2F;boost</span><br><span class="line">wget https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;boost&#x2F;files&#x2F;latest&#x2F;download --no-check-certificate</span><br></pre></td></tr></table></figure></li><li><p>添加用户并创建相应目录存放数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd mysql</span><br><span class="line">#改变权限</span><br><span class="line">mkdir data logs temp</span><br><span class="line">chown -R mysql:mysql data logs temp</span><br></pre></td></tr></table></figure></li><li><p>执行cmake</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    cmake \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql-5.7.17 \</span><br><span class="line">        -DMYSQL_UNIX_ADDR&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-5.7.17&#x2F;software&#x2F;mysql.sock \</span><br><span class="line">        -DDEFAULT_CHARSET&#x3D;utf8 \</span><br><span class="line">        -DDEFAULT_COLLATION&#x3D;utf8_general_ci \</span><br><span class="line">        -DWITH_MYISAM_STORAGE_ENGINE&#x3D;1 \</span><br><span class="line">        -DWITH_INNOBASE_STORAGE_ENGINE&#x3D;1 \</span><br><span class="line">        -DWITH_ARCHIVE_STORAGE_ENGINE&#x3D;1 \</span><br><span class="line">        -DWITH_BLACKHOLE_STORAGE_ENGINE&#x3D;1 \</span><br><span class="line">        -DWITH_MEMORY_STORAGE_ENGINE&#x3D;1 \</span><br><span class="line">        -DWITH_READLINE&#x3D;1 \</span><br><span class="line">        -DENABLED_LOCAL_INFILE&#x3D;1 \</span><br><span class="line">        -DMYSQL_DATADIR&#x3D;&#x2F;home&#x2F;mysql&#x2F;data \</span><br><span class="line">        -DMYSQL_USER&#x3D;mysql \</span><br><span class="line">        -DMYSQL_TCP_PORT&#x3D;3306 \</span><br><span class="line">        -DWITH_BOOST&#x3D;&#x2F;usr&#x2F;local&#x2F;software&#x2F;boost_1_59_0</span><br><span class="line">#如果出现</span><br><span class="line">#CMake Error: The source directory &quot;&#x2F;usr&#x2F;local&#x2F;software&#x2F;boost_1_59_0&quot; does not appear to contain CMakeLists.txt.</span><br><span class="line">#可能是mysql版本有问题，下载source code version</span><br><span class="line">#或者重新安装cmake尝试一下</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>修改mysql安装目录权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql-5.7.17</span><br></pre></td></tr></table></figure></li><li><p>初始化mysql</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql-5.7.17 --datadir&#x3D;&#x2F;home&#x2F;mysql&#x2F;data</span><br></pre></td></tr></table></figure><p>产生密码  WfUqwfkdt0&gt;g</p></li><li><p>修改环境变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">#最后一行添加</span><br><span class="line">PATH&#x3D;usr&#x2F;local&#x2F;software&#x2F;mysql-5.7.17&#x2F;lib:$PATH</span><br><span class="line">export PATH</span><br><span class="line">#使生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li><li><p>删除/etc下的my.cnf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm &#x2F;etc&#x2F;my.cnf</span><br><span class="line">#因为会影响mysql的启动</span><br></pre></td></tr></table></figure></li><li><p>复制服务启动脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp usr&#x2F;local&#x2F;software&#x2F;mysql-5.7.17&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysql</span><br></pre></td></tr></table></figure></li><li><p>启动 MySQL 服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure></li><li><p>设置mysql服务开机自启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld.service</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>登陆mysql并设置可远程登陆</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">#修改密码</span><br><span class="line">#先执行 mysqld_safe --skip-grant-tables &amp;   ---（设置成安全模式）&amp;，表示在后台运行   会实现免密登录</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;1998aaaa&#39;)</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;</span><br><span class="line">flush privileges;</span><br><span class="line">#退出</span><br><span class="line">exit</span><br><span class="line">#重新登录</span><br><span class="line">#允许远程登录</span><br><span class="line">GRANT ALL PRIVILEGES ON . TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;1998aaaa&#39; WITH GRANT OPTION;</span><br><span class="line">flush;</span><br><span class="line">#退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#开启防火墙</span><br><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br><span class="line">#加入</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">firewall-cmd --permanent --add-port&#x3D;3306&#x2F;tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li></ul><h4 id="sonarqube安装"><a href="#sonarqube安装" class="headerlink" title="sonarqube安装"></a>sonarqube安装</h4><ul><li><p>解压安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip sonarqube-6.7.4.zip</span><br></pre></td></tr></table></figure></li><li><p>mysql里新增数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE sonar DEFAULT CHARACTER SET utf8;</span><br></pre></td></tr></table></figure></li><li><p>修改sonarqube相应的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改conf目录下的配置文件</span><br><span class="line">vim &#x2F;conf&#x2F;sonar.properties</span><br><span class="line">#放开注释并修改</span><br><span class="line">sonar.jdbc.username&#x3D;root</span><br><span class="line">sonar.jdbc.password&#x3D;#密码</span><br><span class="line">sonar.jdbc.url&#x3D;#改成自己创建的库名</span><br><span class="line">sonar.web.context&#x3D;&#x2F;sonar</span><br><span class="line">sonar.web.host&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure></li><li><p>新增用户，并将目录所属权赋予该用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd sonar chown -R sonar:sonar sonarqube-6.7.4&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>切换用户启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su sonar</span><br><span class="line">#在相应目录下</span><br><span class="line">.&#x2F;sonar.sh start</span><br></pre></td></tr></table></figure></li><li><p>开启防火墙访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.56.101:9000&#x2F;sonar</span><br></pre></td></tr></table></figure></li><li><p>Maven项目以下方式提交</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn sonar:sonar \ -Dsonar.host.url&#x3D;http:&#x2F;&#x2F;192.168.56.101:9000&#x2F;sonar \ -Dsonar.login&#x3D;830edadfcb2c6326b1c6e2110f43c9f74d008450#这是生成的token</span><br></pre></td></tr></table></figure></li><li><p>Jenkins安装</p><ul><li>安装Tomcat</li></ul></li></ul><h4 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h4><ul><li><p>安装Tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd tomcat #新增一个名为tomcat的用户</span><br><span class="line">passwd tomcat #给tomcat用户设置密码</span><br><span class="line">chown -R tomcat:tomcat &#x2F;usr&#x2F;local&#x2F;software&#x2F;apache-tomcat-9.0.39 #将整个目录的所属权转移给tomcat用户、tomcat组</span><br></pre></td></tr></table></figure></li><li><p>安装Jenkins</p><ul><li>将Jenkins上传到tomcat的webapp目录</li></ul></li><li><p>vim conf/server.xml</p><ul><li>访问 <a href="http://192.168.56.101:9999/jenkins/pluginManager/advanced">http://192.168.56.101:9999/jenkins/pluginManager/advanced</a> 拉到最底下将https改成http</li><li>重启tomcat 浏览器打开<a href="http://192.168.56.101:9999/jenkins">http://192.168.56.101:9999/jenkins</a> </li><li>more /home/tomcat/.jenkins/secrets/initialAdminPassword </li></ul></li><li><p>选择默认安装</p></li><li><p>系统管理—&gt;插件管理</p><ul><li>安装Maven Integration plugin –整合Maven</li><li>安装SonarQube Scanner for Jenkins –整合Jenkins</li><li>Publish Over SSH –发布到远程服务器</li></ul></li><li><p>配置</p><ul><li><p>系统配置</p><ul><li><p>配置jdk </p></li><li><p>配置maven </p></li><li><p>配置sonar </p></li><li><p>邮件配置 </p><p>系统管理–&gt;系统设置–&gt;邮件通知-</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smtp服务器 smtp.qq.com </span><br><span class="line">用户默认邮件后缀 @qq.com </span><br><span class="line">勾选ssl </span><br><span class="line">Reply-To Address发件者邮箱 </span><br><span class="line">之后测试一下配置，无误即可</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置gitlab授权</p><p>Credentials–&gt;system–&gt;Global credentials</p></li><li><p>配置免密登陆</p><ul><li>yum -y install openssh-clients </li><li>ssh-keygen -t rsa – 产生私钥 </li><li>配置git登陆 </li><li>将Jenkins所在机子的公钥 more ~/.ssh/id_rsa.pub 的内容拷贝到gitlab项目上</li></ul></li></ul></li></ul><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><h4 id="手动构建"><a href="#手动构建" class="headerlink" title="手动构建"></a>手动构建</h4><h4 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h4><ul><li>分布式任务自动构建</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git gitlab jekenis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习总结</title>
      <link href="2020/11/05/Linux%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>2020/11/05/Linux%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>重启主机：reboot<br>重启网卡：systemctl restart network.service<br>查看ip地址：ip addr<br>清屏:ctrl +l<br>虚拟机克隆后： systemctl restart network.service命令执行会报错，原因是MAC地址不正确，在网卡路径：/etc/sysconfig/network-scripts/ifcfg-enoxxxx修改MAC地址</p><h4 id="linux核心操作"><a href="#linux核心操作" class="headerlink" title="linux核心操作"></a>linux核心操作</h4><h5 id="linux必备基础命令-一"><a href="#linux必备基础命令-一" class="headerlink" title="linux必备基础命令(一)"></a>linux必备基础命令(一)</h5><ul><li>cd命令<br>功能说明：切换目录。<br>举 例：cd /usr/local/；cd ..；cd -（返回上次路径）</li><li>ls命令<br>功能说明：列出目录内容。<br>举 例：ls -ltr ；ls -lrt /home/</li><li>pwd命令<br>功能说明：查询所在目录。<br>举 例： pwd</li><li>cat命令<br>功能说明：查看小文件内容。<br>举 例：cat -n 123.txt</li><li>more命令<br>功能说明：查看大文件内容<br>举 例：more System.map-3.10.0-123.el7.x86_64</li><li>head命令<br>功能说明：查看文件的前面N行。<br>举 例：head -20 System.map-3.10.0-123.el7.x86_64</li><li>tail命令<br>功能说明：查看文件的后面N行。<br>举 例：tail -f access.log ；tail -20 access.log</li><li>touch命令<br>功能说明：创建一个空文件。<br>举 例：touch 123.txt</li><li>mkdir命令<br>功能说明：创建目录。<br>举 例：mkdir -p /tmp/XD/XD/class</li><li>rmdir命令<br>功能说明：删除目录。<br>举 例：rmdir /tmp/XD/XD/class</li><li>cp命令<br>功能说明：拷贝文件。<br>举 例：cp 123.txt class/ ； cp -a 123.txt class/789.txt</li><li>mv命令<br>功能说明：移动或更名现有的文件或目录。<br>举 例：mv 123.txt 345.php ；mv 789.txt /home/987.php</li><li>rm命令<br>功能说明：删除文件或目录。<br>举 例：rm 987.php ；rm -rf 456.txt</li><li>diff命令<br>功能说明：对比文件差异。<br>举 例：diff 123.txt 456.txt</li><li>sh命令<br>功能说明：远程安全登录方式。<br>举 例：ssh 192.168.226.131</li><li>exit命令<br>功能说明：退出命令。<br>举 例：</li><li>id命令<br>功能说明：查看用户。<br>举 例：id root</li><li>uname命令<br>功能说明：查询主机信息。<br>举 例：uname -a</li><li>ping命令</li></ul><h5 id="linux必备基础命令-二"><a href="#linux必备基础命令-二" class="headerlink" title="linux必备基础命令(二)"></a>linux必备基础命令(二)</h5><p>简介：讲解工作中常用的基础命令</p><ul><li><p>ping命令</p><p>功能说明：查看网络是否通。<br>举 例：ping 192.168.226.131</p></li><li><p>echo命令<br>功能说明：标准输出命令。<br>举 例：echo “this is echo 命令”</p></li><li><p>man命令(ls –help)<br>功能说明：查看帮助文档<br>举 例：man ls</p></li><li><p>help命令<br>功能说明：查看内部命令帮助<br>举 例:help if</p></li><li><p>clear命令<br>功能说明：清屏。<br>举 例：clear ; ctrl + l</p></li><li><p>who命令<br>功能说明：当前在本地系统上的所有用户的信息<br>举 例：whoami ; who</p></li><li><p>uptime命令<br>功能说明：查询系统信息<br>举 例：<br>load average: 0.00, 0.01, 0.05 1分钟的负载，5分钟的负载，15分钟的负载</p></li><li><p>w命令<br>功能说明：查询系统信息<br>举 例：w</p></li><li><p>free命令<br>功能说明：查看系统内存<br>举 例：free -h ; free -m</p></li><li><p>wc命令<br>功能说明：统计行。<br>举 例：wc -l 123.txt</p></li><li><p>grep命令<br>功能说明：查找文件里符合条件的字符串。<br>举 例：grep ‘119.4.253.206’ 123.txt | wc -l<br>-n:输出行数 grep -n ‘80.82.70.187’ 123.txt<br>-w:精确匹配 grep -w ‘113.66.107.198’ 123.txt<br>-i:忽略大小写 grep -i ‘IP:113.66.107.198’ 123.txt<br>-v:反向选择 grep -v ‘113.66.107.198’ 123.txt</p></li><li><p>find命令<br>功能说明：查询文件。<br>举 例：find / -name -type f 123.txt</p></li><li><p>uniq命令<br>功能说明：对排序好的内容进行统计<br>举 例：uniq -c 123.txt | sort -n</p></li><li><p>sort命令<br>功能说明：对内容进行排序<br>举 例：uniq -c 123.txt | sort -n</p></li><li><p>df命令<br>功能说明：文件系统的磁盘使用情况统计。<br>举 例：df -h</p></li><li><p>netstat<br>功能说明：查看网络端口的使用情况<br>举 例：netstat -tunlp | grep nginx<br>-t ：显示tcp端口<br>-u ：显示UDP端口<br>-n ：指明拒绝显示别名<br>-l ：指明listen的<br>-p ：指明显示建立相关连接的程序名<br>安装netstat命令：yum -y install net-tools</p></li><li><p>hostname命令<br>功能说明：查看主机名<br>举 例：hostname</p></li><li><p>ps命令<br>功能说明：显示所有进程信息。 ps 与grep 常用组合用法，查找特定进程<br>举 例：ps -ef | grep nginx<br>ps -aux | grep nginx</p></li><li><p>kill命令<br>功能说明：杀进程<br>举 例： kill -9 top</p></li><li><p>top命令<br>功能说明：监控Linux系统状况，比如cpu、内存的使用<br>举 例：按住键盘q退出</p></li><li><p>du命令<br>功能说明：统计大小<br>举 例：du -sh ； du -sm *</p></li><li><p>firewall-cmd命令<br>功能说明：查看防火墙的状态<br>举 例：firewall-cmd –state<br>centos 7 关闭防火墙：systemctl stop firewalld.service</p></li><li><p>echo命令<br>功能说明：判断上一条命令是否正确<br>举 例：echo $?</p></li><li><p>cal命令<br>功能说明：查看日历<br>举 例：cal 2008</p></li></ul><h5 id="linux输入输出错误重定向"><a href="#linux输入输出错误重定向" class="headerlink" title="linux输入输出错误重定向"></a>linux输入输出错误重定向</h5><p>简介：介绍输入输出错误重定向的使用</p><ul><li><p>输入重定向： &lt;</p><p>通俗的讲，输入重定向就是把要输入的信息写入到指定的文件中去</p><p>eg：wc -l &lt; 123.txt</p></li><li><p>输出重定向：&gt; #代表覆盖写入 ； &gt;&gt; #代表追加写入</p><p>通俗的讲，输出重定向就是把要输出的信息写入到一个文件中去，而不是将要输出的文件信息输</p><p>eg： cat &gt;&gt; 123.txt ; cat &gt; 123.txt ; ls -lrt &gt;123.txt ; echo ‘123455’ &gt; 123.txt</p></li><li><p>错误重定向：</p><p>通俗的讲，错误重定向就是把错误的信息写入到一个文件中去</p><p> eg：llll 2&gt; 123.txt ； llll 2&gt; /dev/null #/dev/null 无底洞</p></li><li><p>linux中一切皆文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">posix名称 文件描述符 用途</span><br><span class="line">&#x2F;dev&#x2F;stdin 0 标准输入</span><br><span class="line">&#x2F;dev&#x2F;stdout 1 标准输出</span><br><span class="line">&#x2F;dev&#x2F;stderr 2 标准错误输出</span><br></pre></td></tr></table></figure></li><li><p>几个符号：</p><ul><li>&amp; #代表等同于的 意思 ls -lrt /boot /test 1&gt;/root/123.txt 2&gt;&amp;1</li><li>&amp;&gt; #代表不分正确还是错误的意思 ls -lrt /boot /test &amp;&gt;123.txt</li><li>| #管道符</li><li>; #代表的是可以执行多条命令 cat /etc/passwd | grep root ; ls -lrt</li><li>&amp;&amp; #前面的命令执行成功的话，后面的才可以执行成功；前面的命令执行失败的话，后面的不可以执行</li><li>|| #前面的命令执行成功的话，后面的不可以执行；前面的命令执行失败的话，后面的可以执行</li></ul></li></ul><h4 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h4><p>​    centos7：</p><ul><li><p>/：根目录，一般根目录下只存放目录，不要存放文件，也不要修改，或者删除目录下的内容</p></li><li><p>/mnt：测试目录</p></li><li><p>/root：root用户的家目录</p></li><li><p>/home：普通用户的家目录</p></li><li><p>/tmp：临时目录(比如文件上传时)</p></li><li><p>/var：存放经常修改的数据，比如程序运行的日志文件</p></li><li><p>/boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件</p></li><li><p>/etc：系统默认放置配置文件的地方</p></li><li><p>/bin：所有用户都能执行的程序</p></li><li><p>/sbin：只有root才能执行的程序</p></li><li><p>/usr：用户自己的软件都可以放到这儿来</p></li><li><p>/dev：存放硬件设备的地方(/dev/cdrom)<br>/media：挂载光盘使用的</p></li><li><p>挂载光盘：mount /dev/cdrom /media</p></li><li><p>卸载光盘：umount /dev/cdrom<br>绝对路径：说白了就是完整的路径</p><p>相对路径：相对于当前位置路径 ./ 代表的是当前目录的意思 ../ 代表的是上一级目录的意思</p></li></ul><h4 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h4><h5 id="虚拟机与外部物理机时间同步"><a href="#虚拟机与外部物理机时间同步" class="headerlink" title="虚拟机与外部物理机时间同步"></a>虚拟机与外部物理机时间同步</h5><ul><li><p>卸载的光盘的时候：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost media]# umount &#x2F;dev&#x2F;cdrom</span><br><span class="line">umount: &#x2F;media: target is busy.</span><br><span class="line">(In some cases useful info about processes that use</span><br><span class="line">the device is found by lsof(8) or fuser(1))</span><br></pre></td></tr></table></figure></li><li><p>解决方法：</p><ul><li>首先确认联网状态</li><li>yum install -y psmisc</li><li>fuser -mv /media</li><li>fuser -kv /media</li></ul></li><li><p>date命令</p><ul><li>date “+%Y-%m-%d %H:%M:%S”</li><li>date -s “2020-10-1 22:00:00”</li><li>date -d yesterday “+%Y-%m-%d %H:%M:%S”</li><li>date “+%w”</li></ul></li><li><p>安装VMwareTools</p><ul><li>第一步打开虚拟机，安装VMwareTools使工具软件包下载到光盘</li><li>挂载光盘到linux系统</li><li>cp VMwareTools-10.2.0-7259539.tar.gz /root/</li><li>umount /dev/cdrom</li><li>tar -xf VMwareTools-10.2.0-7259539.tar.gz</li><li>cd vmware-tools-distrib</li><li>yum -y install perl-Data-Dumper</li><li>./vmware-install.pl</li><li>一路按住键盘的 回车 键，选用默认</li><li>echo $? 验证是否安装成功，返回0就是成功</li><li>验证里面虚拟机的时间是否与外部物理机的时间同步</li></ul></li></ul><h5 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h5><ul><li><p>vi的基本概念:（三种模式）</p><ol><li>命令模式</li><li>插入模式</li><li>底行模式</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入插入模式：按住键盘的 i 或者 o 或者 a</span><br><span class="line">进入命令模式：按住键盘的左上角esc键</span><br><span class="line">进入底行模式：前提是得在命令模式，输入 ： 进入</span><br></pre></td></tr></table></figure></li><li><p>在命令行模式中的操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ #移动到这一行的行尾</span><br><span class="line">gg #移动到文档第一行行首</span><br><span class="line">G #移动到文档最后一行行首</span><br><span class="line">x #删除内容，删除一个字符</span><br><span class="line">dd #删除游标所在的那一整行</span><br><span class="line">u #复原原来的操作</span><br><span class="line">v #选中范围按y即复制</span><br><span class="line">p #粘贴</span><br></pre></td></tr></table></figure></li><li><p>在底行模式中的操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n #n为数字。光标移动到第n 行</span><br><span class="line">&#x2F; #寻找内容</span><br><span class="line">%s&#x2F;word1&#x2F;word2&#x2F;g #从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2</span><br><span class="line">n1,n2s&#x2F;word1&#x2F;word2&#x2F;g #n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2</span><br><span class="line">set nu #显示行号</span><br><span class="line">set nonu #取消行号</span><br><span class="line">q! #强制离开不保存</span><br><span class="line">wq #离开并保存</span><br><span class="line">wq! #强制离开并保存</span><br><span class="line">!ls #暂时离开</span><br></pre></td></tr></table></figure></li></ul><h5 id="inux的用户管理与组管理"><a href="#inux的用户管理与组管理" class="headerlink" title="inux的用户管理与组管理"></a>inux的用户管理与组管理</h5><ul><li>linux用户的分类：</li></ul><ol><li>超级用户root：拥有至高无上的权限 UID：0</li><li>普通用户：权限有一定的限制，可以登录系统。一般可以执行/usr/local/bin或者/bin或者/usr/bin或者自己家目录的命令 UID：500 -60000 （centos 6） UID：1000 - 60000（centos7）</li><li>系统用户（伪用户）：一般不会登录系统，一般情况是用来维持某个服务程序 UID ：1-499 （centos6）UID ：1-1000 （centos 7）</li></ol><ul><li><p>关于用户的相关配置文件</p><ul><li><p>账号信息：/etc/passwd</p></li><li><p>密码信息：/etc/shadow</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test :x :1000 :1000 : :&#x2F;home&#x2F;test :&#x2F;bin&#x2F;bash</span><br><span class="line">用户 密码占位符 UID GID 用户描述 用户家目录 登录后使用的shell解释</span><br><span class="line">&#x2F;sbin&#x2F;nologin #是不可登录的</span><br><span class="line">&#x2F;bin&#x2F;bash #可以登录</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加用户命令：useradd</p><ul><li><p>-u #指定用户UID</p></li><li><p>-d #指定用户主目录</p></li><li><p>-g #指定用户所属组</p></li><li><p>-r #指定用户是系统用户</p></li><li><p>-s #用户登录shell解释器</p></li><li><p>-M #不创建主目录<br>eg：创建一个用户XD，指定UID为1010，指定家目录为/home/XD ,指定所属组为root组，指定登录shell为/bin/bash</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -u 1010 -d &#x2F;home&#x2F;XD -g root -s &#x2F;bin&#x2F;bash XD</span><br></pre></td></tr></table></figure></li><li><p>登录用户时出现以下信息如何解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如下：</span><br><span class="line">bash-4.2$</span><br><span class="line">bash-4.2$</span><br><span class="line">解决：复制相关信息到家目录</span><br><span class="line">cp -r &#x2F;etc&#x2F;skel&#x2F;.bash* &#x2F;home&#x2F;XD&#x2F;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除用户命令：userdel</p><ul><li>-r #连同家目录一块删除</li></ul></li><li><p>添加用户组命令：groupadd</p></li><li><p>删除用户组命令：groupdel</p></li><li><p>修改用户的信息命令：usermod</p><ul><li>-u #指定用户UID</li><li>-d #指定用户主目录</li><li>-g #指定用户所属组</li></ul></li><li><p>设置用户密码命令passwd</p><ul><li>passwd XD</li><li>echo “123456” | passwd –stdin XD</li></ul></li></ul><h5 id="文件属性与权限操作"><a href="#文件属性与权限操作" class="headerlink" title="文件属性与权限操作"></a>文件属性与权限操作</h5><ul><li><p>文件的属性：ls -lrti</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">135088935 -rw-------. 1 root root 1778 Oct 1 2020 yum.log第一列：i节点；i节点可以理解文件id，一个i节点号可以对应多个文件，一个文件只能对应一个i节点号</span><br><span class="line">第二列：文件的类型与权限</span><br><span class="line"></span><br><span class="line">- #代表的是文件；d#代表是目录； l #软链接文件 ；b #代表块设备；c #代表的是硬件设备（键盘）</span><br><span class="line">  r：表示读权限 ；w：表示写权限；x：表示执行权限</span><br><span class="line">  4：表示读权限 ；2：表示写权限；1：表示执行权限</span><br><span class="line">  rw-------:分为三列 rw- --- ---，第一列为所属者的权限，第二列为所属组的权限，第三列为其它的权限</span><br><span class="line">  第三列：有多少文件名链接到这个节点</span><br><span class="line">  第四列：文件的所有者</span><br><span class="line">  第五列：文件的所有组</span><br><span class="line">  第六列：容量大小，单位默认为B</span><br><span class="line">  第八列：创建或最近修改的时间</span><br><span class="line">  第九列：文件名</span><br></pre></td></tr></table></figure></li><li><p>链接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">软连接：ln -s</span><br><span class="line">eg：ln -s &#x2F;home&#x2F;XD&#x2F;yum.log &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">i节点号跟源文件不一样，源文件一旦删除，软链接将找不到源文件</span><br><span class="line">硬链接：ln</span><br><span class="line">eg：ln &#x2F;home&#x2F;XD&#x2F;yum.log &#x2F;usr&#x2F;local&#x2F;XD&#x2F;</span><br><span class="line">i节点与源文件一模一样，源文件删除，硬链接还可以继续使用。常用于防止重要文件被误删</span><br></pre></td></tr></table></figure></li><li><p>修改文件的权限命令chmod：</p><ul><li><p>-R #递归的意思</p></li><li><p>chmod -R 777 /home/XD/*</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line">chmod u+x,g+w,o+w boot.log</span><br><span class="line">chmod u-x,g-w,o-w boot.log</span><br><span class="line">chmod 777 boot.log</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改文件的所有者跟所属组命令chown：</p><ul><li>-R #递归的意思</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg：更改文件目录XD 的所属者为root用户 跟 所属组为XD组</span><br><span class="line">chown -R root:XD XD</span><br></pre></td></tr></table></figure></li></ul><h5 id="文件归档与解压缩"><a href="#文件归档与解压缩" class="headerlink" title="文件归档与解压缩"></a>文件归档与解压缩</h5><ul><li><p>文件归档：</p><p>​    文件归档也称之为打包，指的是一个文件或者多个文件或者目录的一个集合，这个集合储存在一个文件中。归档文件是没有进行压缩的，所以占用的空间是所有文件或者目录的总和。工作中经常与压缩结合在一起使用</p></li><li><p>文件压缩：</p><p>节约磁盘空间，加快文件的传输速率</p></li></ul><h6 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h6><ul><li>gzip：不能压缩目录，只能压缩文件，压缩速度最快，但是压缩比例比较低。扩展名：.gz<ul><li>不保留源文件压缩：gzip 123.txt</li><li>保留源文件压缩：gzip -c 345.txt &gt; 345.txt.gz</li><li>不保留源文件的解压：gunzip 123.txt.gz</li><li>保留原文件的解压：gunzip -c 345.txt.gz &gt; 234.txt</li><li>不保留源文件解压：gzip -d 345.txt.gz</li></ul></li><li>xz ：可以压缩目录和文件压缩的速度比较慢，但是压缩比例最高。扩展名：.xz<ul><li>不保留源文件压缩：xz 123.txt</li><li>保留源文件压缩：xz -c 345.txt &gt; 345.txt.xz</li><li>不保留源文件的解压：unxz 345.txt.xz</li><li>保留原文件的解压：xz -d -k 123.txt.xz</li><li>不保留源文件解压：xz -d 123.txt.xz</li></ul></li></ul><h6 id="归档与压缩命令"><a href="#归档与压缩命令" class="headerlink" title="归档与压缩命令"></a>归档与压缩命令</h6><p>​    tar：</p><ul><li><p>-c #创建新文件</p></li><li><p>-f #指定文件格式</p></li><li><p>-v #显示详细过程</p><p>eg：</p><ul><li>tar -cf vmware.tar vmware-tools-distrib；</li><li>tar -cvf vmware-tools.tar vmware-tools-distrib</li></ul></li><li><p>-z #以gzip方式归档压缩 </p><p>eg：</p><ul><li>tar -zcvf vmware-tools.tar.gz vmware-tools-distrib</li></ul></li><li><p>-J #以xz方式进行归档压缩</p><p> eg：</p><ul><li>tar -Jcvf vmware-tools.tar.xz vmware-tools-distrib；</li><li>tar -Jcvf /home/XD/vmware-tools.tar.xz vmware-tools-distrib</li></ul></li><li><p>-v #解档解压操作 </p><ul><li>tar -xf vmware-tools.tar.xz</li></ul></li><li><p>-C #指定解压路径</p></li></ul><h5 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h5><h6 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h6><p>find 路径 选项</p><ul><li><p>-type #根据文件类型 find /var/log -type f -name “*.log” ；</p><p>find /var/log -type d</p></li><li><p><em>-name #根据文件名 find /var/log -type f -name “</em>.log”</p></li><li><p>-perm #根据文件权限 find /var/log -perm 600 -type f -name “*.log”</p></li></ul><p>-user #根据文件所属主 find /var/log -user XD</p><h6 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;var&#x2F;log -type f -name &quot;*.log&quot; -exec wc -l &#123;&#125; \;</span><br><span class="line">; #可以执行多条命令</span><br><span class="line">\ #转义符，转义;使得这条命令结束</span><br><span class="line">&#123;&#125;#把find命令匹配到的每一次结果传递给&#123;&#125;</span><br><span class="line">-exec #执行</span><br><span class="line">eg：</span><br><span class="line">find &#x2F;var&#x2F;log -type f -name &quot;*.log&quot; -exec cp -a &#123;&#125; &#x2F;home&#x2F;test \;</span><br><span class="line">-mtime #根据文件的变更时间来查找；-n表示更改时间距离现在n天以内；+n表示更改时间距离现在n天以前</span><br><span class="line">eg：</span><br><span class="line">find &#x2F;var&#x2F;log -mtime -2 -name &quot;*.log&quot; -exec ls -lrt &#123;&#125; \;</span><br><span class="line">find &#x2F;var&#x2F;log -mtime +2 -name &quot;*.log&quot; -exec ls -lrt &#123;&#125; \;</span><br></pre></td></tr></table></figure><h6 id="CentOS7的防火墙以及selinux"><a href="#CentOS7的防火墙以及selinux" class="headerlink" title="CentOS7的防火墙以及selinux"></a>CentOS7的防火墙以及selinux</h6><ul><li>查看firewalld服务状态<ul><li>systecmctl status firewalld</li></ul></li><li>开启、重启、关闭firewalld服务<ul><li>开启：systemctl start firewalld.service</li><li>关闭：systemctl stop firewalld.service</li><li>重启：systemctl restart firewalld.service</li></ul></li><li>查看firewall防火墙的状态<ul><li>firewall-cmd –state</li></ul></li><li>查看防火墙开放端口规则<ul><li>firewall-cmd –list-port</li></ul></li><li>开放80端口<ul><li>firewall-cmd –permanent –add-port=80/tcp （–permanent永久生效，没有此参数重启后就失效）</li></ul></li><li>加载生效开放的端口<ul><li>firewall-cmd –reload</li></ul></li><li>查询指定端口80是否开放<ul><li>firewall-cmd –query-port=80/tcp</li></ul></li><li>验证80端口是否开放：<ul><li>安装telnet命令：yum -y install xinetd telnet telnet-server （确认联网状态）</li><li>安装netstat与ifconfig命令：yum -y install net-tools（确认联网状态）</li></ul></li><li>关闭80端口<ul><li>firewall-cmd –remove-port=80/tcp</li></ul></li><li>SELinux 的三种工作模式；配置文件路径：/etc/selinux/config<ul><li>enforcing ：强制模式。违反selinux 规则的行为将会被阻止并记录到日志中去</li><li>permissive：宽容模式。违反selinux 规则的行为将会记录到日志中去</li><li>disabled：关闭模式。</li></ul></li></ul><h6 id="服务器之间telnet与scp命令的用法"><a href="#服务器之间telnet与scp命令的用法" class="headerlink" title="服务器之间telnet与scp命令的用法"></a>服务器之间telnet与scp命令的用法</h6><ul><li><p>telnet命令：主要用于测试到某台机器的某个端口是否畅通</p></li><li><p>telnet这个命令是依赖于 xinetd服务于telnet-server服务</p></li><li><p>telnet命令的安装：yum -y install xinetd telnet telnet-server （确认联网状态）</p></li><li><p>telnet命令用法：</p><ul><li>telnet IP地址 端口</li><li>应用场景：测试某个端口是否畅通</li></ul></li><li><p>scp命令：用于服务器之间的文件或者文件目录拷贝</p><ul><li><p>用法1：从本机拷贝文件到别的机器 scp 本机文件的存放路径 root@服务器IP:服务器目标路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp &#x2F;root&#x2F;VMwareTools-10.2.0-7259539.tar.gz root@192.168.72.129:&#x2F;root&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>用法2：从别的机器拷贝文件到本地目录 scp root@服务器IP:服务器目标路径 本机文件的存放路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp root@192.168.72.129:&#x2F;root&#x2F;VMwareTools-10.2.0-7259539.tar.gz &#x2F;root&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>-r参数：递归的作用（可以拷贝目录）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r vmware-tools-distrib root@192.168.72.129:&#x2F;root&#x2F;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="进程管理命令之ps-ef与ps-aux"><a href="#进程管理命令之ps-ef与ps-aux" class="headerlink" title="进程管理命令之ps -ef与ps aux"></a>进程管理命令之ps -ef与ps aux</h6><ul><li><p>ps命令的参数作用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef | more</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">root 2 0 0 Jul30 ? 00:00:00 [kthreadd]</span><br><span class="line">root 3 2 0 Jul30 ? 00:00:06 [ksoftirqd&#x2F;0]</span><br><span class="line">root 5 2 0 Jul30 ? 00:00:00 [kworker&#x2F;0:0H]</span><br><span class="line">root 7 2 0 Jul30 ? 00:00:04 [migration&#x2F;0]</span><br><span class="line">root 8 2 0 Jul30 ? 00:00:00 [rcu_bh]</span><br><span class="line">root 9 2 0 Jul30 ? 00:00:00 [rcuob&#x2F;0]</span><br><span class="line">root 10 2 0 Jul30 ? 00:00:00 [rcuob&#x2F;1]</span><br><span class="line"></span><br><span class="line">#UID：用户ID</span><br><span class="line">#PID：进程ID</span><br><span class="line">#PPID：父进程号</span><br><span class="line">#C：CPU的占用率</span><br><span class="line">#STIME：进程的启动时间</span><br><span class="line">#TTY：TTY终端</span><br><span class="line">#TIME：进程执行起到现在总的CPU占用时间</span><br><span class="line">#CMD：启动这个进程的命令</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps aux | more</span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line">root 2 0.0 0.0 0 0 ? S Jul30 0:00 [kthreadd]</span><br><span class="line">root 3 0.0 0.0 0 0 ? S Jul30 0:06 [ksoftirqd&#x2F;0]</span><br><span class="line">root 5 0.0 0.0 0 0 ? S&lt; Jul30 0:00 [kworker&#x2F;0:0H]</span><br><span class="line">root 7 0.0 0.0 0 0 ? S Jul30 0:04 [migration&#x2F;0]</span><br><span class="line">root 8 0.0 0.0 0 0 ? S Jul30 0:00 [rcu_bh]</span><br><span class="line">root 9 0.0 0.0 0 0 ? S Jul30 0:00 [rcuob&#x2F;0]</span><br><span class="line">root 10 0.0 0.0 0 0 ? S Jul30 0:00 [rcuob&#x2F;1]</span><br><span class="line">root 11 0.0 0.0 0 0 ? S Jul30 0:00 [rcuob&#x2F;2]</span><br><span class="line"></span><br><span class="line">#USER：哪个用户启动了这个命令</span><br><span class="line">#PID：进程的ID</span><br><span class="line">#%CPU：CPU的占用率</span><br><span class="line">#%MEM：内存的使用率</span><br><span class="line">#VSZ：如果一个程序完全驻留在内存中一共需要使用多少内存空间</span><br><span class="line">#RSS：进程当前占用了多少内存</span><br><span class="line">#TTY：tty终端</span><br><span class="line">#STAT：表示当前进程的状态（S#处于休眠的状态；D#不可中断的状态 ；Z#僵尸进程 ；X#死掉的进程）</span><br><span class="line">#START：启动这个命令的时间点</span><br><span class="line">#TIME：进程执行起到现在总的CPU占用时间</span><br><span class="line">#COMMAND：启动这个进程的命令</span><br></pre></td></tr></table></figure><p>一般执行ps -ef 或者ps aux 命令是查看我们的进程是否启动成功，或者找出进程号，对进程的kill强制关闭</p></li></ul><h6 id="处理海量数据之cut命令"><a href="#处理海量数据之cut命令" class="headerlink" title="处理海量数据之cut命令"></a>处理海量数据之cut命令</h6><p>cut应用场景：通常对数据进行列的提取<br>语法：cut [选项]…[file]</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 选项：</span><br><span class="line">-d #指定分割符</span><br><span class="line">-f #指定截取区域</span><br><span class="line">-c #以字符为单位进行分割</span><br><span class="line">注意：不加-d选项，默认为制表符，不是空格</span><br><span class="line">eg:</span><br><span class="line">以&#39;:&#39;为分隔符，截取出&#x2F;etc&#x2F;passwd的第一列跟第三列</span><br><span class="line">cut -d &#39;:&#39; -f 1,3 &#x2F;etc&#x2F;passwd</span><br><span class="line">eg:</span><br><span class="line">以&#39;:&#39;为分隔符，截取出&#x2F;etc&#x2F;passwd的第一列到第三列</span><br><span class="line">cut -d &#39;:&#39; -f 1-3 &#x2F;etc&#x2F;passwd</span><br><span class="line">eg:</span><br><span class="line">以&#39;:&#39;为分隔符，截取出&#x2F;etc&#x2F;passwd的第二列到最后一列</span><br><span class="line">cut -d &#39;:&#39; -f 2- &#x2F;etc&#x2F;passwd</span><br><span class="line">eg:</span><br><span class="line">截取&#x2F;etc&#x2F;passwd文件从第二个字符到第九个字符</span><br><span class="line">cut -c 2-9 &#x2F;etc&#x2F;passwd</span><br><span class="line">eg:</span><br><span class="line">比如领导想叫你截取linux上面所有可登陆普通用户</span><br><span class="line">cat &#x2F;etc&#x2F;passwd | grep &#39;&#x2F;bin&#x2F;bash&#39; | cut -d &#39;:&#39; -f 1 | grep -v root</span><br></pre></td></tr></table></figure><h6 id="处理海量数据之awk命令"><a href="#处理海量数据之awk命令" class="headerlink" title="处理海量数据之awk命令"></a>处理海量数据之awk命令</h6><ul><li><p>awk的简介：一个非常强大的数据处理命令，支持条件判断，数组，循环等功能，与grep，sed被称为linux三剑客</p></li><li><p>awk的应用场景：通常对数据进行列的提取</p><ul><li>语法：<ul><li>awk ‘条件1 {执行动作} 条件2 {执行动作} …’ 文件名</li><li>或awk [选项] ‘条件1 {执行动作} 条件2 {执行动作} …’ 文件名</li></ul></li></ul></li><li><p>特殊要点与举例说明:</p><ul><li><p>printf #格式化输出，不会自动换行。</p></li><li><p>print #打印出内容，默认会自动换行</p></li><li><p>%s #代表字符串</p></li><li><p>\t #制表符</p></li><li><p>\n #换行符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg：printf &#39;%s\t%s\t%s\t%s\t%s\t%s\n&#39; 1 2 3 4 5 6</span><br></pre></td></tr></table></figure></li></ul></li><li><p>awk的一些特殊要点与举例说明</p><ul><li><p>NR #行号</p></li><li><p>$1 #代表第一列</p></li><li><p>$2 #代表第二列</p></li><li><p>$NF#代表最后一列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h | awk &#39;NR&#x3D;&#x3D;4 &#123;print $1&#125;&#39;</span><br><span class="line">df -h | awk &#39;(NR&gt;&#x3D;2 &amp;&amp; NR &lt;&#x3D;5) &#123;print $1&#125;&#39;</span><br><span class="line">df -h | awk &#39;&#123;print $NF&#125;&#39;</span><br></pre></td></tr></table></figure></li><li><p>-F #指定分割符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F&quot;:&quot; &#39;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li><li><p>BEGIN #在读取所有行内容前就开始执行，一般用来初始化操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line">cat &#x2F;etc&#x2F;passwd | awk &#39;BEGIN &#123;FS&#x3D;&quot;:&quot;&#125; &#123;print $1&#125;&#39;</span><br><span class="line">df -h |grep -v &#39;Filesystem&#39; | awk &#39;&#123;printf $1&#125; &#123;printf &quot;文件系统使用率：&quot;&#125; &#123;print $5&#125;&#39;</span><br><span class="line">df -h |grep -v &#39;Filesystem&#39; | awk &#39;BEGIN &#123;printf &quot;文件系统使用情况：\n \n&quot;&#125; &#123;printf $1&#125;</span><br><span class="line">&#123;printf &quot;文 件系统使用率：&quot;&#125; &#123;print $5&#125;&#39;</span><br></pre></td></tr></table></figure></li><li><p>END #结束的时候 执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h |grep -v &#39;Filesystem&#39; | awk &#39;BEGIN &#123;printf &quot;文件系统使用情况：\n \n&quot;&#125; &#123;printf $1&#125;</span><br><span class="line">&#123;printf &quot;文件系统使用率：&quot;&#125; &#123;print $5&#125; END &#123;printf &quot;一切正常 \n&quot;&#125;&#39;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="处理海量数据之sed命令"><a href="#处理海量数据之sed命令" class="headerlink" title="处理海量数据之sed命令"></a>处理海量数据之sed命令</h6><ul><li><p>sed的应用场景：主要对数据进行处理（选取，新增，替换，删除，搜索）<br>sed语法：</p><ul><li>sed [选项] [动作] 文件名</li></ul></li><li><p>常见的选项与参数：</p><ul><li><p>-n #把匹配到的行输出打印到屏幕</p></li><li><p>p #以行为单位进行打印，通常与-n一起使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h | sed -n &#39;2p&#39;</span><br></pre></td></tr></table></figure></li><li><p>d #删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h | sed &#39;2d&#39;</span><br></pre></td></tr></table></figure></li><li><p>a #在行的下面插入新的内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h | sed &#39;2a 1234567890&#39;</span><br></pre></td></tr></table></figure></li><li><p>i #在行的上面插入新的内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;&#x2F;tmpfs&#x2F;p&#39; df.txt</span><br></pre></td></tr></table></figure></li><li><p>c #替换 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h | sed &#39;2i 1234567890&#39;</span><br></pre></td></tr></table></figure></li><li><p>指定字符串替换：s/要被取代的内容/新的字符串/g #指定内容进行替换</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h | sed &#39;2c 1234567890&#39;</span><br></pre></td></tr></table></figure></li><li><p>-i #对源文件进行修改(高危操作，慎用，用之前需要备份源文件)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h | sed &#39;s&#x2F;centos-root&#x2F;Centos7&#x2F;g&#39;</span><br></pre></td></tr></table></figure></li><li><p>搜索：在文件中搜索内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &#39;s&#x2F;Centos7&#x2F;Centos8&#x2F;g&#39; df.txt</span><br></pre></td></tr></table></figure></li><li><p>-e #表示可以执行多条动作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -e &#39;s&#x2F;Centos8&#x2F;Centos7&#x2F;g&#39; -e &#39;s&#x2F;tmpfs&#x2F;TMP&#x2F;g&#39; df.txt &gt;123.tz</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="linux服务器常用企业服务的安装"><a href="#linux服务器常用企业服务的安装" class="headerlink" title="linux服务器常用企业服务的安装"></a>linux服务器常用企业服务的安装</h4><h5 id="Linux下常用软件安装方式"><a href="#Linux下常用软件安装方式" class="headerlink" title="Linux下常用软件安装方式"></a>Linux下常用软件安装方式</h5><h6 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h6><ul><li><p>rpm安装优点：</p><ul><li>软件已经编译打包，所以传输和安装方便，让用户免除编译</li><li>在安装之前，会先检查系统的磁盘、操作系统版本等，避免错误安装</li></ul></li><li><p>rpm安装缺点：</p><ul><li>软件包安装的环境必须与打包时的环境一致或相当</li><li>必须安装了软件的依赖包</li></ul></li><li><p>RPM包的命名规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which-2.20-7.el7.x86_64.rpm</span><br><span class="line">which #代表的是软件名称</span><br><span class="line">2.20 #代表的是软件版本号；</span><br><span class="line">7 #代表的是发布版本号，指的是这个rpm软件包是第几次编译生成的</span><br><span class="line">el7 #代表的是企业版的7操作系统</span><br><span class="line">X86 #代表的是CPU架构</span><br><span class="line">64 #代表的是系统的位数</span><br></pre></td></tr></table></figure></li><li><p>安装rpm软件包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-i #install 安装软件包</span><br><span class="line">-v #输出更多的详情信息</span><br><span class="line">-h #输出哈希标记（#）</span><br><span class="line">--nodeps #不验证软件的依赖</span><br><span class="line">rpm -ivh zsh-5.0.2-7.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mariadb-server-5.5.35-3.el7.x86_64.rpm --nodeps</span><br></pre></td></tr></table></figure></li><li><p>rpm包下载地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;rpmfind.net&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;rpm.pbone.net&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;www.rpmseek.com&#x2F;index.html</span><br></pre></td></tr></table></figure></li><li><p>rpm 查询功能：rpm -q</p><ul><li>-a #查询所有已安装的软件包 rpm -qa zsh</li><li>-f #查询文件所属软件包 rpm -qf /usr/bin/zsh</li><li>-p #查询软件包</li><li>-i #显示软件包信息</li><li>-l #显示软件包中的文件列表</li><li>-d #显示被标注为文档的文件列表</li><li>-c #显示被标注为配置文件的文件列表</li></ul></li><li><p>rpm 包升级:</p><ul><li>-U #升级rpm软件服务<br>rpm -Uvh zsh-5.0.2-7.el7.x86_64.rpm</li></ul></li><li><p>rpm 包卸载:</p><ul><li>-e #卸载<br>rpm -e zsh</li></ul></li></ul><h6 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h6><p>​    yum安装：基于 C/S 架构，yum安装称之为傻瓜式安装<br>​    yum安装优点：方便快捷，不用考虑包依赖，自动下载软件包。<br>​    yum安装缺点：人为无法干预，无法设定想要的参数</p><ul><li><p>配置本地yum源：</p><ul><li><p>配置文件的路径：/etc/yum.repos.d/</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Centos7-yum] #yum源名称，唯一的，用来区分不同的 yum 源</span><br><span class="line">name&#x3D;Centos7-source #对yum源描述信息</span><br><span class="line">baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;mnt #yum源的路径（repodata目录所在的目录）</span><br><span class="line">enabled&#x3D;1 #表示启用 yum 源</span><br><span class="line">gpgcheck&#x3D;0 #为1表示使用公钥检验 rpm 的正确性</span><br></pre></td></tr></table></figure></li></ul></li><li><p>yum安装方式的使用：</p><ul><li>yum repolist #查看yum源列表</li><li>yum clean all #清空之前yum缓存</li><li>yum makecache #创建yum缓存，为后续安装更加快速</li><li>yum -y install #安装软件 yum -y install zsh</li><li>yum info zsh #查看zsh软件包信息（不管安装了没都会有信息）</li><li>yum info installed zsh #查看已经安装好的软件信息</li><li>yum -remove zsh #卸载软件</li><li>yum search gcc #搜索gcc软件</li><li>yum update #升级软件</li></ul></li></ul><h6 id="源码编译安装方式"><a href="#源码编译安装方式" class="headerlink" title="源码编译安装方式"></a>源码编译安装方式</h6><p>​    源码安装优点：编译安装过程，可以设定参数，指定安装目录，按照需求进行安装，指定安装的版本，灵活性比较大。<br>​    源码安装的缺点：需要对依赖包一个一个的进行安装，不敢随便升级，一升级可能会由于依赖包的是不能使用导致一系列连锁反应</p><ul><li>源码编译安装软件包4大步骤：</li></ul><ol><li><p>解压源码包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xf 源码包</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入解压后的目录，用.&#x2F;configure命令来配置相关信息（比如指定安装目录 --</span><br><span class="line">prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx）和生成Makefile文件</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><h5 id="JDK8安装"><a href="#JDK8安装" class="headerlink" title="JDK8安装"></a>JDK8安装</h5><ol><li><p>全局环境变量的配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8 #这个路径要改，其余不需要改</span><br><span class="line">export JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib:$JRE_HOME&#x2F;lib:$CLASSPATH</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>加载环境变量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li><li><p>检查是否安装成功：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li></ol><h5 id="部署tomcat网站服务器"><a href="#部署tomcat网站服务器" class="headerlink" title="部署tomcat网站服务器"></a>部署tomcat网站服务器</h5><ol><li><p>下载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span><br><span class="line">wget http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-8&#x2F;v8.5.43&#x2F;bin&#x2F;apachetomcat-8.5.43.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xf apache-tomcat-8.5.43.tar.gz</span><br><span class="line">mv apache-tomcat-8.5.43 &#x2F;usr&#x2F;local&#x2F;tomcat8</span><br></pre></td></tr></table></figure></li><li><p>tomcat重要目录介绍</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat8]# ls -lrt &#x2F;usr&#x2F;local&#x2F;tomcat8</span><br><span class="line">total 132</span><br><span class="line">drwxr-x---. 7 root root 76 Jul 5 04:53 webapps</span><br><span class="line">-rw-r-----. 1 root root 16262 Jul 5 04:56 RUNNING.txt</span><br><span class="line">-rw-r-----. 1 root root 7139 Jul 5 04:56 RELEASE-NOTES</span><br><span class="line">-rw-r-----. 1 root root 3255 Jul 5 04:56 README.md</span><br><span class="line">-rw-r-----. 1 root root 1726 Jul 5 04:56 NOTICE</span><br><span class="line">-rw-r-----. 1 root root 57011 Jul 5 04:56 LICENSE</span><br><span class="line">-rw-r-----. 1 root root 5407 Jul 5 04:56 CONTRIBUTING.md</span><br><span class="line">-rw-r-----. 1 root root 19534 Jul 5 04:56 BUILDING.txt</span><br><span class="line">drwxr-x---. 2 root root 4096 Aug 1 23:33 lib</span><br><span class="line">drwxr-x---. 2 root root 29 Aug 1 23:33 temp</span><br><span class="line">drwxr-x---. 2 root root 4096 Aug 1 23:33 bin</span><br><span class="line">drwx------. 3 root root 4096 Aug 1 23:43 conf</span><br><span class="line">drwxr-x---. 2 root root 4096 Aug 1 23:43 logs</span><br><span class="line">drwxr-x---. 3 root root 21 Aug 1 23:43 work</span><br><span class="line">bin：存放可执行命令,比如开启和关闭;</span><br><span class="line">conf：配置文件；</span><br><span class="line">Context.xml：Tomcat公用的环境配置，tomcat 服务器会定时去扫描这个文件</span><br><span class="line">web.xml：Web应用程序描述文件，都是关于是Web应用程序的配置文件</span><br><span class="line">server.xml：可以设置tomcat的端口号，添加虚拟机这些的，是对服务器的设置</span><br><span class="line">tomcat-users.xml：用户配置文件</span><br><span class="line">webapps：发布web应用；</span><br><span class="line">lib：库文件；</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>启动tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure></li><li><p>测试能否访问测试页面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP地址:8080</span><br></pre></td></tr></table></figure></li></ol><h5 id="源码部署apache网站服务器-TODO"><a href="#源码部署apache网站服务器-TODO" class="headerlink" title="源码部署apache网站服务器//TODO"></a>源码部署apache网站服务器//TODO</h5><p>​    我已经嗝屁了……..</p><h5 id="源码部署nginx网站服务器"><a href="#源码部署nginx网站服务器" class="headerlink" title="源码部署nginx网站服务器"></a>源码部署nginx网站服务器</h5><ol><li><p>安装gcc编译环境：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++</span><br></pre></td></tr></table></figure></li><li><p>安装zlib-devel库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y zlib-devel</span><br></pre></td></tr></table></figure></li><li><p>安装OpenSSL密码库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure></li><li><p>安装pcre正则表达式库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载地址：https:&#x2F;&#x2F;ftp.pcre.org&#x2F;pub&#x2F;pcre&#x2F;</span><br><span class="line">tar -xf pcre-8.43.tar.gz</span><br><span class="line">cd pcre-8.43</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;pcre</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;pcre</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>下载编译安装nginx：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx下载官网：http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;download.html</span><br><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.0.tar.gz</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">tar -xf nginx-1.16.0.tar.gz</span><br><span class="line">cd nginx-1.16.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --withhttp_</span><br><span class="line">stub_status_module --with-pcre</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>启停nginx服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">测试：</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t</span><br><span class="line">关闭：</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure></li></ol><h5 id="源码安装mysql5-7"><a href="#源码安装mysql5-7" class="headerlink" title="源码安装mysql5.7"></a>源码安装mysql5.7</h5><ol><li><p>关闭selinux，关闭防火墙：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">vi &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line">SELINUX&#x3D;disabled</span><br></pre></td></tr></table></figure></li><li><p>安装cmake工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install cmake</span><br></pre></td></tr></table></figure></li><li><p>下载boost路径（mysql5.7.17的必需依赖组件）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xf boost_1_59_0.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>yum安装其它依赖组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ bzip2 bzip2-devel bzip2-libs python-devel ncurses</span><br><span class="line">ncurses-devel openssl openssl-devel</span><br></pre></td></tr></table></figure></li><li><p>创建路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line">mkdir -p &#x2F;data&#x2F;mydata</span><br></pre></td></tr></table></figure></li><li><p>创建mysql用户：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -M -s &#x2F;sbin&#x2F;nologin mysql</span><br></pre></td></tr></table></figure></li><li><p>使用cmake工具对mysql5.7.17进行环境收集检验与配置相关模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压mysql源码包，并进入解压后的路径</span><br><span class="line">tar -xf mysql-5.7.17.tar.gz</span><br><span class="line">cd mysql-5.7.17</span><br><span class="line">cmake . -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql \-DMYSQL_DATADIR&#x3D;&#x2F;data&#x2F;mydata \-</span><br><span class="line">DSYSCONFDIR&#x3D;&#x2F;etc \-DWITH_INNOBASE_STORAGE_ENGINE&#x3D;1 \-DWITH_ARCHIVE_STORAGE_ENGINE&#x3D;1 \-</span><br><span class="line">DWITH_BLACKHOLE_STORAGE_ENGINE&#x3D;1 \-DWITH_READLINE&#x3D;1 \-DMYSQL_UNIX_ADDR&#x3D;&#x2F;tmp&#x2F;mysql.sock</span><br><span class="line">\-DWITH_SSL&#x3D;system \-DWITH_ZLIB&#x3D;system \-DDEFAULT_CHARSET&#x3D;utf8 \-</span><br><span class="line">DDEFAULT_COLLATION&#x3D;utf8_general_ci \-DDOWNLOAD_BOOST&#x3D;1 \-DWITH_BOOST&#x3D;..&#x2F;boost_1_59_0</span><br><span class="line">\-DENABLE_DOWNLOADS&#x3D;1</span><br><span class="line">参数详细信息解释：</span><br><span class="line">-DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql \ #指定mysql数据库安装目录</span><br><span class="line">-DMYSQL_DATADIR&#x3D;&#x2F;data&#x2F;mydata \ #指定数据库文件路径</span><br><span class="line">-DSYSCONFDIR&#x3D;&#x2F;etc \ #指定配置文件目录</span><br><span class="line">-DWITH_INNOBASE_STORAGE_ENGINE&#x3D;1 \ #安装INNOBASE存储引擎</span><br><span class="line">-DWITH_ARCHIVE_STORAGE_ENGINE&#x3D;1 \ #安装ARCHIVE存储引擎</span><br><span class="line">-DWITH_BLACKHOLE_STORAGE_ENGINE&#x3D;1 \ #安装BLACKHOLE存储引擎</span><br><span class="line">-DWITH_READLINE&#x3D;1 \ #使用readline功能</span><br><span class="line">-DMYSQL_UNIX_ADDR&#x3D;&#x2F;tmp&#x2F;mysql.sock \ #连接文件位置</span><br><span class="line">-DWITH_SSL&#x3D;system \ #表示使用系统上的自带的SSL库</span><br><span class="line">-DWITH_ZLIB&#x3D;system \ #表示使用系统上的自带的ZLIB库</span><br><span class="line">-DDEFAULT_CHARSET&#x3D;utf8 \ #指定默认使用的字符集编码</span><br><span class="line">-DDEFAULT_COLLATION&#x3D;utf8_general_ci \ #指定默认使用的字符集校对规则</span><br><span class="line">-DDOWNLOAD_BOOST&#x3D;1 \</span><br><span class="line">-DWITH_BOOST&#x3D;..&#x2F;boost_1_59_0 \ #指定Boost库的位置，mysql5.7必须添加该参数</span><br><span class="line">-DENABLE_DOWNLOADS&#x3D;1 #支持下载可选文件</span><br></pre></td></tr></table></figure></li><li><p>编译并安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>初始化mysql：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld \--initialize \--user&#x3D;mysql \--basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql \-</span><br><span class="line">-datadir&#x3D;&#x2F;data&#x2F;mydata \--socket&#x3D;&#x2F;tmp&#x2F;mysql.sock</span><br></pre></td></tr></table></figure></li><li><p>对mysql的相关路径进行更改权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql &#x2F;usr&#x2F;local&#x2F;mysql &#x2F;data&#x2F;mydata</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">datadir&#x3D;&#x2F;data&#x2F;mydata</span><br><span class="line">socket&#x3D;&#x2F;tmp&#x2F;mysql.sock</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql.errlog</span><br><span class="line">pid-file&#x3D;&#x2F;data&#x2F;mydata&#x2F;$hostname.pid</span><br></pre></td></tr></table></figure></li><li><p>启停mysql：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost support-files]# .&#x2F;mysql.server start</span><br><span class="line">Starting MySQL.2019-08-03T14:19:37.028727Z mysqld_safe error: log-error set to</span><br><span class="line">&#39;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql.errlog&#39;, however file don&#39;t exists. Create writable for</span><br><span class="line">user &#39;mysql&#39;.</span><br><span class="line">ERROR! The server quit without updating PID file</span><br><span class="line">(&#x2F;data&#x2F;mydata&#x2F;localhost.localdomain.pid).</span><br><span class="line">解决：</span><br><span class="line">touch &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql.errlog</span><br><span class="line">chown -R mysql:mysql &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;log&#x2F;mysql.errlog</span><br><span class="line">启动：</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server start</span><br><span class="line">关闭：</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server stop</span><br></pre></td></tr></table></figure></li><li><p>登录mysql：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql -uroot -p</span><br></pre></td></tr></table></figure></li><li><p>修改mysql密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;密码&#39;);</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">ERROR 1146 (42S02): Table &#39;mysql.servers&#39; doesn&#39;t exist</span><br><span class="line">use mysql;</span><br><span class="line">drop table if exists mysql.servers;</span><br><span class="line">CREATE TABLE &#96;servers&#96; (</span><br><span class="line">&#96;Server_name&#96; char(64) NOT NULL,</span><br><span class="line">&#96;Host&#96; char(64) NOT NULL,&#96;Db&#96; char(64) NOT NULL,</span><br><span class="line">&#96;Username&#96; char(64) NOT NULL,</span><br><span class="line">&#96;Password&#96; char(64) NOT NULL,</span><br><span class="line">&#96;Port&#96; int(4) DEFAULT NULL,</span><br><span class="line">&#96;Socket&#96; char(64) DEFAULT NULL,</span><br><span class="line">&#96;Wrapper&#96; char(64) NOT NULL,</span><br><span class="line">&#96;Owner&#96; char(64) NOT NULL,</span><br><span class="line">PRIMARY KEY (&#96;Server_name&#96;)</span><br><span class="line">) ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;MySQL Foreign Servers table&#39;;</span><br></pre></td></tr></table></figure></li><li><p>添加MySQL服务并设置mysql开机启动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -a &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;mysql</span><br><span class="line">chkconfig --add mysql</span><br><span class="line">chkconfig --list mysql</span><br><span class="line">mysql 0:off 1:off 2:on 3:on 4:on 5:on 6:off</span><br><span class="line">chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息</span><br><span class="line">等级0表示：表示关机</span><br><span class="line">等级1表示：单用户模式</span><br><span class="line">等级2表示：无网络连接的多用户命令行模式</span><br><span class="line">等级3表示：有网络连接的多用户命令行模式</span><br><span class="line">等级4表示：不可用</span><br><span class="line">等级5表示：带图形界面的多用户模式</span><br><span class="line">等级6表示：重新启动</span><br><span class="line">使用mysql服务的方式操作启停mysql服务：</span><br><span class="line">service mysql start #启动mysql服务器</span><br><span class="line">service mysql stop #关闭mysql服务器</span><br><span class="line">service mysql restart #重启mysql服务器</span><br></pre></td></tr></table></figure></li><li><p>设置mysql环境变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;* &#x2F;usr&#x2F;sbin&#x2F;</span><br></pre></td></tr></table></figure></li></ol><h5 id="源码部署php服务与nginx-的整合"><a href="#源码部署php服务与nginx-的整合" class="headerlink" title="源码部署php服务与nginx 的整合"></a>源码部署php服务与nginx 的整合</h5><ol><li><p>源码编译安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装依赖组件：</span><br><span class="line">yum -y install gcc gcc-c++ bzip2 bzip2-devel bzip2-libs python-devel ncurses ncursesdevel</span><br><span class="line">openssl openssl-devel</span><br><span class="line">yum install -y libxml2-devel</span><br><span class="line">解压php并进入解压后php包：tar -xf php-5.5.35.tar.gz &amp;&amp; cd php-5.5.35</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F; --enable-fpm --with-configfile&#x3D;&#x2F;</span><br><span class="line">usr&#x2F;local&#x2F;php&#x2F;etc</span><br><span class="line">编译安装：</span><br><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -a php.ini-production &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php.ini</span><br><span class="line">cp -a &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf.default &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php-fpm.conf</span><br></pre></td></tr></table></figure></li><li><p>启停php服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin&#x2F;php-fpm #启动</span><br><span class="line">php的默认端口是：9000</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin &amp;&amp; pkill php-fpm</span><br></pre></td></tr></table></figure></li><li><p>启停php服务器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin&#x2F;php-fpm #启动</span><br><span class="line">php的默认端口是：9000</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;php&#x2F;sbin &amp;&amp; pkill php-fpm #关闭</span><br></pre></td></tr></table></figure></li><li><p>整合nginx测试php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改nginx配置文件并添加以下内容：vi &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html;</span><br><span class="line">fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">include fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line">修改后对nginx进行重启：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FastCGI是 一个 在HTTP服务器和动态脚本语言间通信的接口</span><br><span class="line">fastcgi_pass 127.0.0.1:9000; #设置监听端口</span><br><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;#设置脚本文件请求的路径</span><br><span class="line">include fastcgi_params; #引入fastcgi的配置文件</span><br></pre></td></tr></table></figure></li><li><p>在nginx的网站发布路径下创建index.php文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.php</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="shell脚本编程"><a href="#shell脚本编程" class="headerlink" title="shell脚本编程"></a>shell脚本编程</h4><ul><li>shell的优点：<ol><li>易用 #直接在linux系统上使用，不需要编译</li><li>高效 #程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务</li><li>简单 #语法和结构比较简单，易于掌握</li></ol></li><li>shell应用场景：<ol><li>监控linux系统的健康度</li><li>数据的处理 #日志的切割、分析、统计等</li><li>与数据库交互 #对数据库进行增，删，改，查等操作</li><li>监控进程，自动化启停服务</li><li>完成一些重复性的工作</li></ol></li></ul><h5 id="企业实战之shell脚本与crontab定时器的运用"><a href="#企业实战之shell脚本与crontab定时器的运用" class="headerlink" title="企业实战之shell脚本与crontab定时器的运用"></a>企业实战之shell脚本与crontab定时器的运用</h5><ul><li><p>crond服务：<br>以守护进程方式在无需人工干预的情况下来处理着一系列作业和指令的服务</p></li><li><p>crond服务的启停命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动</span><br><span class="line">systemctl start crond.service</span><br><span class="line">查看状态：</span><br><span class="line">systemctl status crond.service</span><br><span class="line">停止</span><br><span class="line">systemctl stop crond.service</span><br><span class="line">重新启动</span><br><span class="line">systemctl restart crond.service</span><br></pre></td></tr></table></figure></li><li><p>crontab定时器的使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l #列出crontab有哪些任务</span><br><span class="line">crontab -e #编辑crontab任务</span><br><span class="line">crontab -r #删除crontab里的所有任务</span><br></pre></td></tr></table></figure></li><li><p>crontab的例子<br>略…</p></li><li><p>实战nginx服务器日志定时切割</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Auto cut nginx log script.</span><br><span class="line">#nginx日志路径</span><br><span class="line">logs_path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs</span><br><span class="line">YesterDay&#x3D;$(date -d &#39;yesterday&#39; +%Y-%m-%d)</span><br><span class="line">#移动日志并以日期改名</span><br><span class="line">mv $&#123;logs_path&#125;&#x2F;access.log $&#123;logs_path&#125;&#x2F;access_$&#123;YesterDay&#125;.log</span><br><span class="line">mv $&#123;logs_path&#125;&#x2F;error.log $&#123;logs_path&#125;&#x2F;error_$&#123;YesterDay&#125;.log</span><br><span class="line">#向nginx主进程发送信号，重新生成日志文件</span><br><span class="line">kill -USR1 $(cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid)</span><br></pre></td></tr></table></figure></li></ul><h4 id="企业实战篇"><a href="#企业实战篇" class="headerlink" title="企业实战篇"></a>企业实战篇</h4><h5 id="静态ip地址配置"><a href="#静态ip地址配置" class="headerlink" title="静态ip地址配置"></a>静态ip地址配置</h5><ul><li><p>网卡的路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-enoxxxxxxxx</span><br></pre></td></tr></table></figure></li><li><p>alias命令实现别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">临时设置别名：</span><br><span class="line">alias vinet&#x3D;&#39;vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eno16777728&#39;</span><br><span class="line">查看别名：</span><br><span class="line">alias</span><br><span class="line">取消临时别名：</span><br><span class="line">alias vinet</span><br><span class="line">永久设置别名：vi &#x2F;root&#x2F;.bashrc</span><br><span class="line">alias vinet&#x3D;&#39;vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eno16777728&#39;</span><br><span class="line">加载使立即生效：</span><br><span class="line">source &#x2F;root&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li><li><p>修改ip地址为静态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOTPROTO&#x3D;&quot;static&quot;</span><br><span class="line">IPADDR&#x3D;xxx.xxx.xxx.xxx</span><br><span class="line">GATEWAY&#x3D;xxx.xxx.xxx.xxx</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">ONBOOT&#x3D;&quot;yes&quot;</span><br><span class="line">修改以上信息，以下是我网卡信息</span><br><span class="line">HWADDR&#x3D;&quot;00:0c:29:dc:47:58&quot;</span><br><span class="line">TYPE&#x3D;&quot;Ethernet&quot;</span><br><span class="line">BOOTPROTO&#x3D;&quot;static&quot;</span><br><span class="line">DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">PEERDNS&#x3D;&quot;yes&quot;</span><br><span class="line">PEERROUTES&#x3D;&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">IPADDR&#x3D;192.168.10.100</span><br><span class="line">GATEWAY&#x3D;192.168.10.2</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">IPV6INIT&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF&#x3D;&quot;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_PEERDNS&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_PEERROUTES&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">NAME&#x3D;&quot;eno16777728&quot;</span><br><span class="line">UUID&#x3D;&quot;3199add9-379c-43a9-bab1-ae4e05c0f2cc&quot;</span><br><span class="line">ONBOOT&#x3D;&quot;yes&quot;</span><br></pre></td></tr></table></figure></li><li><p>重启网卡</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure></li><li><p>ping不通域名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ping www.baidu.com</span><br><span class="line">ping: unknown host www.baidu.com</span><br><span class="line">解决：vi &#x2F;etc&#x2F;resolv.conf 加上以下域名服务器解析地址</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 1.1.1.1</span><br></pre></td></tr></table></figure></li></ul><h5 id="实战修改linux系统主机名"><a href="#实战修改linux系统主机名" class="headerlink" title="实战修改linux系统主机名"></a>实战修改linux系统主机名</h5><ul><li><p>查看主机名命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure></li><li><p>修改主机名的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname NEW_NAME</span><br></pre></td></tr></table></figure></li><li><p>修改后记得重启使得生效：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/hosts文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure></li></ul><h5 id="实战ssh免密远程登录其它机器"><a href="#实战ssh免密远程登录其它机器" class="headerlink" title="实战ssh免密远程登录其它机器"></a>实战ssh免密远程登录其它机器</h5><ol><li><p>执行命令创建密钥：ssh-keygen -t rsa</p></li><li><p>拷贝文件到目标服务器并重命名为authorized_keys</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#eg:</span><br><span class="line">scp &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@xdapp2:&#x2F;root&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure></li></ol><h5 id="实战搭建nfs文件共享服务器-TODO"><a href="#实战搭建nfs文件共享服务器-TODO" class="headerlink" title="实战搭建nfs文件共享服务器//TODO"></a>实战搭建nfs文件共享服务器//TODO</h5><p>已经脑死亡了….</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>do do docker</title>
      <link href="2020/11/04/do-do-docker/"/>
      <url>2020/11/04/do-do-docker/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><p>什么是Dokcer？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任</span><br><span class="line">何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口；</span><br><span class="line">使用go语言编写，在LCX（linux容器）基础上进行的封装</span><br><span class="line">简单来说分三点：</span><br><span class="line">1）就是可以快速部署启动应用</span><br><span class="line">2）实现虚拟化，完整资源隔离</span><br><span class="line">3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的</span><br><span class="line">linux&#x2F;Windows&#x2F;unix环境下使用）</span><br></pre></td></tr></table></figure></li><li><p>为什么要用？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就</span><br><span class="line">可以直接启动运行</span><br><span class="line">2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动</span><br><span class="line">3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用</span><br><span class="line">4、更好的资源隔离和共享</span><br></pre></td></tr></table></figure></li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>Windows:</p><p>​    懂的都懂</p></li><li><p>Linux:</p><ul><li><p>centOS版本建议3.8以上(uname -a 查看内核版本)</p></li><li><p>systemctl stop firewalld.service 关闭防火墙避免踩坑</p></li><li><p>vi /etc/selinux/config 关闭selinux</p></li><li><p>安装阿里docker社区版yum源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@zyaire ~]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">[root@zyaire yum.repos.d]#</span><br><span class="line">[root@zyaire yum.repos.d]# wget http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;dockerce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>查看docker安装包：yum list | grep docker</p></li><li><p>安装Docker Ce 社区版本：yum install -y docker-ce.x86_64 </p></li><li><p>设置开机启动：systemctl enable docker </p></li><li><p>更新xfsprogs：yum -y update xfsprogs </p></li><li><p>启动docker：systemctl start docker </p></li><li><p>查看版本：docker version </p></li><li><p>查看详细信息：docker info</p></li></ul><p>DuangDuangDuang, 还有个更简便的安装方法,看:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;help.aliyun.com&#x2F;document_detail&#x2F;51853.html?spm&#x3D;a2c4g.11186623.6.820.RaToNY</span><br></pre></td></tr></table></figure></li></ul><h4 id="入门命令"><a href="#入门命令" class="headerlink" title="入门命令"></a>入门命令</h4><h5 id="查看和删除"><a href="#查看和删除" class="headerlink" title="查看和删除"></a>查看和删除</h5><ul><li><p>查看本地镜像： docker images </p></li><li><p>搜索镜像：docker search centos </p></li><li><p>搜索镜像并过滤是官方的： docker search –filter “is-official=true” centos </p></li><li><p>搜索镜像并过滤大于多少颗星星的：docker search –filter stars=10 centos </p></li><li><p>下载centos7镜像：docker pull centos:7 </p></li><li><p>修改本地镜像名字（小写）：docker tag centos:7 mycentos:1</p></li><li><p>本地镜像的删除：docker rmi centos:7</p></li></ul><h5 id="配置阿里云镜像"><a href="#配置阿里云镜像" class="headerlink" title="配置阿里云镜像"></a>配置阿里云镜像</h5><ul><li>配置步骤参考阿里文档:<a href="https://cr.console.aliyun.com/cnbeijing/instances/mirrors">https://cr.console.aliyun.com/cnbeijing/instances/mirrors</a></li></ul><h5 id="创建查看重启停止"><a href="#创建查看重启停止" class="headerlink" title="创建查看重启停止"></a>创建查看重启停止</h5><ul><li>构建容器：docker run -itd –name=mycentos centos:7 <ul><li>-i ：表示以交互模式运行容器（让容器的标准输入保持打开）</li><li>-d：表示后台运行容器，并返回容器ID </li><li>-t：为容器重新分配一个伪输入终端 { “registry-mirrors”: [“<a href="https://5xok66d4.mirror.aliyuncs.com&quot;]">https://5xok66d4.mirror.aliyuncs.com&quot;]</a> } </li><li>–name：为容器指定名称 查看本地所有的容器：docker ps -a 查看本地正在运行的容器：docker ps </li></ul></li><li>停止容器：docker stop CONTAINER_ID / CONTAINER_NAME </li><li>一次性停止所有容器：docker stop $(docker ps -a -q) </li><li>启动容器：docker start CONTAINER_ID / CONTAINER_NAME </li><li>重启容器：docker restart CONTAINER_ID / CONTAINER_NAME</li><li> 删除容器：docker rm CONTAINER_ID / CONTAINER_NAME </li><li>强制删除容器：docker rmi -f CONTAINER_ID / CONTAINER_NAME </li><li>查看容器详细信息：docker inspect CONTAINER_ID / CONTAINER_NAME </li><li>进入容器：docker exec -it CONTAINER_ID / CONTAINER_NAME /bin/bash</li></ul><h5 id="容器和宿主机之间文件复制与挂载"><a href="#容器和宿主机之间文件复制与挂载" class="headerlink" title="容器和宿主机之间文件复制与挂载"></a>容器和宿主机之间文件复制与挂载</h5><ul><li>从宿主机复制到容器：docker cp 宿主机本地路径 容器名字/ID：容器路径          docker cp /root/123.txt mycentos:/home/</li><li> 从容器复制到宿主机：docker cp 容器名字/ID：容器路径 宿主机本地路径 docker cp mycentos:/home/456.txt /root </li><li>宿主机文件夹挂载到容器里：docker run -itd -v 宿主机路径:容器路径 镜像ID docker run -itd -v /root/mytest/:/home centos:7  (容器和宿主机之间的数据同步更新, 想想数据库吧…)</li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h5 id="构建自定义镜像"><a href="#构建自定义镜像" class="headerlink" title="构建自定义镜像"></a>构建自定义镜像</h5><ul><li><p>commit方法</p><ul><li>构建镜像： docker commit   CONTAINER_ID / CONTAINER_NAME  &lt;镜像名称&gt;:&lt;版本号&gt; <ul><li>a：标注作者 </li><li>-m：说明注释</li></ul></li></ul><p>eg: <code>docker commit -a &quot;XD&quot; -m&quot;mkdir/home/mytest&quot; 4eb9d14ebb18 mycentos:v1</code></p></li><li><p>dockefile方法</p><ul><li><p>构建:docker build -t &lt;name&gt;:&lt;tag&gt;.   (.表示当前路径)</p></li><li><p>镜像分层结构</p><p><img src="/2020/11/04/do-do-docker/image-20201104145416541.png"></p></li><li><p>dockerfile常用指令</p><ul><li>FROM 基于哪个镜像 </li><li>MAINTAINER 注明作者</li><li> COPY 复制文件进入镜像（只能用相对路径，不能用绝对路径） </li><li>ADD 复制文件进入镜像（假如文件是.tar.gz文件会解压） </li><li>WORKDIR： 指定工作目录，假如路径不存在会创建路径 </li><li>ENV 设置环境变量 EXPOSE 暴露容器端口 </li><li>RUN在构建镜像的时候执行，作用于镜像层面 </li><li>ENTRYPOINT 在容器启动的时候执行，作用于容器层，dockerfile里有多条时只允许执行最后一条(优先于cmd执行)</li><li>CMD 在容器启动的时候执行，作用于容器层，dockerfile里有多条时只允许执行最后一条 容器启动后执行默认的命令或者参数，允许被修改 (允许传参,没太搞懂……/bin/bash???)</li><li>命令格式： <ol><li>shell命令格式：RUN yum install -y net-tools</li><li>exec命令格式：RUN [ “yum”,”install” ,”-y” ,”net-tools”]</li></ol></li></ul></li><li><p>dockerfile</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一个</span><br><span class="line">FROM centos:7</span><br><span class="line">RUN echo &quot;images building!&quot;</span><br><span class="line">CMD [&quot;echo&quot;,&quot;container&quot;,&quot;starting...&quot;]</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;,&quot;container&quot;,&quot;starting ！！！&quot;]</span><br><span class="line">#第二个</span><br><span class="line">FROM centos:7</span><br><span class="line">RUN echo &quot;images building!&quot;</span><br><span class="line">CMD [&quot;echo&quot;,&quot;containe1r&quot;,&quot;starting...&quot;]</span><br><span class="line">CMD [&quot;echo&quot;,&quot;container2&quot;,&quot;starting...&quot;]</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;,&quot;container2&quot;,&quot;starting ！！！&quot;]</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;,&quot;container2&quot;,&quot;starting ！！！&quot;]</span><br><span class="line">#第三个</span><br><span class="line">FROM centos:7</span><br><span class="line">CMD [&quot;-ef&quot;]</span><br><span class="line">ENTRYPOINT [&quot;ps&quot;]</span><br><span class="line">#假如执行docker run xxx:xx aux   ps -ef 会变成 ps aux!!!!</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="Docker构建JAVA网站镜像"><a href="#Docker构建JAVA网站镜像" class="headerlink" title="Docker构建JAVA网站镜像"></a>Docker构建JAVA网站镜像</h5><ul><li><p>宿主机配置java环境:  有手就行,快上车不解释</p></li><li><p>安装tomcat</p></li><li><p>构建镜像:docker build -t mycentos:jdk</p></li><li><p>dockerfile </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">ADD jdk-8u211-linux-x64.tar.gz &#x2F;usr&#x2F;local</span><br><span class="line">RUN mv &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_211 &#x2F;usr&#x2F;local&#x2F;jdk</span><br><span class="line">ENV JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk</span><br><span class="line">ENV JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</span><br><span class="line">ENV CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib:$JRE_HOME&#x2F;lib:$CLASSPATH</span><br><span class="line">ENV PATH&#x3D;$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$PATH</span><br><span class="line">ADD apache-tomcat-8.5.35.tar.gz &#x2F;usr&#x2F;local</span><br><span class="line">RUN mv &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.35 &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;catalina.sh&quot;,&quot;run&quot;]</span><br></pre></td></tr></table></figure></li><li><p>启动容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -itd -p 80:8080 -v &#x2F;root&#x2F;test&#x2F;ROOT:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT</span><br><span class="line">mycentos:jdk &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li><li><p>踩坑:</p><p>出现iptables错误的时候打开防火墙, 以及tomcat要以前台方式启动(./catalina.sh)</p></li></ul><h5 id="Docker构建nginx镜像"><a href="#Docker构建nginx镜像" class="headerlink" title="Docker构建nginx镜像"></a>Docker构建nginx镜像</h5><ul><li><p>dockerfile</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">ADD nginx-1.16.0.tar.gz &#x2F;usr&#x2F;local</span><br><span class="line">COPY nginx_install.sh &#x2F;usr&#x2F;local</span><br><span class="line">RUN sh &#x2F;usr&#x2F;local&#x2F;nginx_install.sh</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></li><li><p>安装nginx脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">yum install -y gcc gcc-c++ make pcre pcre-devel zlib zlib-devel</span><br><span class="line">#安装nginx依赖</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx-1.16.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>制作nginx镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t mycentos:nginx</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><ul><li>在容器里nginx是以daemon方式启动，退出容器时，nginx程序也会随着停止：/usr/local/nginx/sbin/nginx</li><li>使用前台方式永久运行：/usr/local/nginx/sbin/nginx -g “daemon off;”</li></ul></li><li><p>检查验证:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -itd -p 80:80 mycentos:nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Docker构建redis镜像"><a href="#Docker构建redis镜像" class="headerlink" title="Docker构建redis镜像"></a>Docker构建redis镜像</h5><ul><li><p>dockerfile</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">yum install -y gcc gcc-c++ make openssl openssl-devel</span><br><span class="line">cd &#x2F;home&#x2F;redis-4.0.9</span><br><span class="line">make &amp;&amp; make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;</span><br><span class="line">cp &#x2F;home&#x2F;redis-4.0.9&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;</span><br><span class="line">#sed -i &#39;69s&#x2F;127.0.0.1&#x2F;0.0.0.0&#x2F;&#39; &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br><span class="line">#sed -i &#39;88s&#x2F;protected-mode yes&#x2F;protected-mode no&#x2F;&#39; &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br><span class="line">#sed -i 表示修改源文件,不安全所以不建议</span><br></pre></td></tr></table></figure></li><li><p>安装redis脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">ADD redis-4.0.9.tar.gz &#x2F;home</span><br><span class="line">COPY redis_install.sh &#x2F;home</span><br><span class="line">RUN sh &#x2F;home&#x2F;redis_install.sh</span><br><span class="line">ENTRYPOINT &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li><p>测试redis</p><ul><li>启动容器：docker run -itd -p 6380:6379 mycentos:redis #6380是宿主机端口，6379是容器的端口 </li><li>进入容器：docker exec -it 9b402baeaba7 /bin/bash </li><li>宿主机连接redis： /usr/local/redis/bin/redis-cli -p 6380 </li><li>验证：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@zyaire home]# &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; set name mytest</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get name</span><br><span class="line">&quot;mytest&quot;</span><br><span class="line">127.0.0.1:6380&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="Docker构建mysql镜像"><a href="#Docker构建mysql镜像" class="headerlink" title="Docker构建mysql镜像"></a>Docker构建mysql镜像</h5><ul><li><p>启动命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD&#x3D;abc123456 -d mysql:5.7</span><br><span class="line">#-e MYSQL_ROOT_PASSWORD&#x3D;abc123456  指定root用户密码</span><br></pre></td></tr></table></figure></li><li><p>进入容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 4336ae28fbfa env LANG&#x3D;C.UTF-8 &#x2F;bin&#x2F;bash</span><br><span class="line">#env LANG&#x3D;C.UTF-8 设置中文,否则中文字符不会显示(小坑!!!因为pull下来的mysql:5.7 默认镜像FROM Debian)</span><br></pre></td></tr></table></figure></li><li><p>dockerfile</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM mysql:5.7</span><br><span class="line">WORKDIR &#x2F;docker-entrypoint-initdb.d</span><br><span class="line">ENV LANG&#x3D;C.UTF-8</span><br><span class="line">ADD init.sql .</span><br><span class="line">#ADD会执行这个sql,而copy不会,因此不能替换成COPY。并且因为指定了WORKDIR,所以ADD的路径为&lt;.&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="docker网络模式"><a href="#docker网络模式" class="headerlink" title="docker网络模式"></a>docker网络模式</h4><ul><li><p>模式介绍：</p><ul><li><p>bridge：桥接模式 </p></li><li><p>host：主机模式 </p></li><li><p>none：无网络模式</p><p>查看网络模式：docker network ls</p></li></ul></li><li><p>bridge模式</p><ul><li>容器有自己的ip，外部无法直接访问</li><li>route  -n：查看路由表（可能需要安装 yum install  -y  net-tools）</li><li>brctl show：查看桥接关系（安装yum install -y bridge-utils）</li></ul></li><li><p>host模式</p><ul><li><p>容器没有自己的ip（使用宿主机的ip，因此网络比桥接模式好，但是会占用宿主机端口，网络隔离性差一点）</p></li><li><p>docker启动命令加上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--net&#x3D;host</span><br></pre></td></tr></table></figure><p>表示以host模式启动</p></li></ul></li><li><p>none模式:</p><p>​    用于测试和个人学习，同样在启动命令加上–net=none表示以none模式启动，docker inspect CONTAINER_ID/CONTAINER_NAME 是看不到容器ip的。</p></li></ul><h5 id="docker容器间基于link实现单向通讯"><a href="#docker容器间基于link实现单向通讯" class="headerlink" title="docker容器间基于link实现单向通讯"></a>docker容器间基于link实现单向通讯</h5><p>​    可以用于多台tomcat和数据库通讯。(因为mysql挂掉之后重启，docker会重新分配ip，docker启动mysql容器时可以–name=mydb指定名称，tomcat容器直接ping mydb就行，就不用在乎ip）</p><ul><li><p>启动mysql数据库容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mydb -e MYSQL_ROOT_PASSWORD&#x3D;abc123456 -d mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>启动tomcat应用容器并link到mysql数据库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -itd --name tomcat1 --link mydb tomcat:&lt;tag&gt;</span><br></pre></td></tr></table></figure></li><li><p>mysql容器里是ping不通tomcat容器的</p><p>mysql容器里需要安装ping命令———前面已经说过mysql容器构建镜像不是centOS</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install iputils-ping</span><br></pre></td></tr></table></figure></li></ul><h5 id="docker容器间利用bridge实现双向通讯"><a href="#docker容器间利用bridge实现双向通讯" class="headerlink" title="docker容器间利用bridge实现双向通讯"></a>docker容器间利用bridge实现双向通讯</h5><ul><li><p>创建一个新的网桥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge BRIDGE_NAME</span><br></pre></td></tr></table></figure></li><li><p>启动第一个容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -itd --name tomcat centos:7 </span><br></pre></td></tr></table></figure></li><li><p>启动第二个容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -itd --name redis centos:7 </span><br></pre></td></tr></table></figure></li><li><p>把第一个容器加入网桥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network connect my_bridge tomcat </span><br></pre></td></tr></table></figure></li><li><p>把第二个容器加入网桥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network connect my_bridge redis </span><br></pre></td></tr></table></figure></li><li><p>最后分别进入俩个容器中进行验证</p></li></ul><h5 id="docker容器的特权模式"><a href="#docker容器的特权模式" class="headerlink" title="docker容器的特权模式"></a>docker容器的特权模式</h5><p>特权模式可以做一些连root权限都做不到的骚操作，比如删除网卡</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route del default gw 172.17.0.1</span><br></pre></td></tr></table></figure><p>具体方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -itd --privileged&#x3D;true --name CONTAINER_NAME centos:7 &#x2F;bin&#x2F;bash</span><br><span class="line">#--privileged&#x3D;true 表示以特权模式启动</span><br></pre></td></tr></table></figure><h5 id="docker必备之Volume数据共享"><a href="#docker必备之Volume数据共享" class="headerlink" title="docker必备之Volume数据共享"></a>docker必备之Volume数据共享</h5><p>​    简单来说就是挂载</p><ul><li><p>dockerfile：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">VOLUME [&quot;&#x2F;usr&#x2F;local&quot;]</span><br></pre></td></tr></table></figure><p>注意在dockerfile里设置volume点是无法在宿主机修改挂载路径的</p></li><li><p>使用–volumes-from 实现容器与容器之间volume共享</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#eg：</span><br><span class="line">docker run -itd -p 8081:80 --volumes-from nginx1 --name nginx2 mycentos:nginx</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用docker inspect CONTANINER_ID 可以查看详细的挂载信息</p></li></ul><h4 id="compose操作容器"><a href="#compose操作容器" class="headerlink" title="compose操作容器"></a>compose操作容器</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><ul><li><p>安装pip工具 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需要有python环境 </span><br><span class="line">#python -V查看python版本</span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y python-pip</span><br><span class="line">#可以先执行 pip install --upgrade pip 升级pip</span><br></pre></td></tr></table></figure><p>安装pip出错解决办法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo </span><br></pre></td></tr></table></figure><p>修改配置文件，注释掉metalink ，取消注释 baseurl</p></li><li><p>安装docker-compose </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple docker-compose&#x3D;&#x3D;1.24.1</span><br><span class="line"># -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 指定清华镜像源</span><br></pre></td></tr></table></figure></li><li><p>检查docker-compose是否安装成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure></li></ul><h5 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h5><ul><li><p>编写简单的yml文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">#version表示yml版本（有三个），建议3</span><br><span class="line">services:</span><br><span class="line">redis:</span><br><span class="line">image: mycentos:redis</span><br><span class="line">#注意yml文件格式</span><br></pre></td></tr></table></figure></li><li><p>compose操作容器（<strong>一定要配置文件目录下操作</strong>） </p><ul><li><p>后台启动容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d </span><br></pre></td></tr></table></figure></li><li><p>查看容器运行情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose ps </span><br></pre></td></tr></table></figure></li><li><p>停止并删除容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down </span><br></pre></td></tr></table></figure></li><li><p>停止并删除容器并删除volume：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down --volumes </span><br></pre></td></tr></table></figure></li><li><p>停止启动容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">docker-compose start</span><br></pre></td></tr></table></figure></li><li><p>docker-compose exec的使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose exec redis bash</span><br><span class="line">#docker-compose exec CONTAINER_NAME&#x2F;CONTAINER_ID bash</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><ul><li><p>核心技能</p><ul><li>docker-compose.yml的三大部分：version，services，networks，最关键是services和networks两个部分 </li><li>compose设置网络模式 </li><li>compose使用端口映射 </li><li>compose设置文件共享 </li><li>compose管理多个容器 </li><li>docker-compose.yml</li></ul></li><li><p>yml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">nginx:</span><br><span class="line">image: mycentos:nginx</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">volumes:</span><br><span class="line">- &#x2F;home:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html</span><br><span class="line">- &#x2F;var&#x2F;logs&#x2F;nginx&#x2F;logs:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs</span><br><span class="line">command: &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -g &quot;daemon off;&quot;</span><br><span class="line">redis:</span><br><span class="line">image: mycentos:redis</span><br><span class="line">ports:</span><br><span class="line">- &quot;6380:6379&quot;</span><br></pre></td></tr></table></figure></li></ul><h5 id="搭建简单个人博客"><a href="#搭建简单个人博客" class="headerlink" title="搭建简单个人博客"></a>搭建简单个人博客</h5><p>​    快速搭建WordPress个人博客</p><ul><li><p>官网：<a href="https://docs.docker.com/compose/wordpress/">https://docs.docker.com/compose/wordpress/</a></p></li><li><p>docker-compose.yml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3.3&#39;</span><br><span class="line">services:</span><br><span class="line">    db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    volumes:</span><br><span class="line">        - db_data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">        MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">        MYSQL_DATABASE: wordpress</span><br><span class="line">        MYSQL_USER: wordpress</span><br><span class="line">        MYSQL_PASSWORD: wordpress</span><br><span class="line">  </span><br><span class="line">    wordpress:</span><br><span class="line">    depends_on:</span><br><span class="line">        - db</span><br><span class="line">    image: wordpress:latest</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;8000:80&quot;</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">        WORDPRESS_DB_HOST: db:3306</span><br><span class="line">        WORDPRESS_DB_USER: wordpress</span><br><span class="line">        WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">        WORDPRESS_DB_NAME: wordpress</span><br><span class="line">volumes:</span><br><span class="line">    db_data: &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动wordpress：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d </span><br></pre></td></tr></table></figure></li><li><p>打开浏览器访问：IP:8000 </p></li><li><p>进行安装配置 </p></li><li><p>将删除容器和默认网络，但会保留WordPress数据库： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down </span><br></pre></td></tr></table></figure></li><li><p>将删除容器，默认网络和WordPress数据库： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down --volumes</span><br></pre></td></tr></table></figure></li></ul><h5 id="docker-compose-yml文件解析"><a href="#docker-compose-yml文件解析" class="headerlink" title="docker-compose.yml文件解析"></a>docker-compose.yml文件解析</h5><ul><li><p>docker-compose.yml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3.3&#39;</span><br><span class="line">services:</span><br><span class="line">db:</span><br><span class="line">image: mysql:5.7</span><br><span class="line">volumes:</span><br><span class="line">- db_data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">#采用的是卷标的形式挂载（注意：- db_data是参数，可以变，自定义，必须与下面对应）</span><br><span class="line">restart: always</span><br><span class="line">#自动重启，保证服务在线</span><br><span class="line">environment:</span><br><span class="line">#指定环境变量 docker -itd -e MYSQL_ROOT_PASSWORD&#x3D; somewordpress</span><br><span class="line">MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">MYSQL_DATABASE: wordpress</span><br><span class="line">MYSQL_USER: wordpress</span><br><span class="line">MYSQL_PASSWORD: wordpress</span><br><span class="line"></span><br><span class="line">wordpress:</span><br><span class="line">depends_on:</span><br><span class="line">- db</span><br><span class="line"># - db 是参数，合起来的意思是只有当上面的mysql数据库安装成功后，这个wordpress才可以</span><br><span class="line">#被安装，还有一个功能，就是docker --link 将上面的mysql数据库，与这个wordpress应用连起来</span><br><span class="line">image: wordpress:latest</span><br><span class="line">ports:</span><br><span class="line">- &quot;8000:80&quot;</span><br><span class="line">restart: always</span><br><span class="line">environment:</span><br><span class="line">WORDPRESS_DB_HOST: db:3306</span><br><span class="line">WORDPRESS_DB_USER: wordpress</span><br><span class="line">WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">WORDPRESS_DB_NAME: wordpress</span><br><span class="line">volumes:</span><br><span class="line">db_data: &#123;&#125;</span><br><span class="line">#遥相呼应</span><br></pre></td></tr></table></figure></li><li><p>查看卷</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure></li><li><p>查看卷详细信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume inspect VOLUME_NAME</span><br><span class="line">#eg:docker volume inspect myblog_db_data</span><br></pre></td></tr></table></figure></li><li><p>进入Mountpoint</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;myblog_db_data&#x2F;_data</span><br><span class="line">#内容和mysql镜像中 &#x2F;var&#x2F;lib&#x2F;mysql路径相同(挂载点!)</span><br></pre></td></tr></table></figure></li><li><p>附一个终极奥义</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose --help</span><br></pre></td></tr></table></figure></li></ul><h4 id="搭建私有仓库"><a href="#搭建私有仓库" class="headerlink" title="搭建私有仓库"></a>搭建私有仓库</h4><h5 id="阿里云私有仓库"><a href="#阿里云私有仓库" class="headerlink" title="阿里云私有仓库"></a>阿里云私有仓库</h5><ul><li>地址:<a href="https://cr.console.aliyun.com/cn-shanghai/instances/repositories">https://cr.console.aliyun.com/cn-shanghai/instances/repositories</a></li><li>网站上步骤很详细</li></ul><h5 id="Harbor私有仓库"><a href="#Harbor私有仓库" class="headerlink" title="Harbor私有仓库"></a>Harbor私有仓库</h5><h6 id="搭建Harbor私有仓库"><a href="#搭建Harbor私有仓库" class="headerlink" title="搭建Harbor私有仓库"></a>搭建Harbor私有仓库</h6><ul><li><p>harbor离线地址:<a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></p></li><li><p>修改配置：harbor.yml </p><ul><li><p>修改主机名（注意空格）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostname: 192.168.0.151 </span><br></pre></td></tr></table></figure></li><li><p>修改密码（注意空格）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">harbor_admin_password: Harbor12345 </span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh prepare </span><br></pre></td></tr></table></figure></li><li><p>执行安装命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh install.sh</span><br><span class="line">#harbor本身也是一个镜像</span><br></pre></td></tr></table></figure></li><li><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose ps </span><br></pre></td></tr></table></figure></li><li><p>访问Harbor，默认用户名admin </p></li><li><p>关闭：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down </span><br></pre></td></tr></table></figure></li><li><p>启动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ul><h6 id="Harbor私有仓库的配置"><a href="#Harbor私有仓库的配置" class="headerlink" title="Harbor私有仓库的配置"></a>Harbor私有仓库的配置</h6><ul><li><p>Docker配置使用自建仓库 </p><ul><li><p>默认docker只允许访问 https仓库 如果要访问http仓库需要自己配置 </p></li><li><p>配置允许访问http仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http:&#x2F;&#x2F;仓库ip&quot;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重启docker服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker.service </span><br></pre></td></tr></table></figure></li><li><p>网页上创建项目名 登录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login --username&#x3D;admin 仓库ip</span><br></pre></td></tr></table></figure></li><li><p>改名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag mysql:5.7 仓库ip&#x2F;镜像仓库&#x2F;mysql:5.7 </span><br></pre></td></tr></table></figure></li><li><p>推送：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push 仓库ip&#x2F;镜像仓库&#x2F;mysql:5.7 </span><br></pre></td></tr></table></figure></li><li><p>下载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 仓库ip&#x2F;镜像仓库&#x2F;mysql:5.7 </span><br></pre></td></tr></table></figure></li><li><p>docker login 后有一个登录凭证（可删除，下次需要密码）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;root&#x2F;.docker&#x2F;config.json </span><br></pre></td></tr></table></figure><p>（建议从安全角度出发，每次登录后进行删除）</p></li></ul><h6 id="本地景象容器的载入和载出"><a href="#本地景象容器的载入和载出" class="headerlink" title="本地景象容器的载入和载出"></a>本地景象容器的载入和载出</h6><ul><li><p>保存镜像： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save cd3ed0dfff7e -o &#x2F;home&#x2F;mysql.tar #-o表示ouput</span><br><span class="line">或者</span><br><span class="line">docker save mysql:5.7 &gt; &#x2F;home&#x2F;mysql.tar </span><br></pre></td></tr></table></figure></li><li><p>载入镜像： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i mysql.tar </span><br></pre></td></tr></table></figure></li><li><p>保存容器： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker export CONTAINER_ID&#x2F;CONTAINER_NAME -o &#x2F;home&#x2F;mysql-export.tar </span><br></pre></td></tr></table></figure></li><li><p>载入容器： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker import mysql-export.tar</span><br></pre></td></tr></table></figure></li></ul><h4 id="收工！！！！"><a href="#收工！！！！" class="headerlink" title="收工！！！！"></a>收工！！！！</h4>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="2020/11/04/redis/"/>
      <url>2020/11/04/redis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
