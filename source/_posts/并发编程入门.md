---
title: 并发编程入门
date: 2020-11-18 14:46:21
tags: 并发编程
category: Java
description: java并发编程从入门到实战学习记录
---

### 起步

#### 概念入门

##### 什么是并发编程

- 什么是并发编程

  并发历史: 早期计算机--从头到尾执行一个程序，资源浪费 操作系统出现--计算机能运行多个程序，不同的程序在不同的单独的进程中运行

一个进程，有多个线程 提高资源的利用率，公平

- 串行与并行的区别

  串行：洗茶具、打水、烧水、等水开、冲茶 并行：打水、烧水同时洗茶具、水开、冲茶

  好处：可以缩短整个流程的时间

- 并发编程目的

  摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。这一定律揭示了信息技术进步的速度。 让程序充分利用计算机资源 加快程序响应速度（耗时任务、web服务器） 简化异步事件的处理

- 什么时候适合使用并发编程

  任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况 任务执行时间过长，可以划分为分工明确的子任务：比如分段下载 任务间断性执行：日志打印 任务本身需要协作执行：比如生产者消费者问题

##### 上下文切换

**什么是上下文切换**

- cpu为线程分配时间片，时间片非常短（毫秒级别），cpu不停的切换线程执行，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，让我们感觉是多个程序同时运行的。
- 上下文的频繁切换，会带来一定的性能开销

**如何减少上下文切换的开销？**

- 无锁并发编程

  无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据

- CAS

  Java的Atomic包使用CAS算法来更新数据，而不需要加锁。使用最少线程

- 使用最少线程。

  避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态

- 协程

  在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。--GO语言比较多

##### 死锁

- 好比打架互掐，揪头发，你不放过我，我也不饶你。

```
    package com.xdclass.synopsis;

        /**
         * 死锁Demo
         */
        public class DeadLockDemo {
            private static final Object HAIR_A = new Object();
            private static final Object HAIR_B = new Object();

            public static void main(String[] args) {
                new Thread(()->{
                    synchronized (HAIR_A) {
                        try {
                            Thread.sleep(50L);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        synchronized (HAIR_B) {
                            System.out.println("A成功的抓住B的头发");
                        }
                    }
                }).start();

                new Thread(()->{
                    synchronized (HAIR_B) {
                        synchronized (HAIR_A) {
                            System.out.println("B成功抓到A的头发");
                        }
                    }
                }).start();
            }
        }
```

- jps 查看pid      jstack+pid查看进程

  或者直接 jconsole 检测死锁查看

#### 线程基础

- **进程和线程的关系**

  - 进程：是系统进行分配和管理资源的基本单位
  - 线程：进程的一个执行单元，是进程内调度的实体、是CPU调度和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程,线程是程序执行的最小单位。
  - 一个程序至少一个进程，一个进程至少一个线程。
  - 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。

  ​     如何处理好同步与互斥是编写多线程程序的难点。 多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响， 而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题。

- **状态及其相互转换**
  - 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
  - 运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
  - 阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。
  - 等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
  - 超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，它可以在指定的时间内自行返回。
  - 终止(TERMINATED)：表示该线程已经执行完毕。

-  **创建线程都方式**
  - 继承Thread，并重写父类的run方法
  - 实现Runable接口，并实现run方法
  - 使用匿名内部类
  - Lambda表达式
  - 线程池

- **线程的挂起和恢复**

  - **什么是挂起线程？**

     线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。 在线程挂起后，可以通过重新唤醒线程来使之恢复运行

  - **为什么要挂起线程？**

    cpu分配的时间片非常短、同时也非常珍贵。避免资源的浪费。

  - **如何挂起线程？**

    ```
    被废弃的方法 thread.suspend() 
    	该方法不会释放线程所占用的资源。如果使用该方法将某个线程挂起，则可能会使其他等待资源的线程死锁 
    ```

    ```
    thread.resume() 方法
    本身并无问题，但是不能独立于suspend()方法存在 
    ```

    ```
    可以使用的方法 ：
    wait() 暂停执行、放弃已经获得的锁、进入等待状态
    notify() 随机唤醒一个在等待锁的线程
    notifyAll() 唤醒所有在等待锁的线程，自行抢占cpu资源
    ```

  - **什么时候适合使用挂起线程？**

    我等的船还不来(等待某些未就绪的资源)，我等的人还不明白。直到notify方法被调用

- **线程的中断操作**
  - stop() 废弃方法，开发中不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线程安全性问题
  - Thread.interrupt方法
  - 自行定义一个标志，用来判断是否继续执行

- **线程的优先级**

  - 线程的优先级告诉程序该线程的重要程度有多大。如果有大量线程都被堵塞，都在等候运行，程序会尽可能地先运行优先级的那个线程。 但是，这并不表示优先级较低的线程不会运行。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。

  - 线程的优先级设置可以为1-10的任一数值，Thread类中定义了三个线程优先级，分别是：MIN_PRIORITY（1）、NORM_PRIORITY（5）、MAX_PRIORITY（10），一般情况下推荐使用这几个常量，不要自行设置数值。

  - 不同平台，对线程的优先级的支持不同。 编程的时候，不要过度依赖线程优先级，如果你的程序运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确

  - 任务：

    快速处理：设置高的优先级 慢慢处理：设置低的优先级

- **守护线程**
  - 线程分类：用户线程、守护线程 

    守护线程：任何一个守护线程都是整个程序中所有用户线程的守护者，只要有活着的用户线程，守护线程就活着。当JVM实例中最后一个非守护线程结束时，也随JVM一起退出

  - 守护线程的用处：jvm垃圾清理线程

  - 建议： 尽量少使用守护线程，因其不可控，不要在守护线程里去进行读写操作、执行计算逻辑

###  起飞

#### 线程安全性

##### 什么是线程安全性

- 当多个线程访问某个类,不管运行时环境采用何种调度方式或者这些线程如何交替执行,并且在主调代码中不需要任何额外的同步或协同,这个类都能表现出正确的行为,那么就称这个类为线程安全的。----《并发编程实战》

- **什么是线程不安全？**

  多线程并发访问时，得不到正确的结果。

##### 从字节码角度分析线程不安全操作

```
javac -encoding UTF-8  指定字节码编译
javap -c 反编译
```

![image-20201118170522642](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AD%97%E8%8A%82%E7%A0%81.png)

```
0: getstatic     #2               获取指定类的静态域，并将其押入栈顶
3: iconst_1						 将int型1押入栈顶
4: iadd							 将栈顶两个int型相加，将结果押入栈顶
5: putstatic     #2               为指定类静态域赋值
8: return
```

注意：究极原因++操作不是原子操作

##### 原子性操作

- **什么是原子性操作**

  一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。（和mysql事务里的原子性感觉相差无几，要么都成功，要么都失败）

- **如何变成原子操作**
  - volatile关键字只能保证可见性，不能保证原子性
  - synchronized关键字可以保证原子性

##### 简单理解synchronized

- 内置锁
      		每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。

- 互斥锁
  		内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。

- synchronized用法：

  ​	修饰普通方法：锁住对象的实例，不同对象不会竞争锁
  ​	修饰静态方法：锁住整个类，不同对象会竞争锁
  ​	修饰代码块： 锁住一个对象 synchronized (lock) 即synchronized后面括号里的内容

##### volatile关键字

- 能且仅能修饰变量
- 保证该变量的可见性，volatile关键字仅仅保证可见性，并不保证原子性
- 禁止指令重排序
- A、B两个线程同时读取volatile关键字修饰的对象，A读取之后，修改了变量的值,修改后的值，对B线程来说，是可见
- 使用场景 1：作为线程开关 2：单例，修饰对象实例，禁止指令重排序

#####  单例与线程安全

- 饿汉式--本身线程安全

  在类加载的时候，就已经进行实例化，无论之后用不用到。如果该类比较占内存，之后又没用到，就白白浪费了资源。

- 懒汉式 -- 最简单的写法是非线程安全的，在需要的时候再实例化

##### 避免线程安全性问题

-  线程安全性问题成因
  - 多线程环境
  - 多个线程操作同一共享资源
  - 对该共享资源进行了非原子性操作

- 如何避免
  打破成因中三点任意一点
  - 多线程环境--将多线程改单线程（必要的代码，加锁访问）
  - 多个线程操作同一共享资源--不共享资源（ThreadLocal、不共享、操作无状态化、不可变——比如final修饰）
  - 对该共享资源进行了非原子性操作-- 将非原子性操作改成原子性操作（加锁、使用JDK自带的原子性操作的类、JUC提供的相应的并发工具类）

#### 锁

##### 锁分类

- 自旋锁： 线程状态及上下文切换消耗系统资源，当访问共享资源的时间短，频繁上下文切换不值得。jvm实现，使线程在没获得锁的时候，不被挂起，转而执行空循环，循环几次之后，如果还没能获得锁，则被挂起
- 阻塞锁：阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态
- 重入锁:支持线程再次进入的锁,就跟我们有房间钥匙，可以多次进入房间类似
- 读写锁： 两把锁，读锁跟写锁，写写互斥、读写互斥、读读共享
- 互斥锁： 上厕所，进门之后就把门关了，不让其他人进来
- 悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁
- 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。（mysql的version机制）
- 公平锁：大家都老老实实排队，对大家而言都很公平
- 非公平锁：一部分人排着队，但是新来的可能插队
- 偏向锁：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁
- 独占锁：独占锁模式下，每次只能有一个线程能持有锁
- 共享锁：允许多个线程同时获取锁，并发访问共享资源

##### 深入理解lock接口

- lock的使用

  ```
  Lock mylock = new ReentrantLock();
  //手动加锁
  mylock.lock();
  //手动解锁
  mylock.unlock();
  ```

- synchronized和lock锁的区别

  - lock 获取锁与释放锁的过程，都需要程序员手动的控制 

  - Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作 
  - synchronized托管给jvm执行 原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。

- lock实现类

  ![image-20201118192050223](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB)

- lock里的方法

  ![image-20201118192222720](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E6%96%B9%E6%B3%95)

##### 写一个锁

```
package net.zyaire.lock.mylock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private boolean isHoldLock = false;

    private Thread holdLockThread = null;

    private int reentryCount = 0;

    /**
     * 同一时刻，能且仅能有一个线程获取到锁，
     * 其他线程，只能等待该线程释放锁之后才能获取到锁
     */
    @Override
    public synchronized void lock() {
        if (isHoldLock && Thread.currentThread() != holdLockThread) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        holdLockThread = Thread.currentThread();
        isHoldLock = true;
        reentryCount++;
    }

    @Override
    public synchronized void unlock() {
        //判断当前线程是否是持有锁的线程，是，重入次数减去1，不是就不做处理
        if (Thread.currentThread() == holdLockThread) {
            reentryCount--;
            if (reentryCount == 0) {
                notify();
                isHoldLock = false;
            }
        }
    }

    @Override
    public Condition newCondition() {
        return null;
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public boolean tryLock() {
        return false;
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return false;
    }
}

```

##### 浅入AQS

![image-20201118194744682](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/AQS%E7%9A%84public%E6%96%B9%E6%B3%95)

- 主要方法

  ```
  acqiure(相当于加锁)
  release(相当于释放锁)
addwaiter(加入等待队列)
  isHeldExclusively(是否是独占锁)
  ```
  

##### Reentrantlock非公平锁

##### Reentrantlock公平锁

##### 线程执行顺序

##### 读写锁Reentrantlock的使用





