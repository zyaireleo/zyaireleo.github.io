---
title: 并发编程入门
date: 2020-11-18 14:46:21
tags: 并发编程 jvm 设计模式
category: Java
description: java并发编程从入门到实战学习记录
---

### 起步

#### 概念入门

##### 什么是并发编程

- 什么是并发编程

  并发历史: 早期计算机--从头到尾执行一个程序，资源浪费 操作系统出现--计算机能运行多个程序，不同的程序在不同的单独的进程中运行

一个进程，有多个线程 提高资源的利用率，公平

- 串行与并行的区别

  串行：洗茶具、打水、烧水、等水开、冲茶 并行：打水、烧水同时洗茶具、水开、冲茶

  好处：可以缩短整个流程的时间

- 并发编程目的

  摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。这一定律揭示了信息技术进步的速度。 让程序充分利用计算机资源 加快程序响应速度（耗时任务、web服务器） 简化异步事件的处理

- 什么时候适合使用并发编程

  任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况 任务执行时间过长，可以划分为分工明确的子任务：比如分段下载 任务间断性执行：日志打印 任务本身需要协作执行：比如生产者消费者问题

##### 上下文切换

**什么是上下文切换**

- cpu为线程分配时间片，时间片非常短（毫秒级别），cpu不停的切换线程执行，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，让我们感觉是多个程序同时运行的。
- 上下文的频繁切换，会带来一定的性能开销

**如何减少上下文切换的开销？**

- 无锁并发编程

  无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据

- CAS

  Java的Atomic包使用CAS算法来更新数据，而不需要加锁。使用最少线程

- 使用最少线程。

  避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态

- 协程

  在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。--GO语言比较多

##### 死锁

- 好比打架互掐，揪头发，你不放过我，我也不饶你。

```
    package com.xdclass.synopsis;

        /**
         * 死锁Demo
         */
        public class DeadLockDemo {
            private static final Object HAIR_A = new Object();
            private static final Object HAIR_B = new Object();

            public static void main(String[] args) {
                new Thread(()->{
                    synchronized (HAIR_A) {
                        try {
                            Thread.sleep(50L);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        synchronized (HAIR_B) {
                            System.out.println("A成功的抓住B的头发");
                        }
                    }
                }).start();

                new Thread(()->{
                    synchronized (HAIR_B) {
                        synchronized (HAIR_A) {
                            System.out.println("B成功抓到A的头发");
                        }
                    }
                }).start();
            }
        }
```

- jps 查看pid      jstack+pid查看进程

  或者直接 jconsole 检测死锁查看

#### 线程基础

- **进程和线程的关系**

  - 进程：是系统进行分配和管理资源的基本单位
  - 线程：进程的一个执行单元，是进程内调度的实体、是CPU调度和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程,线程是程序执行的最小单位。
  - 一个程序至少一个进程，一个进程至少一个线程。
  - 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。

  ​     如何处理好同步与互斥是编写多线程程序的难点。 多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响， 而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题。

- **状态及其相互转换**
  - 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
  - 运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
  - 阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。
  - 等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
  - 超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，它可以在指定的时间内自行返回。
  - 终止(TERMINATED)：表示该线程已经执行完毕。

-  **创建线程都方式**
  - 继承Thread，并重写父类的run方法
  - 实现Runable接口，并实现run方法
  - 使用匿名内部类
  - Lambda表达式
  - 线程池

- **线程的挂起和恢复**

  - **什么是挂起线程？**

     线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。 在线程挂起后，可以通过重新唤醒线程来使之恢复运行

  - **为什么要挂起线程？**

    cpu分配的时间片非常短、同时也非常珍贵。避免资源的浪费。

  - **如何挂起线程？**

    ```
    被废弃的方法 thread.suspend() 
    	该方法不会释放线程所占用的资源。如果使用该方法将某个线程挂起，则可能会使其他等待资源的线程死锁 
    ```

    ```
    thread.resume() 方法
    本身并无问题，但是不能独立于suspend()方法存在 
    ```

    ```
    可以使用的方法 ：
    wait() 暂停执行、放弃已经获得的锁、进入等待状态
    notify() 随机唤醒一个在等待锁的线程
    notifyAll() 唤醒所有在等待锁的线程，自行抢占cpu资源
    ```

  - **什么时候适合使用挂起线程？**

    我等的船还不来(等待某些未就绪的资源)，我等的人还不明白。直到notify方法被调用

- **线程的中断操作**
  - stop() 废弃方法，开发中不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线程安全性问题
  - Thread.interrupt方法
  - 自行定义一个标志，用来判断是否继续执行

- **线程的优先级**

  - 线程的优先级告诉程序该线程的重要程度有多大。如果有大量线程都被堵塞，都在等候运行，程序会尽可能地先运行优先级的那个线程。 但是，这并不表示优先级较低的线程不会运行。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。

  - 线程的优先级设置可以为1-10的任一数值，Thread类中定义了三个线程优先级，分别是：MIN_PRIORITY（1）、NORM_PRIORITY（5）、MAX_PRIORITY（10），一般情况下推荐使用这几个常量，不要自行设置数值。

  - 不同平台，对线程的优先级的支持不同。 编程的时候，不要过度依赖线程优先级，如果你的程序运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确

  - 任务：

    快速处理：设置高的优先级 慢慢处理：设置低的优先级

- **守护线程**
  - 线程分类：用户线程、守护线程 

    守护线程：任何一个守护线程都是整个程序中所有用户线程的守护者，只要有活着的用户线程，守护线程就活着。当JVM实例中最后一个非守护线程结束时，也随JVM一起退出

  - 守护线程的用处：jvm垃圾清理线程

  - 建议： 尽量少使用守护线程，因其不可控，不要在守护线程里去进行读写操作、执行计算逻辑

###  起飞

#### 线程安全性

##### 什么是线程安全性

- 当多个线程访问某个类,不管运行时环境采用何种调度方式或者这些线程如何交替执行,并且在主调代码中不需要任何额外的同步或协同,这个类都能表现出正确的行为,那么就称这个类为线程安全的。----《并发编程实战》

- **什么是线程不安全？**

  多线程并发访问时，得不到正确的结果。

##### 从字节码角度分析线程不安全操作

```
javac -encoding UTF-8  指定字节码编译
javap -c 反编译
```

![image-20201118170522642](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AD%97%E8%8A%82%E7%A0%81.png)

```
0: getstatic     #2               获取指定类的静态域，并将其押入栈顶
3: iconst_1						 将int型1押入栈顶
4: iadd							 将栈顶两个int型相加，将结果押入栈顶
5: putstatic     #2               为指定类静态域赋值
8: return
```

注意：究极原因++操作不是原子操作

##### 原子性操作

- **什么是原子性操作**

  一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。（和mysql事务里的原子性感觉相差无几，要么都成功，要么都失败）

- **如何变成原子操作**
  - volatile关键字只能保证可见性，不能保证原子性
  - synchronized关键字可以保证原子性

##### 简单理解synchronized

- 内置锁
      		每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。

- 互斥锁
  		内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。

- synchronized用法：

  ​	修饰普通方法：锁住对象的实例，不同对象不会竞争锁
  ​	修饰静态方法：锁住整个类，不同对象会竞争锁
  ​	修饰代码块： 锁住一个对象 synchronized (lock) 即synchronized后面括号里的内容

##### volatile关键字

- 能且仅能修饰变量
- 保证该变量的可见性，volatile关键字仅仅保证可见性，并不保证原子性
- 禁止指令重排序
- A、B两个线程同时读取volatile关键字修饰的对象，A读取之后，修改了变量的值,修改后的值，对B线程来说，是可见
- 使用场景 1：作为线程开关 2：单例，修饰对象实例，禁止指令重排序

#####  单例与线程安全

- 饿汉式--本身线程安全

  在类加载的时候，就已经进行实例化，无论之后用不用到。如果该类比较占内存，之后又没用到，就白白浪费了资源。

- 懒汉式 -- 最简单的写法是非线程安全的，在需要的时候再实例化

##### 避免线程安全性问题

-  线程安全性问题成因
  - 多线程环境
  - 多个线程操作同一共享资源
  - 对该共享资源进行了非原子性操作

- 如何避免
  打破成因中三点任意一点
  - 多线程环境--将多线程改单线程（必要的代码，加锁访问）
  - 多个线程操作同一共享资源--不共享资源（ThreadLocal、不共享、操作无状态化、不可变——比如final修饰）
  - 对该共享资源进行了非原子性操作-- 将非原子性操作改成原子性操作（加锁、使用JDK自带的原子性操作的类、JUC提供的相应的并发工具类）

#### 锁

##### 锁分类

- 自旋锁： 线程状态及上下文切换消耗系统资源，当访问共享资源的时间短，频繁上下文切换不值得。jvm实现，使线程在没获得锁的时候，不被挂起，转而执行空循环，循环几次之后，如果还没能获得锁，则被挂起
- 阻塞锁：阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态
- 重入锁:支持线程再次进入的锁,就跟我们有房间钥匙，可以多次进入房间类似
- 读写锁： 两把锁，读锁跟写锁，写写互斥、读写互斥、读读共享
- 互斥锁： 上厕所，进门之后就把门关了，不让其他人进来
- 悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁
- 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。（mysql的version机制）
- 公平锁：大家都老老实实排队，对大家而言都很公平
- 非公平锁：一部分人排着队，但是新来的可能插队
- 偏向锁：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁
- 独占锁：独占锁模式下，每次只能有一个线程能持有锁
- 共享锁：允许多个线程同时获取锁，并发访问共享资源

##### 深入理解lock接口

- lock的使用

  ```
  Lock mylock = new ReentrantLock();
  //手动加锁
  mylock.lock();
  //手动解锁
  mylock.unlock();
  ```

- synchronized和lock锁的区别

  - lock 获取锁与释放锁的过程，都需要程序员手动的控制 

  - Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作 
  - synchronized托管给jvm执行 原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。

- lock实现类

  ![image-20201118192050223](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB)

- lock里的方法

  ![image-20201118192222720](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E6%96%B9%E6%B3%95)

##### 写一个锁

```
package net.zyaire.lock.mylock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {

    private boolean isHoldLock = false;

    private Thread holdLockThread = null;

    private int reentryCount = 0;

    /**
     * 同一时刻，能且仅能有一个线程获取到锁，
     * 其他线程，只能等待该线程释放锁之后才能获取到锁
     */
    @Override
    public synchronized void lock() {
        if (isHoldLock && Thread.currentThread() != holdLockThread) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        holdLockThread = Thread.currentThread();
        isHoldLock = true;
        reentryCount++;
    }

    @Override
    public synchronized void unlock() {
        //判断当前线程是否是持有锁的线程，是，重入次数减去1，不是就不做处理
        if (Thread.currentThread() == holdLockThread) {
            reentryCount--;
            if (reentryCount == 0) {
                notify();
                isHoldLock = false;
            }
        }
    }

    @Override
    public Condition newCondition() {
        return null;
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public boolean tryLock() {
        return false;
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return false;
    }
}

```

##### 浅入AQS

![image-20201118194744682](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/AQS%E7%9A%84public%E6%96%B9%E6%B3%95)

- 主要方法

  ```
  acqiure(相当于加锁)
  release(相当于释放锁)
addwaiter(加入等待队列)
  isHeldExclusively(是否是独占锁)
  ```
  

##### Reentrantlock非公平锁

![ReentranLock非公平和公平锁的实现](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0.png)

- **lock()**

  ![ReentranLock加锁](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%8A%A0%E9%94%81.png)

  1.进入aquire（）

  ![ReentranLock公平锁aquire逻辑](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%85%AC%E5%B9%B3%E9%94%81aquire%E9%80%BB%E8%BE%91.png)
  - tryaquire(arg)尝试获得锁，aquireQueued（）加入等待队列。
  - 假如既没有获得锁成功，也没有成功假如等待队列，就会执行selfInterrupt（）方法；

  2.进入selfInterrupt（），调用的是线程的interrupt（）方法

  3.tryAquire()逻辑，具体实现在其子类NonfairSync（）实现

  ![Reentranlock非公平锁加锁具体实现](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/Reentranlock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0.png)

  注意是compareAndSetState(0, acquires)进行都操作，即是CAS操作

  4.加入队列的操作

  //TODO

- **unlock()**

![ReentranLock解锁逻辑](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E8%A7%A3%E9%94%81%E9%80%BB%E8%BE%91.png)

1. 进入release()

   ![ReentranLock释放锁](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E9%87%8A%E6%94%BE%E9%94%81.png)

   首先会tryRelease()，成功会唤起等待队列里面的线程

2. tryRelease()逻辑

   ![image-20201119160236412](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/tryRelease%E9%80%BB%E8%BE%91)

##### Reentrantlock公平锁

![image-20201119163132797](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81)

##### 如何多线程debug

![image-20201119164635268](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug)

##### 读写锁ReentrantReadlock

- **readLock（）**

**lock操作**

![image-20201119172020524](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/readLock())

读锁具体实现之tryAcquireShared（）

![image-20201119180216772](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81%E5%86%99%E9%94%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0)

读锁具体实现之doAcquireShared（）

![image-20201119181023428](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81doAcquire)

**unlock操作**

![image-20201119181411049](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81releaseShared)

- ##### unLock（）//TODO

  ps：差不多一样，更简单。

##### 解密AQS如何用单一int值表示读写两种状态

```
int 是32位，将其拆分成两个无符号short
    高位表示读锁          低位表示写锁
    0000000000000000   0000000000000000

两种锁的最大次数均为65535也即是2的16次方减去1
    读锁： 每次都从当前的状态加上65536
    0000000000000000   0000000000000000
    ‭0000000000000001   0000000000000000‬
    -----------------------------------
    0000000000000001   0000000000000000‬
    0000000000000001   0000000000000000‬
    -----------------------------------
    0000000000000010   0000000000000000‬

    获取读锁个数，将state整个无符号右移16位就可得出读锁的个数
                       0000000000000001 

    写锁：每次都直接加1
    0000000000000000   0000000000000000
    0000000000000000   0000000000000001
    -----------------------------------
    0000000000000000   0000000000000001

    获取写锁的个数
    0000000000000000   0000000000000001
    ‭0000000000000000   1111111111111111‬   
    ----------------------------------- 
    0000000000000000   0000000000000001
```

##### 锁降级

- 锁降级：写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性。

  注意点：锁降级之后，写锁并不会直接降级成读锁，不会随着读锁的释放而释放，因此需要显式地释放写锁

- 是否有锁升级？

  在ReentrantReadWriteLock里面，不存在锁升级这一说法

- 锁降级的应用场景

  用于对数据比较敏感，需要在对数据修改之后，获取到修改后的值，并进行接下来的其他操作

##### StampedLock

- **1.8之前，锁已经那么多了，为什么还要有StampedLock？**

  一般应用，都是读多写少，ReentrantReadWriteLock 因读写互斥，故读时阻塞写，因而性能上上不去。可能会使写线程饥饿

- StampedLock的特点

  所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功； 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致； StampedLock是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁） 支持锁升级跟锁降级 可以乐观读也可以悲观读 使用有限次自旋，增加锁获得的几率，避免上下文切换带来的开销 乐观读不阻塞写操作，悲观读，阻塞写得操作

- StampedLock的优点

  相比于ReentrantReadWriteLock，吞吐量大幅提升

- StampedLock的缺点

  api相对复杂，容易用错 内部实现相比于ReentrantReadWriteLock复杂得多

- StampedLock的原理

  每次获取锁的时候，都会返回一个邮戳（stamp），相当于mysql里的version字段 释放锁的时候，再根据之前的获得的邮戳，去进行锁释放

- 使用stampedLock注意点

  如果使用乐观读，一定要判断返回的邮戳是否是一开始获得到的，如果不是，要去获取悲观读锁，再次去读取

  官方Demo：

  ```
  import java.util.concurrent.locks.StampedLock;
  
  /**
   * StampedLock Demo
   */
  public class StampedLockDemo {
      // 成员变量
      private double x, y;
  
      // 锁实例
      private final StampedLock sl = new StampedLock();
  
      // 排它锁-写锁（writeLock）
      void move(double deltaX, double deltaY) {
          long stamp = sl.writeLock();
          try {
              x += deltaX;
              y += deltaY;
          } finally {
              sl.unlockWrite(stamp);
          }
      }
  
      // 乐观读锁
      double distanceFromOrigin() {
  
          // 尝试获取乐观读锁（1）
          long stamp = sl.tryOptimisticRead();
          // 将全部变量拷贝到方法体栈内（2）
          double currentX = x, currentY = y;
          // 检查在（1）获取到读锁票据后，锁有没被其他写线程排它性抢占（3）
          if (!sl.validate(stamp)) {
              // 如果被抢占则获取一个共享读锁（悲观获取）（4）
              stamp = sl.readLock();
              try {
                  // 将全部变量拷贝到方法体栈内（5）
                  currentX = x;
                  currentY = y;
              } finally {
                  // 释放共享读锁（6）
                  sl.unlockRead(stamp);
              }
          }
          // 返回计算结果（7）
          return Math.sqrt(currentX * currentX + currentY * currentY);
      }
  
      // 使用悲观锁获取读锁，并尝试转换为写锁
      void moveIfAtOrigin(double newX, double newY) {
          // 这里可以使用乐观读锁替换（1）
          long stamp = sl.readLock();
          try {
              // 如果当前点在原点则移动（2）
              while (x == 0.0 && y == 0.0) {
                  // 尝试将获取的读锁升级为写锁（3）
                  long ws = sl.tryConvertToWriteLock(stamp);
                  // 升级成功，则更新票据，并设置坐标值，然后退出循环（4）
                  if (ws != 0L) {
                      stamp = ws;
                      x = newX;
                      y = newY;
                      break;
                  } else {
                      // 读锁升级写锁失败则释放读锁，显示获取独占写锁，然后循环重试（5）
                      sl.unlockRead(stamp);
                      stamp = sl.writeLock();
                  }
              }
          } finally {
              // 释放锁（6）
              sl.unlock(stamp);
          }
      }
  }
  
  ```

#### 线程间通信

##### wait，notify，notifyAll

- 何时使用 在多线程环境下，有时候一个线程的执行，依赖于另外一个线程的某种状态的改变，这个时候，我们就可以使用wait与notify或者notifyAll

- wait跟sleep的区别 wait会释放持有的锁，而sleep不会，sleep只是让线程在指定的时间内，不去抢占cpu的资源 注意点 wait notify必须放在同步代码块中, 且必须拥有当前对象的锁，即不能取得A对象的锁，而调用B对象的wait 哪个对象wait，就得调哪个对象的notify

- notify跟notifyAll的区别

  nofity随机唤醒一个等待的线程 notifyAll唤醒所有在该对象上等待的线程

##### 等待通知经典模型之生产者消费者

![生产者消费者](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png)

//TODO 代码太长

##### 使用管道流进行通信

- 以内存为媒介，用于线程之间的数据传输。
- 主要有面向字节：【PipedOutputStream、PipedInputStream】、面向字符【PipedReader、PipedWriter】

- reader

  ```
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.io.PipedInputStream;
  import java.util.stream.Collectors;
  
  public class Reader implements Runnable{
  
      private PipedInputStream pipedInputStream;
  
      public Reader(PipedInputStream pipedInputStream) {
          this.pipedInputStream = pipedInputStream;
      }
  
      @Override
      public void run() {
          if (pipedInputStream != null) {
              String collect = new BufferedReader(new InputStreamReader(pipedInputStream)).lines().collect(Collectors.joining("\n"));
              System.out.println(Thread.currentThread().getName() +collect);
          }
          try {
              pipedInputStream.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- main

  ```
  import java.io.*;
  
  public class Main {
  
      public static void main(String[] args) throws IOException {
          PipedInputStream pipedInputStream = new PipedInputStream();
          PipedOutputStream pipedOutputStream = new PipedOutputStream();
  
          pipedOutputStream.connect(pipedInputStream);
  
          new Thread(new Reader(pipedInputStream)).start();
          BufferedReader bufferedReader = null;
          try {
              bufferedReader = new BufferedReader(new InputStreamReader(System.in));
              pipedOutputStream.write(bufferedReader.readLine().getBytes());
          } finally {
              pipedOutputStream.close();
              if (bufferedReader != null) {
                  bufferedReader.close();
              }
          }
  
      }
  
  }
  ```

##### Thread.join（）方法

- 使用场景：线程A执行到一半，需要一个数据，这个数据需要线程B去执行修改，只有B修改完成之后，A才能继续操作。线程A的run方法里面，调用线程B的join方法，这个时候，线程A会等待线程B运行完成之后，再接着运行

```

public class Main {

    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"开始运行");
            try {
                Thread.sleep(3000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"结束运行");
        }, "线程1");

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"开始运行");
            thread.start();//这里调用start,程序不会按预期进行
            try {
//调用join方法,结果:线程2开始--->线程1开始--->线程1结束---->线程2结束
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"运行结束");
        }, "线程2").start();
    }

}
```

join()方法可以传参，相当于wait()

##### Threadlocal的使用

- 线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。为每个线程单独存放一份变量副本，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。只要线程处于活动状态并且ThreadLocal实例可访问，那么每个线程都拥有对其本地线程副本的隐式引用变量一个线程消失后，它的所有副本线程局部实例受垃圾回收（除非其他存在对这些副本的引用）
- 一般用的比较多的是 
  - ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。 
  - ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。 
  - ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。 
  - ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。

##### condition的使用

- 可以在一个锁里面，存在多种等待条件
- 主要的方法 await signal signalAll

####  原子类

- 一度认为原子是不可分割的最小单位，故原子类可以认为其操作都是不可分割

- **为什么要有原子类？**

  对多线程访问同一个变量，我们需要加锁，而锁是比较消耗性能的，JDk1.5之后， 新增的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的.方式， 这些类同样位于JUC包下的atomic包下，发展到JDk1.8，该包下共有17个类， 囊括了原子更新基本类型、原子更新数组、原子更新属性、原子更新引用

- 1.8新增的原子类

  DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64

##### 原子更新基本类型

- 发展至JDk1.8，基本类型原子类有以下几个：

  AtomicBoolean、AtomicInteger、AtomicLong、DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder

- 大致可以归为3类

  - AtomicBoolean、AtomicInteger、AtomicLong 元老级的原子更新，方法几乎一模一样 

  **AutomicInterger**

  ```
  public class Demo1 {
  
  	//初始化实例
      private static AtomicInteger sum = new AtomicInteger(0);
  
      public static void inCreate() {
          sum.incrementAndGet();
      }
  
      public static void main(String[] args) {
          for (int i = 0; i < 10; i++) {
              new Thread(()->{
                  for (int j = 0; j < 100; j++) {
                      inCreate();
                      System.out.println(sum);
                  }
              }).start();
          }
      }
  }
  ```

  - DoubleAdder、LongAdder 对Double、Long的原子更新性能进行优化提升 
  - DoubleAccumulator、LongAccumulator 支持自定义运算

  ```
  public class Demo2 {
  
      public static void main(String[] args) {
          //输入一个数字，如果比上一个输入的大，则直接返回，如果小，则返回上一个
          LongAccumulator longAccumulator = new LongAccumulator((left, right) ->
          //可以自定义逻辑
                  left * right, 0L
          );
  
          longAccumulator.accumulate(3L);
          System.out.println(longAccumulator.get());
          longAccumulator.accumulate(5L);
          System.out.println(longAccumulator.get());
      }
  
  }
  ```

##### 原子更新数组类型

- AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray

  ```
  /**
   * AtomicIntegerArray Demo
   */
  public class AtomicIntegerArrayDemo {
  
      public static void main(String[] args) {
          int[] arr = new int[]{3, 2};
          AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(arr);
          System.out.println(atomicIntegerArray.addAndGet(1, 8));//第一个入参是数组的下标，执行结果为10
  
  		//自定义逻辑，支持lamada表达式
          int i = atomicIntegerArray.accumulateAndGet(0, 2, (left, right) ->
                  left * right / 3
          );
  
          System.out.println(i);
      }
  
  }
  ```

##### 原子地更新属性

- 原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下4个类进行原子字段更新 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicStampedReference、AtomicReferenceFieldUpdater

  **AtomicIntegerFieldUpdater**

  ```
  import java.util.concurrent.atomic.AtomicLongFieldUpdater;
  import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
  
  /**
   * AtomicLongFieldUpdaterDemo
   */
  public class AtomicLongFieldUpdaterDemo {
  
      public static void main(String[] args) {
          AtomicLongFieldUpdater<Student> longFieldUpdater = AtomicLongFieldUpdater.newUpdater(Student.class, "id");
  
          Student xdclass = new Student(1L, "xdclass");
          
        //第二个入参的是第几个字段,从1开始  
          longFieldUpdater.compareAndSet(xdclass, 1L, 100L);
          System.out.println("id="+xdclass.getId());
  
  		//第二个为要修改的类型，第三个为要修改的字段
          AtomicReferenceFieldUpdater<Student, String> referenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");
          referenceFieldUpdater.compareAndSet(xdclass, "xdclass", "wiggin");
          System.out.println("name="+xdclass.getName());
      }
  }
  
  class Student{
  
  	//必须以volatile修饰，并且是基本数据类型，不能用包装类型
      volatile long id;
      
      //
      volatile String name;
  
      public Student(Long id, String name) {
          this.id = id;
          this.name = name;
      }
  
      public Long getId() {
          return id;
      }
  
      public void setId(Long id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  }
  ```

  ```
      使用上述类的时候，必须遵循以下原则
      字段必须是volatile类型的，在线程之间共享变量时保证立即可见
      字段的描述类型是与调用者与操作对象字段的关系一致。
      也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。
      对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。
      只能是实例变量，不能是类变量，也就是说不能加static关键字。
      只能是可修改变量，不能使final变量，因为final的语义就是不可修改。
      对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。
      如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。
  ```

##### 原子更新引用

- AtomicReference：用于对引用的原子更新
- AtomicMarkableReference：带版本戳的原子引用类型，版本戳为boolean类型。
- AtomicStampedReference：带版本戳的原子引用类型，版本戳为int类型。

```
/**
 * AtomicReferenceDemo
 */
public class AtomicReferenceDemo {

    public static void main(String[] args) {
        AtomicReference<Student> studentAtomicReference = new AtomicReference<>();
        Student student = new Student(1L, "xdclass");
        Student student1 = new Student(2L, "wiggin");
        
        //如果不先把要CAS的对象set进去的话,最后get会报空指针异常
        studentAtomicReference.set(student);
        studentAtomicReference.compareAndSet(student, student1);
        
        //必需通过get获取CAS后的对象
        Student student2 = studentAtomicReference.get();
        System.out.println(student2.getName());
    }
}

class Student{
    private long id;
    private String name;

    public Student(long id, String name) {
        this.id = id;
        this.name = name;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

#### 容器

##### 同步容器和并发容器

- 同步容器

  Vector、HashTable -- JDK提供的同步容器类 Collections.synchronizedXXX 本质是对相应的容器进行包装

- 同步容器类的缺点

  在单独使用里面的方法的时候，可以保证线程安全。但是，复合操作需要额外加锁来保证线程安全 使用Iterator迭代容器或使用for-each遍历容器，在迭代过程中修改容器会抛出ConcurrentModificationException异常。想要避免出现ConcurrentModificationException，就必须在迭代过程持有容器的锁。但是若容器较大，则迭代的时间也会较长。那么需要访问该容器的其他线程将会长时间等待。从而会极大降低性能。 

  若不希望在迭代期间对容器加锁，可以使用"克隆"容器的方式。使用线程封闭，由于其他线程不会对容器进行修改，可以避免ConcurrentModificationException。但是在创建副本的时候，存在较大性能开销。 toString，hashCode，equalse，containsAll，removeAll，retainAll等方法都会隐式的Iterate，也即可能抛出ConcurrentModificationException。

- 并发容器

  CopyOnWrite、Concurrent、BlockingQueue 根据具体场景进行设计，尽量避免使用锁，提高容器的并发访问性。

   ConcurrentBlockingQueue：基于queue实现的FIFO的队列。队列为空，取操作会被阻塞 

  ConcurrentLinkedQueue，队列为空，取得时候就直接返回空

##### 同步容器

- 

    public static void main(String[] args) {
        Vector<String> stringVector = new Vector<>();
        for (int i = 0; i < 1000; i++) {
            stringVector.add("demo" + i);
        }
    
        //错误遍历
       stringVector.forEach(e->{
           if (e.equals("demo3")) {
               stringVector.remove(e);
           }
           System.out.println(e);
       });
    
        //正确迭代
        Iterator<String> stringIterator = stringVector.iterator();
       while (stringIterator.hasNext()) {
           String next = stringIterator.next();
           if (next.equals("demo2")) {
               stringIterator.remove();
           }
       }
    
    	//模拟多线程修改
    	Iterator<String> stringIterator2 = stringVector.iterator();
    	for (int i = 0; i < 4; i++) {
    	    new Thread(() -> {
    	    	//不加synchronized会报错
    	        synchronized (stringIterator2) {
    	            while (stringIterator2.hasNext()) {
    	                String next = stringIterator2.next();
    	                if (next.equals("demo2")) {
    	                    stringIterator2.remove();
    	                }
    	            }
    	        }
    	    }).start();
    	}
    }

##### 并发容器

    public static void main(String[] args) {
    
        CopyOnWriteArrayList<String> strings = new CopyOnWriteArrayList<>();
        for (int i = 0; i < 1000; i++) {
            strings.add("demo" + i);
        }
        //不会报错
       strings.forEach(e->{
           if (e.equals("demo2")) {
               strings.remove(e);
           }
       });
       //不支持在迭代器里直接remove的操作, 会直接报错
       Iterator<String> iterator = strings.iterator();
       while (iterator.hasNext()) {
           String next = iterator.next();
           if (next.equals("demo2")) {
               iterator.remove();
           }
       }
    
    	//然鹅多线程修改并不会报错
        for (int i = 0; i < 4; i++) {
            new Thread(() -> {
                strings.forEach(e -> {
                    if (e.equals("demo2")) {
                        strings.remove(e);
                    }
                });
            }).start();
        }
    }

##### LinkedBlockingQueue

- 为什么用

  在并发编程中，LinkedBlockingQueue使用的非常频繁。因其可以作为生产者消费者的中间商

- 常用方法

  add  实际上调用的是offer，区别是在队列满的时候，add会报异常

  offer  对列如果满了，直接入队失败

  

  put("111"); 在队列满的时候，会进入阻塞的状态  

  remove(); 直接调用poll，唯一的区别即使remove会抛出异常，而poll在队列为空的时候直接返回null
  poll(); 在队列为空的时候直接返回null
  take(); 在队列为空的时候，会进入等待的状态   

```
public class Demo2 {
    public static void main(String[] args) throws InterruptedException {
        LinkedBlockingQueue<String> strings = new LinkedBlockingQueue<>();
        //往队列里存元素
        strings.add("111");
        strings.offer("111");
        strings.put("111");

        //从队列中取元素
        String remove = strings.remove();
        strings.poll();
        strings.take();

    }
}
```



#### 并发工具类

##### CountDownLatch

- await(),进入等待的状态
- countDown(),计数器减一
- 应用场景：启动三个线程计算，需要对结果进行累加

```
import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {

    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(8);
        new Thread(()->{
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("800米比赛结束，准备清空跑道并继续跨栏比赛");
        }).start();

        for (int i = 0; i < 8; i++) {
            int finalI = i;
            new Thread(()->{
                try {
                    Thread.sleep(finalI * 1000L);
                    System.out.println(Thread.currentThread().getName()+"到达终点");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    countDownLatch.countDown();
                }
            }).start();
        }
    }
}

```

##### CyclicBarrier--栅栏

- 允许一组线程相互等待达到一个公共的障碍点，之后再继续执行

- 跟countDownLatch的区别

  CountDownLatch一般用于某个线程等待若干个其他线程执行完任务之后，它才执行；不可重复使用 CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；可重用的

```
package com.xdclass.tool;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {

    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(8);

        for (int i = 0; i < 8; i++) {
            int finalI = i;
            new Thread(() -> {
                try {
                    Thread.sleep(finalI * 1000L);
                    System.out.println(Thread.currentThread().getName() + "准备就绪");
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }

                System.out.println("开始比赛");
            }).start();
        }
    }
}
```



##### Semaphore--信号量

- 控制并发数量
- 使用场景：接口限流

```
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {

    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2);

        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                try {
                
                	//必须获得信号量才可以执行
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "开始执行");
                    Thread.sleep(5000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                	//用完之后必须释放
                    semaphore.release();
                }
            }).start();
        }
    }
    
}
```

##### Exchanger

- 用于交换数据
- 它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger的重点是成对的线程使用exchange()方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是   **成对**   的。

```
import java.util.concurrent.Exchanger;

public class ExchangerDemo {

    public static void main(String[] args) {
        Exchanger<String> stringExchanger = new Exchanger<>();

        String str1 = "xdclass";
        String str2 = "wiggin";

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "初始值==========>" + str1);
            try {
                String exchange = stringExchanger.exchange(str1);
                System.out.println(Thread.currentThread().getName() + "交換后的数据==========>" + exchange);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "线程1").start();

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "初始值==========>" + str2);
            try {
                String exchange = stringExchanger.exchange(str2);
                System.out.println(Thread.currentThread().getName() + "交換后的数据==========>" + exchange);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "线程2").start();


//新增一个线程执行exchange, 程序会一直卡着(必须要有一个线程的exchange和他匹配!!!)
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "初始值==========>" + str2);
            try {
                String exchange = stringExchanger.exchange(str2);
                System.out.println(Thread.currentThread().getName() + "交換后的数据==========>" + exchange);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "线程3").start();
    }

}
```

#### 线程池及Executor框架

##### 为什么要使用线程池

```
    诸如 Web 服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务。请求以某种方式到达服务器，这种方式可能是通过网络协议（例如 HTTP、FTP ）、通过 JMS队列或者可能通过轮询数据库。不管请求如何到达，服务器应用程序中经常出现的情况是：单个任务处理的时间很短而请求的数目却是巨大的。每当一个请求到达就创建一个新线程，然后在新线程中为请求服务，但是频繁的创建线程，销毁线程所带来的系统开销其实是非常大的。
    线程池为线程生命周期开销问题和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。其好处是，因为在请求到达时线程已经存在，所以无意中也消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。而且，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。
    风险与机遇
        用线程池构建的应用程序容易遭受任何其它多线程应用程序容易遭受的所有并发风险，
        诸如同步错误和死锁，它还容易遭受特定于线程池的少数其它风险，诸如与池有关的死锁、资源不足和线程泄漏。
```

##### 创建线程池及使用

![image-20201120162227498](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0)

![image-20201120162307754](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E5%9B%BE%E7%A4%BA)

线程池的创建和使用

![](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BD%BF%E7%94%A8)

##### Future与Callable、FutureTask

- Callable与Runable功能相似，Callable的call有返回值，可以返回给客户端，而Runable没有返回值，一般情况下，Callable与FutureTask一起使用，或者通过线程池的submit方法返回相应的Future
- Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。get方法会阻塞，直到任务返回结果
- FutureTask则是一个RunnableFuture，而RunnableFuture实现了Runnbale又实现了Futrue这两个接口

FutureTask

![image-20201120164134227](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/FutureTask%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3)

使用

```

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableDemo implements Callable<String> {
    
    @Override
    public String call() throws Exception {
        Thread.sleep(3000L);
        return "1111";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {

        CallableDemo callableDemo = new CallableDemo();

        //callable的实现类不能直接使用
        FutureTask<String> stringFutureTask = new FutureTask<>(callableDemo);\

        //FutureTask实现了Rnnable接口
        new Thread(stringFutureTask).start();

        //通过get拿到返回值
        System.out.println(stringFutureTask.get());
    }
}
```

##### 线程池核心组成部分

- 构造参数

  ![image-20201120162307754](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E5%9B%BE%E7%A4%BA)

  - corePoolSize：核心线程池大小 cSize
  - maximumPoolSize：线程池最大容量 mSize
  - keepAliveTime：当线程数量大于核心时，多余的空闲线程在终止之前等待新任务的最大时间。
  - unit：时间单位
  - workQueue:工作队列 nWorks
  - ThreadFactory：线程工厂
  - handler：拒绝策略

- 运行机制

  通过new创建线程池时，除非调用prestartAllCoreThreads方法初始化核心线程，否则此时线程池中有0个线程，即使工作队列中存在多个任务，同样不会执行

  任务数X

  x <= cSize(核心线程数) 只启动x个线程

  x >= cSize && x < nWorks(等待对列最大值) + cSize 会启动 <= cSize 个线程 其他的任务就放到工作队列里

  x > cSize && x > nWorks + cSize

  - x-(nWorks) <= mSize 会启动x-(nWorks)个线程

  - x-(nWorks) > mSize 会启动mSize个线程来执行任务，其余的执行相应的拒绝策略

##### 线程池拒绝策略

![image-20201120171650128](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ExcutionHandler%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5)

- AbortPolicy：该策略直接抛出异常，阻止系统正常工作
- CallerRunsPolicy：只要线程池没有关闭，该策略直接在调用者线程中，执行当前被丢弃的任务（叫老板帮你干活）
- DiscardPolicy：直接啥事都不干，直接把任务丢弃
- DiscardOldestPolicy：丢弃最老的一个请求（任务队列里面的第一个），再尝试提交任务

- 自定义handler

  ```
  import java.util.concurrent.RejectedExecutionHandler;
  import java.util.concurrent.ThreadPoolExecutor;
  
  public class CustomPolicy implements RejectedExecutionHandler {
      @Override
      public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
          //发送邮件告警
          System.out.println("线程池满了");
      }
  }
  ```

##### Executor框架

总共六种	

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Executor 框架Demo
 */
public class ExecutorDemo {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        ExecutorService executorService1 = Executors.newFixedThreadPool(2);
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
        ExecutorService executorService2 = Executors.newWorkStealingPool();
        ExecutorService executorService3 = Executors.newSingleThreadExecutor();
        ScheduledExecutorService scheduledExecutorService1 = Executors.newSingleThreadScheduledExecutor();

		//submit来使用线程池
        executorService.submit(() -> {
           System.out.println(Thread.currentThread().getName());
        });
    }
   
}
```

- 通过相应的方法，能创建出6种线程池

- 上面的方法最终都创建了ThreadPoolExecutor

  - newCachedThreadPool：创建一个可以根据需要创建新线程的线程池，如果有空闲线程，优先使用空闲的线程 

  - newFixedThreadPool：创建一个固定大小的线程池，在任何时候，最多只有N个线程在处理任务

  - newScheduledThreadPool：能延迟执行、定时执行的线程池 

  - newWorkStealingPool：工作窃取，使用多个队列来减少竞争 

    通过new ForkJoinPool, 空闲队列窃取满队列任务

  - newSingleThreadExecutor：单一线程的线程次，只会使用唯一一个线程来执行任务，即使提交再多的任务，也都是会放到等待队列里进行等待 

  - newSingleThreadScheduledExecutor：单线程能延迟执行、定时执行的线程池

##### 线程池的使用建议

- 尽量避免使用Executor框架创建线程池

  - newFixedThreadPool newSingleThreadExecutor 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 
  - newCachedThreadPool newScheduledThreadPool 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM

  **PS:**

  创建线程时用的内存并不是我们制定jvm堆内存，而是系统的剩余内存。（电脑内存-系统其它程序占用的内存-已预留的jvm内存）

- 创建线程池时，核心线程数不要过大

- 相应的逻辑，发生异常时要处理

- submit 如果发生异常，不会立即抛出，而是在get的时候，再抛出异常

- execute 直接抛出异常

#### jvm与并发

##### jvm内存模型

- 硬件内存模型

  处理器--->高速缓存--->缓存一致性协议--->主存

- java内存模型

  线程<--->工作内存<--->save和load <--->主存

  

  **硬件内存模型和java内存模型**

  ![java内存模型](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

- **java内存间的交互操作(八种)**

  - lock(锁定)：作用于**主内存的变量**，把一个变量标记为一条线程独占状态 
  - unlock(解锁)：作用于**主内存的变量**，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 
  - read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 
  - load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 
  - use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 
  - assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 
  - store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 
  - write(写入)：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

- **上面8中操作必须满足以下规则**(8点)

  - 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 
  - 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 
  - 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。 
  - 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 
  - 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 
  - 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 
  - 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 
  - 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。

##### Happens-before原则

- 判断数据是有有竞争、线程是否安全的主要依据

  1. 程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。
  2. 管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。
  3. volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作
  4. 线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。
  5. 线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。
  6. 线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断
  7. 对象终结规则：一个对象的初始化完成先行于发生它的finalize（）方法的开始。
  8. 传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C。

- **为什么要有该原则？**

   无论jvm或者cpu，都希望程序运行的更快。如果两个操作不在上面罗列出来的规则里面，那么久可以对他们进行任意的重排序。

- 时间先后顺序与先行发生的顺序之间基本没有太大的关系。

##### 指令重排序

- 什么是指令重排序？

  重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。

- 数据依赖性

  编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。）

- 两操作访问同一个变量，其两个操作中有至少一个写操作，此时就存在依赖性

  写后读 a=0 b=a

  读后写 a=b b=1

  写后写 a=1 a=2 a=1,b=1

  写后读 a=0 b=a 正确b=0 错误b=1

- as-if-serial原则

  不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。

### 其他

#### 单例模式

##### 饿汉式

```
public class HungerSingleton {

    private static HungerSingleton ourInstance = new HungerSingleton();

    public static HungerSingleton getInstance() {
        return ourInstance;
    }

    private HungerSingleton() {
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                System.out.println(HungerSingleton.getInstance());
            }).start();
        }
    }
}

```



##### 懒汉式

```
public class LazySingleton {

    private static volatile LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public static LazySingleton getInstance() {
        //判断实例是否为空，为空则实例化
        if (null == lazySingleton) {
            //模拟实例化时耗时的操作
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (LazySingleton.class) {
                if (null == lazySingleton) {
                    lazySingleton = new LazySingleton();
                }
            }
        }
        //否则直接返回
        return lazySingleton;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(LazySingleton.getInstance());
            }).start();
        }
    }

}
```



#### 生产者消费者模型 