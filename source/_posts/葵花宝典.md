---
title: 葵花宝典
date: 2020-11-06 09:57:15
tags: java
description: 整理自小滴课堂
---

打工人，打工魂，打工都是人上人。

### JAVA

#### 基础

1. **String str = new String("zyaire.net"); 创建了了⼏几个对象？**

   ```
   创建一个对象：常量池存在，则直接new⼀个对象；
   创建两个对象：常量池不存在，则在常量池创建一个对象，也在堆里面创建一个对象
   ```

   ps：

   ```
   String s2 = s1 + ".net"; //变量 + 常量 = 来自堆
   #把s1变为常量的方法：fianl String s1 = "zyaire"
   #不管是new String("XXX")和直接常量赋值, 都会在字符串常量池创建.只是new String("XXX")方式会在堆中创建一个对象去指向常量池的对象, 普通的常量赋值是直接赋值给变量
   ```

   ```
   String s3 = "zyaire" + ".net"; //常量 + 常量 = 来自常量池
   #javac编译可以对【字符串常量】直接相加的表达式进行优化，不用等到运行期再去进行加法运算处理，而是直接将其编译成⼀个这些常量相连的结果
   ```

2. **接口是否可以继承接口？接口是否⽀支持多继承？类是否支持多继承？接口⾥里面是否可以有方法实现？**

   - 接⼝里可以有静态方法和方法体
   - 接⼝中所有的方法必须是抽象方法（JDK8之后就不是）
   - 接⼝不是被类继承了了，而是要被类实现
   - 接⼝⽀持多继承, 类不支持多个类继承

3. **JDK8接口新特性**

   - interface中可以有static方法，但必须有方法实现体，该方法只属于该接口，接口名直接调用该方法
   - 接口中新增default关键字修饰的方法，default方法只能定义在接口中，可以在子类或⼦子接口中被重写，default定义的方法必须有方法体
   - 父接口的default方法如果在子接口或子类被重写，那么子接口实现对象、子类对象，调用该方法，以重写为准
   - 本类、接口如果没有重写父类（即接口）的default方法，则在调用default方法时，使用父类（接口） 定义的default方法逻辑

4. **如果需要保证线程安全，ArrayList应该怎么做，⽤用有几种⽅方式?**

   ```
   方式一：自己写个包装类，根据业务一般是add/update/remove加锁
   方式二：Collections.synchronizedList(new ArrayList<>())//使用synchronized加锁
   方式三：CopyOnWriteArrayList<>()//get()没有加锁
   //add():使用ReentrantLock加锁---->Arrays.copyOf()---->unlock---->拷贝引用地址
   //通通给我锁上!!!
   ```

5. **CopyOnWriteArrayList和Collections.synchronizedList实现线程安全有什么区别？**

   - CopyOnWriteArrayList：执行修改操作时，会拷贝一份新的数组进行操作（add、set、remove等)，代价十分昂贵，在执行完修改后将原来集合指向新的集合来完成修改操作，源码里面用ReentrantLock可重入锁来保证不会有多个线程同时拷贝一份数组。
   - Collections.synchronizedList：线程安全的原因是因为它几乎在每个方法中都使用了synchronized同步锁

6. **CopyOnWriteArrayList的设计思想是怎样的,有什么缺点？**

   - 优点：设计思想：读写分离+最终一致
   - 缺点：内存占用问题，写时复制机制，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象,如果对象大则容易发生Yong GC和Full GC

7. **ArrayList的扩容机制？**

   ```
   注意：JDK1.7之前ArrayList默认大小是10，JDk1.7之后是0
   未指定集合容量，默认是0，若已经指定大小则集合大小为指定的；
   当集合第一次添加元素的时候，集合大小扩容为10
   ArrayList的元素个数大于其容量，扩容的大小= 原始大小+原始大小/2
   ```

8.  **HashMap和Hashtable** 

   ```
   HashMap：底层是基于数组+链表，非线程安全的，默认容量是16、允许有空的健和值
   Hashtable：基于哈希表实现，线程安全的(加了synchronized)，默认容量是11，不允许有null的健和值
   ```

9. **HashMap和TreeMap**

   ```
   hashMap:散列桶(数组+链表)，可以实现快速的存储和检索，但是确实包含无序的元素，适⽤用于在map中插入删除和		  定位元素
   treeMap:使用存储结构是一个平衡二叉树->红黑树，可以自定义排序规则，要实现Comparator接口，能便捷的实现内		 部元素的各种排序，但是一般性能比HashMap差，适用于安装自然排序或者自定义排序规则(写过微信⽀付签 		 名工具类就用这个类)
   ```

10. **什么是Hash碰撞？常⻅见的解决办法有哪些？**

    ```
    hash碰撞的意思是不同key计算得到的Hash值相同，需要放到同个bucket中
    常见的解决办法：链表法、开发地址法、再哈希法等
    HashMap采用的是链表法
    ```

11. **为什么ConcurrentHashMap性能比hashtable高？**

    ```
    ConcurrentHashMap线程安全的Map, hashtable类基本上所有的方法都是采用synchronized进行线程安全控制
    高并发情况下效率就降低
    
    ConcurrentHashMap是采用了分段锁的思想提高性能，锁粒度更细化
    ```

12. **jdk1.7和jdk1.8里面ConcurrentHashMap实现**的区别

    ```
    //都不允许空值
    JDK8之前，ConcurrentHashMap使用锁分段技术，将数据分成一段段存储，每个数据段配置一把锁，即segment类，这个类继承ReentrantLock来保证线程安全
    技术点：Segment+HashEntry
    
    JKD8的版本取消Segment这个分段锁数据结构，底层也是使用Node数组+链表+红黑树，从而实现对每一段数据就行加锁，也减少了并发冲突的概率，CAS(读)+Synchronized(写)
    技术点：Node+Cas+Synchronized
    ```

13. **ConcurrentHashMap的put的核心逻辑（JDK8以上版本）**

    ```
    spread(key.hashCode())  重哈希，减少碰撞概率
    tabAt(i) 获取table中索引为i的Node元素
    casTabAt(i) 利用CAS操作获取table中索引为i的Node元素
    
    put的核心流程
    1、key进行重哈希spread(key.hashCode())
    2、对当前table进行无条件循环
    3、如果没有初始化table，则用initTable进行初始化
    4、如果没有hash冲突，则直接用cas插入新节点，成功后则直接判断是否需要扩容，然后结束
    5、(fh = f.hash) == MOVED 如果是这个状态则是扩容操作，先进行扩容
    6、存在hash冲突，利用synchronized (f) 加锁保证线程安全
    7、如果是链表，则直接遍历插入，如果数量大于8，则需要转换成红黑树
    8、如果是红黑树则按照红黑树规则插入
    9、最后是检查是否需要扩容addCount()
    //令人头大
    ```
    
14. **Spring里面 CGLib和JDK动态代理区别、选择策略**
    动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理，解耦和易维护

    两种动态代理的区别：

    - JDK动态代理：要求目标对象实现一个接口，但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以用CGLib动态代理

    - CGLib动态代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展

    - JDK动态代理是自带的，CGlib需要引入第三方包

    - CGLib动态代理基于继承来实现代理，所以无法对final类、private方法和static方法实现代理

      

    Spring AOP中的代理使用的默认策略：

    - 如果目标对象实现了接口，则默认采用JDK动态代理
    - 如果目标对象没有实现接口，则采用CgLib进行动态代理
    - 如果目标对象实现了接扣，程序里面依旧可以指定使用CGlib动态代理

15. e

16. e

17. e

18. e

19. e

20. 

    

#### web

1. servlet的生命周期

   - 实例化->使用构造方法创建对象
   - 初始化->执行init方法：Servlet 的生命期中，仅执行一次 init() 方法，它是在服务器装入 Servlet 时执行的,即第一次访问这个Servlet才执行
   - 服务->执行service方法，service() 方法是 Servlet 的核心。每当一个客户请求一个HttpServlet 对象，该对象的service() 方法就要被调用
   - 销毁-> 执行destroy方法,destroy() 方法仅执行一次，即在服务器停止且卸装 Servlet 时执行该方法

2. Servlet API中forward()和redirect()的区别

   - 重定向会改变URL地址，请求转发不会改变URL地址
   - 重定向不可以使用多个作用域的内容，请求转发可以
   - 重定向可以用URL访问外部资源，请求转发只能跳转内部资源
   - 重定向会触发多次请求；转发的话只在内部跳转

3. Cookie和Session的区别和联系

   - cookie数据保存在客户端，session数据保存在服务端
   - cookie不是很安全，容易泄露，不能直接明文存储信息
   - Cookie大小和数量存储有限制

4. JDBC中的Statement 和PreparedStatement的区别

   - PreparedStatement在执行之前会进行预编译
   - 效率高于Statement,且能够有效防止SQL注入
   - PreparedStatement支持?占位符而不是直接拼接，提高可读性

5. 数据库连接池工作原理和优点

   - 先创建一定数量的连接对象存放在连接池
   - 需要使用连接对象的时候，从连接池中请求一个空闲的连接
   - 使用完毕之后，并不会把连接关闭，而是还给连接池
   - 优点：
     - 系统响应速度加快
     - 资源利用率高

6. 为什么要用连接池

   - 数据库建立Connection比较耗时，频繁的创建和释放连接引起的大量性能开销
   - 如果数据库连接得到重用，避免这些开销，也提高了系统稳定
   - 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用，对于业务请求处理而言，直接利用现有可用连接，缩减了系统整体响应时间
   - 统一的连接管理，避免数据库连接泄漏、超时占用等问题

7. ttp请求 get和post的区别

   - get是用来从服务器上获取数据，而post是用来向服务器上传递数据
   - get是不安全的，因为在传输过程中，数据被放在请求的URL中,post是放到body里面，对小白用户不可见
   - get传输的数据量小，主要是由于受URL长度的限制；post可以传输大量的数据，一般上传文件只能用post

8. 
   浏览器输入一个地址，到页面展示中间经历了哪些处理

   - 浏览器输入url, 解析url地址是否合法
   - 浏览器检查是否有缓存, 如果有直接显示。如果没有跳到第三步。
   - 在发送http请求前，需要域名解析（DNS解析），解析获取对应过的ip地址。
   - 浏览器向服务器发起tcp链接，完成tcp三次握手
   - 握手成功后，浏览器向服务器发送http请求
   - 服务器收到处理的请求，将数据返回至浏览器
   - 浏览器收到http响应。
   - 浏览器解析响应。如果响应可以缓存，则存入缓存
   - 浏览器进行页面渲染

9. 你知道HTTP有哪些状态码吗，列举下 

   - 200：成功

   - 302：重定向

   - 404：请求失败，基本都是路径拼接错误

   - 400：请求没有进入到后台服务里，比如http报文有问题

   - 502：无效的响应（基本上就是Tomcat没启好或者挂了）

10. 你知道http和https的区别

    - HTTPS = HTTP + SSL
    - https有ca证书，http一般没有
    - http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议
    - http默认80端口，https默认443端口。

11. 解决内网与外网之间的切换烦恼

    ```
    备注：
    公司内网 子网192.168.43.0
    剩余可分配ip地址 192.168.43.30 ~ 192.168.43.60
    
    内网网关ip地址：192.168.43.1
    外网路由器的子网 192.168.1.0
    网关ip地址：192.168.190.1
    ```
    
    
    
    ```
    第一步：先设置有线网卡的ip地址与网关，ip设置为192.168.43.30 ~ 192.168.43.60中的其中一个，网关192.168.43.1，子网掩码:255.255.255.0
    第二步：无线网卡的ip地址设置自动获取ip即可
    第三步：route delete 0.0.0.0 "删除所有0.0.0.0的路由"
    第四步：route add -p 0.0.0.0 mask 0.0.0.0 192.168.1.1 "添加0.0.0.0网络路由"
    第五步：route add -p 192.168.43.0 mask 255.255.255.0 192.168.43.1 "添加192.168.43.0网络路由"
    ```
    
    
    
12. e

13. e

    

#### 并发编程

##### 基础

1. **线程、进程、协程的区别**

   ```
   进程: 本质上是一个独立执行的程序，进程是操作系统进行资源分配和调度的基本概念，操作系统进行资源分配和调度的一个独立单位
   
   线程:是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程执行不同的任务，切换受系统控制。
   
   协程: 又称为微线程，是一种用户态的轻量级线程，协程不像线程和进程需要进行系统内核上的上下文切换，协程的上下文切换是由用户自己决定的，有自己的上下文，所以说是轻量级的线程，也称之为用户级别的线程就叫协程，一个线程可以多个协程,线程进程都是同步机制，而协程则是异步 
   Java的原生语法中并没有实现协程,目前python、Lua和GO等语言支持
   
   关系：一个进程可以有多个线程，它允许计算机同时运行两个或多个程序。线程是进程的最小执行单位，CPU的调度切换的是进程和线程，进程和线程多了之后调度会消耗大量的CPU，CPU上真正运行的是线程，线程可以对应多个协程
   ```

2. **协程对于多线程的优缺点**

   ```
   优点：
       非常快速的上下文切换，不用系统内核的上下文切换，减小开销
       单线程即可实现高并发，单核CPU可以支持上万的协程
       由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁
   缺点：
       协程无法利用多核资源，本质也是个单线程
       协程需要和进程配合才能运行在多CPU上
       目前java没成熟的第三方库，存在风险
       调试debug存在难度，不利于发现问题
   ```

3. **并发和并行的区别**

   ```
   并发 concurrency：
   一台处理器上同时处理任务, 这个同时实际上是交替处理多个任务，程序中可以同时拥有两个或者多个线程，当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行
   
   并行 parallellism：
       多个CPU上同时处理多个任务，一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行
           
   并发指在一段时间内宏观上去处理多个任务。  并行指同一个时刻，多个任务确实真的同时运行。    
   
   例子：
   并发是一心多用，听课和看电影，但是CPU大脑只有一个，所以轮着来
   并行：火影忍者中的影分身，有多个你出现，可以分别做不同的事情
   
   一个项目经理A和3个程序B C D的故事
   单线程
   并发：A给B讲完需求，B自己去实现，期间A继续给C和D讲，不用等待某个程序员去完成，期间项目经理没空闲下来
   并行：直接找3个项目经理分别分配给3个程序员
   ```

4. **java里面实现多线程有哪几种方式**

   - 继承Thread类

   - 实现Runnable接口

   - 通过Callable和FutureTask方式

     ```
     //创建callable接口的实现类，并实现call方法，结合FutureTask类包装Callable对象，实现多线程
     //优点：有返回值，拓展性也高
     ```

   - 通过线程池创建线程

     ```
     //自定义Runnable接口，实现run方法，创建线程池，调用执行方法并传入对象
     //优点：安全高性能，复用线程
     public class ThreadDemo4 implements Runnable {
     
         @Override
         public void run() {
             System.out.println("通过线程池+runnable实现多线程，名称："+Thread.currentThread().getName());
         }
     }
     
     
     public static void main(String[] args) {
             ExecutorService executorService = Executors.newFixedThreadPool(3);
     
             for(int i=0;i<10;i++){
                 executorService.execute(new ThreadDemo4());
             }
     
     
             System.out.println("主线程名称:"+Thread.currentThread().getName());
     
             //关闭线程池
             executorService.shutdown();
     }
     ```

5. **java线程常见的基本状态有哪些**

   ```
   JDK的线程状态分6种，JVM里面9种，我们一般说JDK的线程状态
   
   常见的5种状态
   
   创建(NEW): 生成线程对象，但是并没有调用该对象start(), new Thread()
   
   就绪(Runnable)：当调用线程对象的start()方法，线程就进入就绪状态，但是此刻线程调度还没把该线程设置为当前线程，就是没获得CPU使用权。   如果线程运行后，从等待或者睡眠中回来之后，也会进入就绪状态
       注意:有些文档把就绪和运行两种状态统一称为 “运行中”
   
   运行(Running)
       程序将处于就绪状态的线程设置为当前线程，即获得CPU使用权，这个时候线程进入运行状态，开始运行run里面的逻辑
   
   阻塞(Blocked)
       等待阻塞：进入该状态的线程需要等待其他线程作出一定动作(通知或中断)，这种状态的话CPU不会分配过来，他们需要被唤醒，可能也会无限等待下去。比如调用wait(状态就会变成WAITING状态)，也可能通过调用sleep(状态就会变成TIMED_WAITING), join或者发出IO请求，阻塞结束后线程重新进入就绪状态
       
       同步阻塞：线程在获取synchronized同步锁失败，即锁被其他线程占用，它就会进入同步阻塞状态
       
       备注：相关资料会用细分下面的状态
           等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
           超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回
       
   
   死亡(TERMINATED):一个线程run方法执行结束，该线程就死亡了，不能进入就绪状态
   ```

6. **多线程开发里面常用的API**

   ```
   sleep
       属于线程Thread的方法
       让线程暂缓执行，等待预计时间之后再恢复
       交出CPU使用权，不会释放锁
       进入阻塞状态TIME_WAITGING，睡眠结束变为就绪Runnable
       
   yield
       属于线程Thread的方法
       t1/t2/t3
       暂停当前线程的对象，去执行其他线程
       交出CPU使用权，不会释放锁，和sleep类似
       作用：让相同优先级的线程轮流执行，但是不保证一定轮流
       注意：不会让线程进入阻塞状态，直接变为就绪Runnable，只需要重新获得CPU使用权
       
       
   join  
       属于线程Thread的方法
       在主线程上运行调用该方法，会让主线程休眠，不会释放已经持有的对象锁
       让调用join方法的线程先执行完毕，在执行其他线程
       类似让救护车警车优先通过
       
   wait
       属于Object的方法
       当前线程调用对象的wait方法，会All唤醒，或者wait(timeout)时间自动唤醒
       
   notify
       属于Object的方法
       唤醒在对象监视器上等待的单个线程，选择是任意的
       
   notifyAll
       属于Object的方法
       唤醒在对象监视器上等待的全部线程
   ```
   
7. **在Java中可以有哪些方法来保证线程安全**

   ```
   加锁,比如synchronize/ReentrantLock
   使用volatile声明变量，轻量级同步，不能保证原子性(需要解释)
   使用线程安全类(原子类AtomicXXX，并发容器，同步容器 CopyOnWriteArrayList/ConcurrentHashMap等
   ThreadLocal本地私有变量/信号量Semaphore等
   ```

8. **volatile关键字**

   ```
   volatile是轻量级的synchronized，保证了共享变量的可见性，被volatile关键字修饰的变量，如果值发生了变化，其他线程立刻可见，避免出现脏读现象
   
   volatile：保证可见性，但是不能保证原子性
   synchronized：保证可见性，也保证原子性
   
   使用场景
   1、不能修饰写入操作依赖当前值的变量，比如num++、num=num+1,不是原子操作，肉眼看起来是，但是JVM字节码层面不止一步
   
   2、由于禁止了指令重排，所以JVM相关的优化没了，效率会偏弱
   ```

9. **为什么会出现脏读？**

   ```
   JAVA内存模型简称 JVM
   JMM规定所有的变量存在主内存，每个线程有自己的工作内存,线程对变量的操作都在工作内存中进行，不能直接对主内存就行操作
   
   使用volatile修饰变量
   每次读取前必须从主内存属性最新的值
   每次写需要立刻写到主内存中
   
   volatile关键字修修饰的变量随时看到的自己的最新值，假如线程1对变量v进行修改，那么线程2是可以马上看见
   ```

   ![image-20201107093745135](%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107093745135.png)

11. **什么是指令重排?**

    ```
    指令重排序分两类 编译器重排序和运行时重排序
    
    JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(不改变程序结果的前提)
    
    int a = 3 //1
    int b = 4 //2
    int c =5 //3 
    int h = a*b*c //4
    
    定义顺序 1,2,3,4
    计算顺序  1,3,2,4 和 2,1,3,4 结果都是一样
    
    虽然指令重排序可以提高执行效率，但是多线程上可能会影响结果，有什么解决办法？
    解决办法：内存屏障
    解释：内存屏障是屏障指令，使CPU对屏障指令之前和之后的内存操作执行结果的一种约束
    ```

12. **happens-before原则**

    ```
    先行发生原则，volatile的内存可见性就提现了该原则之一
    
    例子：
    //线程A操作
    int k = 1;
    
    //线程B操作
    int j = k;
    
    //线程C操作
    int k = 2
    
    分析：
    假设线程A中的操作“k=1”先行发生于线程B的操作“j=k”，那确定在线程B的操作执行后，变量j的值一定等于1，依据有两个：一是先行发生原则，“k=1”的结果可以被观察到；二是第三者线程C还没出现，线程A操作结束之后没有其他线程会修改变量k的值。
    
    但是考虑线程C出现了，保持线程A和线程B之间的先行发生关系，线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少？答案是1和2都有可能，因为线程C对变量k的影响可能会被线程B观察到，也可能不会，所以线程B就存在读取到不符合预期数据的风险，不具备多线程安全性
    
    八大原则
    1、程序次序规则
    2、管程锁定规则
    3、volatile变量规则
    4、线程启动规则
    5、线程中断规则
    6、线程终止规则
    7、对象终结规则
    8、传递性
    ```

12. **并发编程三要素**

    ```
    原子性:一个不可再被分割的颗粒，原子性指的是一个或多个操作要么全部执行成功要么全部执行失败，期间不能被中断，也不存在上下文切换，线程切换会带来原子性的问题
    
    有序性: 程序执行的顺序按照代码的先后顺序执行，因为处理器可能会对指令进行重排序
    JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(不改变程序结果的前提)
    
    可见性: 一个线程A对共享变量的修改,另一个线程B能够立刻看到
    ```

13. **进程和线程间的调度算法**

    ![image-20201107094651554](%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107094651554.png)

    ```
    先来先服务调度算法：
        按照作业/进程到达的先后顺序进行调度 ，即：优先考虑在系统中等待时间最长的作业
        排在长进程后的短进程的等待时间长，不利于短作业/进程
    
    短作业优先调度算法：
        短进程/作业（要求服务时间最短）在实际情况中占有很大比例，为了使得它们优先执行
        对长作业不友好
    
    高响应比优先调度算法: 
        在每次调度时，先计算各个作业的优先权：优先权=响应比=（等待时间+要求服务时间）/要求服务时间,
        因为等待时间与服务时间之和就是系统对该作业的响应时间，所以 优先权=响应比=响应时间/要求服务时间，选    择优先权高的进行服务需要计算优先权信息，增加了系统的开销
        
    
    时间片轮转调度算法:
        轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
        由于高频率的进程切换，会增加了开销，且不区分任务的紧急程度
    
    优先级调度算法:
        根据任务的紧急程度进行调度，高优先级的先处理，低优先级的慢处理
        如果高优先级任务很多且持续产生，那低优先级的就可能很慢才被处理
    ```

    ![image-20201107094736862](%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107094736862.png)

    ​	要求服务时间越短，优先级越高。

14. **常见的线程间的调度算法**

    ```
    线程调度是指系统为线程分配CPU使用权的过程，主要分两种
    
    协同式线程调度(分时调度模式)：线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里
    
    抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞
    
    Java线程调度就是抢占式调度,优先让可运行池中优先级高的线程占用CPU,如果可运行池中的线程优先级相同,那就随机选择一个线程
    
    所以我们如果希望某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。
    JAVA的线程的优先级，以1到10的整数指定。当多个线程可以运行时，VM一般会运行最高优先级的线程（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）
    
    在两线程同时处于就绪runnable状态时，优先级越高的线程越容易被系统选择执行。但是优先级并不是100%可以获得，只不过是机会更大而已。
    
    有人会说，wait,notify不就是线程本身控制吗？
    其实不是，wait是可以让出执行时间，notify后无法获取执行时间，随机等待队列里面获取而已
    ```

##### 并发编程进阶

1. **java里面中的锁**

   1. 悲观锁：

      当线程去操作数据的时候，总认为别的线程会去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞，比如synchronized

   2. 乐观锁：

      每次去拿数据的时候都认为别人不会修改，更新的时候会判断是别人是否回去更新数据，通过版本来判断，如果数据被修改了（根据version号检查是否被修改）就拒绝更新，比如CAS是乐观锁，但严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现，CAS不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响

      小结：悲观锁适合写操作多的场景，乐观锁适合读操作多的场景，乐观锁的吞吐量会比悲观锁多

   3. 公平锁：

      指多个线程按照申请锁的顺序来获取锁，简单来说 如果一个线程组里，能保证每个线程都能拿到锁 比如ReentrantLock(底层是同步队列FIFO:First Input First Output来实现)

   4. 非公平锁：

      获取锁的方式是随机获取的，保证不了每个线程都能拿到锁，也就是存在有线程饿死,一直拿不到锁，比如synchronized、ReentrantLock

      小结：非公平锁性能高于公平锁，更能重复利用CPU的时间

   5. 自旋锁：

      一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环,任何时刻最多只能有一个执行单元获得锁.
      小结：不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU
      常见的自旋锁：TicketLock,CLHLock,MSCLock

   6. 可重入锁：

      也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁

      ```
      可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁
      
       //不可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁
      
      public class ReentrantLock {
      
          private boolean isLocked = false;
      
          //用于记录是不是重入的线程
          private Thread lockedOwner = null;
      
          //累计加锁次数，加锁一次累加1，解锁一次减少1
          private int lockedCount = 0;
      
          public synchronized void lock() throws InterruptedException {
      
             System.out.println("进入lock加锁 "+Thread.currentThread().getName());
      
              Thread thread = Thread.currentThread();
      
              //判断是否是同个线程获取锁, 引用地址的比较
              while (isLocked && lockedOwner != thread ){
                  System.out.println("进入wait等待 "+Thread.currentThread().getName());
                  System.out.println("当前锁状态 isLocked = "+isLocked);
                  System.out.println("当前count数量 lockedCount =  "+lockedCount);
                  wait();
              }
      
              //进行加锁
              isLocked = true;
              lockedOwner = thread;
              lockedCount++;
          }
          public synchronized void unlock(){
              System.out.println("进入unlock解锁 "+Thread.currentThread().getName());
      
              Thread thread = Thread.currentThread();
      
              //线程A加的锁，只能由线程A解锁，其他线程B不能解锁
              if(thread == this.lockedOwner){
                  lockedCount--;
                  if(lockedCount == 0){
                      isLocked = false;
                      lockedOwner = null;
                      //唤醒对象锁池里面的一个线程
                      notify();
                  }
              }
          }
      }
      public class Main {
          //private UnreentrantLock unreentrantLock = new UnreentrantLock();
          private ReentrantLock reentrantLock = new ReentrantLock();
      
          //加锁建议在try里面，解锁建议在finally
          public void  methodA(){
      
              try {
                  reentrantLock.lock();
                  System.out.println("methodA方法被调用");
                  methodB();
      
              }catch (InterruptedException e){
                  e.fillInStackTrace();
      
              } finally {
                  reentrantLock.unlock();
              }
          }
          public void methodB(){
              try {
                  reentrantLock.lock();
                  System.out.println("methodB方法被调用");
      
              }catch (InterruptedException e){
                  e.fillInStackTrace();
      
              } finally {
                  reentrantLock.unlock();
              }
          }
      
          public static void main(String [] args){
              for(int i=0 ;i<10;i++){
                  //演示的是同个线程
                  new Main().methodA();
              }
          }
      }
      ```

      

   7. 不可重入锁：

      若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞

      可重入锁能一定程度的避免死锁 synchronized、ReentrantLock 重入锁

      ```
      public class UnreentrantLock {
      
          private boolean isLocked = false;
      
          public synchronized void lock() throws InterruptedException {
      
              System.out.println("进入lock加锁 "+Thread.currentThread().getName());
      
              //判断是否已经被锁，如果被锁则当前请求的线程进行等待
              while (isLocked){
                  System.out.println("进入wait等待 "+Thread.currentThread().getName());
                  wait();
              }
              //进行加锁
              isLocked = true;
          }
          public synchronized void unlock(){
              System.out.println("进入unlock解锁 "+Thread.currentThread().getName());
              isLocked = false;
              //唤醒对象锁池里面的一个线程
              notify();
          }
      }
      
      public class Main {
          private UnreentrantLock unreentrantLock = new UnreentrantLock();
          //加锁建议在try里面，解锁建议在finally
          public void  methodA(){
              try {
                  unreentrantLock.lock();
                  System.out.println("methodA方法被调用");
                  methodB();
              }catch (InterruptedException e){
                  e.fillInStackTrace();
              } finally {
                  unreentrantLock.unlock();
              }
          }
          public void methodB(){
              try {
                  unreentrantLock.lock();
                  System.out.println("methodB方法被调用");
              }catch (InterruptedException e){
                  e.fillInStackTrace();
              } finally {
                  unreentrantLock.unlock();
              }
          }
          public static void main(String [] args){
              //演示的是同个线程
              new Main().methodA();
          }
      }
      
      //同一个线程，重复获取锁失败，形成死锁，这个就是不可重入锁 private void meathA(){
                  //获取锁 TODO
              meathB();
          }
      
          private void meathB(){
                 //获取锁 TODO
                 //其他操作
          }
          
      //同一个线程，重复获取锁失败，形成死锁，这个就是不可重入锁
      ```

   8. 共享锁：

      也叫S锁/读锁，能查看但无法修改和删除的一种数据锁，加锁后其它用户可以并发读取、查询数据，但不能修改，增加，删除数据，该锁可被多个线程所持有，用于资源数据共享

   9. 互斥锁：

      也叫X锁/排它锁/写锁/独占锁/独享锁/ 该锁每一次只能被一个线程所持有,加锁后任何线程试图再次加锁的线程会被阻塞，直到当前线程解锁。例子：如果 线程A 对 data1 加上排他锁后，则其他线程不能再对 data1 加任何类型的锁,获得互斥锁的线程即能读数据又能修改数据

   10. 死锁：

       两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法让程序进行下去

       死锁的4个必要条件

       - 互斥条件：资源不能共享，只能由一个线程使用

       - 请求与保持条件：线程已经获得一些资源，但因请求其他资源发生阻塞，对已经获得的资源保持不释放

       - 不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强行回收，只能由线程使用完自己释放

       - 循环等待条件：多个线程形成环形链，每个都占用对方申请的下个资源

         只要发生死锁，上面的条件都成立；只要一个不满足，就不会发生死锁

       ```
       //死锁的例子:
       public class DeadLockDemo {
       
           private static String locka = "locka";
       
           private static String lockb = "lockb";
       
           public void methodA(){
       
               synchronized (locka){
                   System.out.println("我是A方法中获得了锁A "+Thread.currentThread().getName() );
       
                   //让出CPU执行权，不释放锁
                   try {
                       Thread.sleep(2000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
       
                   synchronized(lockb){
                       System.out.println("我是A方法中获得了锁B "+Thread.currentThread().getName() );
                   }
               }
       
           }
       
       
           public void methodB(){
               synchronized (lockb){
                   System.out.println("我是B方法中获得了锁B "+Thread.currentThread().getName() );
       
                   //让出CPU执行权，不释放锁
                   try {
                       Thread.sleep(2000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
       
                   synchronized(locka){
                       System.out.println("我是B方法中获得了锁A "+Thread.currentThread().getName() );
                   }
               }
           }
       
           public static void main(String [] args){
               System.out.println("主线程运行开始运行："+Thread.currentThread().getName());
       
               DeadLockDemo deadLockDemo = new DeadLockDemo();
       
               new Thread(()->{
                   deadLockDemo.methodA();
               }).start();
       
               new Thread(()->{
                   deadLockDemo.methodB();
               }).start();
       
               System.out.println("主线程运行结束："+Thread.currentThread().getName());
       
           }
       ```

       死锁解决办法：

       - 调整申请锁的范围
       - 调整申请锁的顺序

   11. 下面三种是Jvm为了提高锁的获取与释放效率而做的优化 针对Synchronized的锁升级，锁的状态是通过对象监视器在对象头中的字段来表明，是不可逆的过程，

       - 偏向锁：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，获取锁的代价更低，
       - 轻量级锁：当锁是偏向锁的时候，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，但不会阻塞，且性能会高点
       - 重量级锁：当锁为轻量级锁的时候，其他线程虽然是自旋，但自旋不会一直循环下去，当自旋一定次数的时候且还没有获取到锁，就会进入阻塞，该锁升级为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能也会降低-

   12. 分段锁、行锁、表锁

2. **对synchronized的了解**

   ```
   synchronized是解决线程安全的问题，常用在 同步普通方法、静态方法、代码块 中
   
   非公平、可重入
   
   每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出一个并唤醒，唤醒哪个线程是不确定的，不保证公平性
   
   两种形式：
   方法：生成的字节码文件中会多一个 ACC_SYNCHRONIZED 标志位，当一个线程访问方法时，会去检查是否存在ACC_SYNCHRONIZED标识，如果存在，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象，也叫隐式同步
   
   代码块：加了 synchronized 关键字的代码段，生成的字节码文件会多出 monitorenter 和 monitorexit 两条指令，每个monitor维护着一个记录着拥有次数的计数器, 未被拥有的monitor的该计数器为0，当一个线程获执行monitorenter后，该计数器自增1;当同一个线程执行monitorexit指令的时候，计数器再自减1。当计数器为0的时候,monitor将被释放.也叫显式同步
   
   两种本质上没有区别，底层都是通过monitor来实现同步, 只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成
   ```

   ```
   查看字节码 
   javac XXX.java
   javap -v XXX.class
   ```

   JVM中对象存在形式

   ![image-20201107154251100](%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107154251100.png)

3. **什么是CAS**

   ```
   全称是Compare And Swap，即比较再交换，是实现并发应用到的一种技术
   底层通过Unsafe类实现原子性操作操作包含三个操作数 —— 内存地址（V）、预期原值（A）和新值(B)。 
   如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 ，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。
   
   CAS这个是属于乐观锁，性能较悲观锁有很大的提高
   AtomicXXX 等原子类底层就是CAS实现，一定程度比synchonized好，因为后者是悲观锁
   ```

   ![image-20201107155044378](%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201107155044378.png)

4. **CAS会存在什么比较严重的问题?**

   ```
   1、自旋时间长CPU利用率增加，CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用
   
   2、存在ABA问题 
   ```

5. **ABA问题**

   ```
   如果一个变量V初次读取是A值，并且在准备赋值的时候也是A值，那就能说明A值没有被修改过吗？其实是不能的，因为变量V可能被其他线程改回A值，结果就是会导致CAS操作误认为从来没被修改过，从而赋值给V
   
   给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。
   在java5中，已经提供了AtomicStampedReference来解决问题，检查当前引用是否等于预期引用，其次检查当前标志是否等于预期标志，如果都相等就会以原子的方式将引用和标志都设置为新值
   ```

   ![image-20201107160211277](C:/Users/tarena/AppData/Roaming/Typora/typora-user-images/image-20201107160211277.png)

6. **ReentrantLock和synchronized使用的场景是什么，实现机制有什么不同**

   ```
   ReentrantLock和synchronized都是独占锁
   synchronized：
   1、是悲观锁会引起其他线程阻塞，java内置关键字，
   2、无法判断是否获取锁的状态，锁可重入、不可中断、只能是非公平
   3、加锁解锁的过程是隐式的,用户不用手动操作,优点是操作简单但显得不够灵活
   4、一般并发场景使用足够、可以放在被递归执行的方法上,且不用担心线程最后能否正确释放锁
   5、synchronized操作的应该是对象头中mark word，参考原先原理图片
   
   ReentrantLock：
   1、是个Lock接口的实现类，是悲观锁，
   2、可以判断是否获取到锁，可重入、可判断、可公平可不公平
   3、需要手动加锁和解锁,且 解锁的操作尽量要放在finally代码块中,保证线程正确释放锁
   4、在复杂的并发场景中使用在重入时要却确保重复获取锁的次数必须和重复释放锁的次数一样，否则可能导致 其他线程无法获得该锁。
   5、创建的时候通过传进参数true创建公平锁,如果传入
   ```

7. e

8. e

9. e

10. e

11. e

12. e

13. e

14. e

15. 



##### 并发编程底层原理

1. AQS

   ```
   它是一个Java提高的底层同步工具类，比如CountDownLatch、ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的
   ```

   

2. w

3. w

4. w

5. 



### MYSQL

- **mysql常用的功能索引有哪些分别在什么场景下使用**

  ![image-20201117142105960](%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/image-20201117142105960.png)

- **Mysql搭建数据库主从复制,会有同步延迟问题，怎么解决**

  - 硬件提升

  ```
  保证性能第一情况下，不能百分百解决主从同步延迟问题，只能增加缓解措施。
  现象：主从同步，大数据量场景下，会发现写入主库的数据，在从库没找到。
  原因：
  1、主从复制是单线程操作，当主库TPS高，产生的超过从库sql线程执行能力
  2、从库执行了大的sql操作，阻塞等待
  3、服务器硬件问题，如磁盘，CPU,还有网络延迟等
  解决办法：
  1、业务需要有一定的容忍度，程序和数据库直接增加缓存，降低读压力
  2、业务适合的话，写入主库后，再写缓存，读的时候可以读缓存，没命中再读从库
  3、读写分离，一主多从，分散主库和从库压力
  4、提高硬件配置，比如使用SSD固态硬盘、更好的CPU和网络
  5、进行分库分表，减少单机压力
  ```

  - 业务侧解决，比如核心业务强制走主库，结合缓存使用

- **Mysql主从复制数据一致性校验方案怎么做**

  ```
  Mysql主从复制是基于binlog复制，难免出现复制数据不一致的风险，引起用户数据访问前后不一致的风险所以要定期开展主从复制数据一致性的校验并修复，避免这些问题
  
  解决方案之一，使用Percona公司下的工具
  pt-table-checksum工具进行一致性校验
  
  原理：
  主库利用表中的索引，将表的数据切割成一个个chunk(块)，然后进行计算得到checksum值。从库也执相应的操作，并在从库上计算相同数据块的checksum，然后对比主从中各个表的checksum是否一致并存储到数据库，最后通过存储校验结果的表就可以判断出哪些表的数据不一致
  
  pt-table-sync(在从库执行)工具进行修复不一致数据，可以修复主从结构数据的不一致，也可以修复非主从结构数据表的数据不一致
  
  原理：在主库上执行数据的更改，再同步到从库上，不会直接更改成从的数据。在主库上执行更改是基于主库现在的数据，也不会更改主库上的数据，可以同步某些表或整个库的数据，但它不同步表结构、索引，只同步不一致的数据
  
  注意：
  默认主库要检查的表在从库都存在，并且同主库表有相同的表结构
  如果表中没有索引，pt-table-checksum将没法处理，一般要求最基本都要有主键索引
  pt-table-sync工具会修改数据，使用前最好备份下数据，防止误操作
  ```

  


##### jichu2

### Redis

### Nginx

##### 	基础

1. 什么是正向代理服务器和反向代理服务器？
   - 正向代理服务器
     - 客户端和目标服务器之间的服务器，客户端向代理发送一个请求指定目标服务器，然后代理向目标服务器请求并获得内容，并返回给客户端，平时说的代理服务器一般是正向代理服务器
     - 核心：用户知道自己访问的目标服务器
     - 场景：跳板机、访问原来无法访问的网站, 比如国外的一些站点
   - 
     - 反向代理服务器（Nginx）
       - 客户端和目标服务器之间的服务器，客户端向代理发送一个请求，然后代理向目标服务器请求并获得内容，并返回给客户端。反向代理隐藏了真实的服务器
       - 核心：客户端不知道要访问的目标服务器是哪台服务器，代理会根据一定的策略选择一个真实的服务器进行请求
       - 场景：访问淘宝，知道访问的域名是taobao.com， 但是后面提供数据的具体是什么域名或ip我们是不知道的

### Docker

### Es

### Dubbo

- **Dubbo的负载均衡策略有哪些？**
  主要有random（随机，这种是默认的负载均衡策略）、RoundRobin （轮询）、LeastActive
  （最少活跃数）、ConsistentHash（一致性hash）可以在暴露服务的时候使用loadbalance进行
  指定。
  - 随机：在一个截面上碰撞的概率高，调用量越大分布越均匀，而且按概率使用权重后也比较均
    匀，有利于动态调整提供者权重。
  - 轮询：存在慢的提供者累积请求的问题，一台机器很慢，但没挂，当请求轮询到那台机子就卡在
    那，久而久之，所有请求都卡在那台服务器上。
    最少活跃数：使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
  - 一致性hash：当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供
    者，不会引起剧烈变动。可以方便节点的增加及移除

- **Dubbo服务调用超时怎么办？**
  dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时
  时间时，就会有重复请求，此时在接口设计的时候，需要考虑接口的幂等性，避免重复调用导致
  出现脏数据。

### Linux

- **公司公网网站经常卡顿，经查有些ip对网站发起频繁访问，疑似被黑客攻击，请定位出问题，并解决**

  ```
  #!/bin/bash
  DATE=$(date +%d/%b/%Y:%H:%M)
  NGINX_PATH=/usr/local/nginx/logs/access.log
  
  #先tail防止文件过大，读取慢，数字可调整每分钟最大的访问量。awk不能直接过滤日志，因为包含特殊字符。
  
  ABNORMAL_IP=$(tail -n5000 ${NGINX_PATH} |grep $DATE |awk
  '{a[$1]++}END{for(i in a)if(a[i]>200)print i}')
  
  #执行防火墙
  if [ ! $ABNORMAL_IP ];then
  exit
  else
  for IP in $ABNORMAL_IP;
  do
  firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source
  address="${IP}" port protocol="tcp" port="80" reject" && firewall-cmd -
  -reload
  echo -e "${IP}\n"
  >>/usr/local/nginx/shell_script/nginx_firewall_result.txt
  done
  fi
  
  #查看防火墙规则
  #firewall-cmd --zone=public --list-rich-rules
  #放开防火墙对ip的限制
  #firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source
  address="${IP}" port protocol="tcp" port="80" accept" && firewall-cmd -
  -reload
  #如果未生效，编辑配置文件
  #vi /etc/firewalld/zones/public.xml
  #重启防火墙服务
  #systemctl restart firewalld.service
  ```

  

