<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发编程入门 | 如今听雨僧庐下</title><meta name="keywords" content="并发编程 jvm 设计模式"><meta name="author" content="Zyaire"><meta name="copyright" content="Zyaire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="java并发编程从入门到实战学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程入门">
<meta property="og:url" content="http://example.com/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="如今听雨僧庐下">
<meta property="og:description" content="java并发编程从入门到实战学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-11-18T06:46:21.000Z">
<meta property="article:modified_time" content="2021-06-03T06:35:35.548Z">
<meta property="article:author" content="Zyaire">
<meta property="article:tag" content="并发编程 jvm 设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-03 14:35:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tzki/tzki.github.io/css/pool.css"><link rel="stylesheet" href="css/background.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> HOME</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> ARTICLE</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> LABEL</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> CATEGORY</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> LINK</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard"><i class="fa-fw fa fa-paper-plane"></i><span> MESSAGEBOARD</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> ABOUT</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">如今听雨僧庐下</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> HOME</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> ARTICLE</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> LABEL</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> CATEGORY</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> LINK</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard"><i class="fa-fw fa fa-paper-plane"></i><span> MESSAGEBOARD</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> ABOUT</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">并发编程入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-18T06:46:21.000Z" title="发表于 2020-11-18 14:46:21">2020-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-03T06:35:35.548Z" title="更新于 2021-06-03 14:35:35">2021-06-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">Java</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="概念入门"><a href="#概念入门" class="headerlink" title="概念入门"></a>概念入门</h4><h5 id="什么是并发编程"><a href="#什么是并发编程" class="headerlink" title="什么是并发编程"></a>什么是并发编程</h5><ul>
<li><p>什么是并发编程</p>
<p>并发历史: 早期计算机–从头到尾执行一个程序，资源浪费 操作系统出现–计算机能运行多个程序，不同的程序在不同的单独的进程中运行</p>
</li>
</ul>
<p>一个进程，有多个线程 提高资源的利用率，公平</p>
<ul>
<li><p>串行与并行的区别</p>
<p>串行：洗茶具、打水、烧水、等水开、冲茶 并行：打水、烧水同时洗茶具、水开、冲茶</p>
<p>好处：可以缩短整个流程的时间</p>
</li>
<li><p>并发编程目的</p>
<p>摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。这一定律揭示了信息技术进步的速度。 让程序充分利用计算机资源 加快程序响应速度（耗时任务、web服务器） 简化异步事件的处理</p>
</li>
<li><p>什么时候适合使用并发编程</p>
<p>任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况 任务执行时间过长，可以划分为分工明确的子任务：比如分段下载 任务间断性执行：日志打印 任务本身需要协作执行：比如生产者消费者问题</p>
</li>
</ul>
<h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p><strong>什么是上下文切换</strong></p>
<ul>
<li>cpu为线程分配时间片，时间片非常短（毫秒级别），cpu不停的切换线程执行，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，让我们感觉是多个程序同时运行的。</li>
<li>上下文的频繁切换，会带来一定的性能开销</li>
</ul>
<p><strong>如何减少上下文切换的开销？</strong></p>
<ul>
<li><p>无锁并发编程</p>
<p>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据</p>
</li>
<li><p>CAS</p>
<p>Java的Atomic包使用CAS算法来更新数据，而不需要加锁。使用最少线程</p>
</li>
<li><p>使用最少线程。</p>
<p>避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态</p>
</li>
<li><p>协程</p>
<p>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。–GO语言比较多</p>
</li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><ul>
<li>好比打架互掐，揪头发，你不放过我，我也不饶你。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xdclass.synopsis;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 死锁Demo</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public class DeadLockDemo &#123;</span><br><span class="line">        private static final Object HAIR_A &#x3D; new Object();</span><br><span class="line">        private static final Object HAIR_B &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                synchronized (HAIR_A) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(50L);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    synchronized (HAIR_B) &#123;</span><br><span class="line">                        System.out.println(&quot;A成功的抓住B的头发&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                synchronized (HAIR_B) &#123;</span><br><span class="line">                    synchronized (HAIR_A) &#123;</span><br><span class="line">                        System.out.println(&quot;B成功抓到A的头发&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>jps 查看pid      jstack+pid查看进程</p>
<p>或者直接 jconsole 检测死锁查看</p>
</li>
</ul>
<h4 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h4><ul>
<li><p><strong>进程和线程的关系</strong></p>
<ul>
<li>进程：是系统进行分配和管理资源的基本单位</li>
<li>线程：进程的一个执行单元，是进程内调度的实体、是CPU调度和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程,线程是程序执行的最小单位。</li>
<li>一个程序至少一个进程，一个进程至少一个线程。</li>
<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。</li>
</ul>
<p>​     如何处理好同步与互斥是编写多线程程序的难点。 多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响， 而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题。</p>
</li>
<li><p><strong>状态及其相互转换</strong></p>
<ul>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。</li>
<li>阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。</li>
<li>等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，它可以在指定的时间内自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ul>
</li>
<li><p><strong>创建线程都方式</strong></p>
<ul>
<li>继承Thread，并重写父类的run方法</li>
<li>实现Runable接口，并实现run方法</li>
<li>使用匿名内部类</li>
<li>Lambda表达式</li>
<li>线程池</li>
</ul>
</li>
<li><p><strong>线程的挂起和恢复</strong></p>
<ul>
<li><p><strong>什么是挂起线程？</strong></p>
<p> 线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。 在线程挂起后，可以通过重新唤醒线程来使之恢复运行</p>
</li>
<li><p><strong>为什么要挂起线程？</strong></p>
<p>cpu分配的时间片非常短、同时也非常珍贵。避免资源的浪费。</p>
</li>
<li><p><strong>如何挂起线程？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">被废弃的方法 thread.suspend() </span><br><span class="line">	该方法不会释放线程所占用的资源。如果使用该方法将某个线程挂起，则可能会使其他等待资源的线程死锁 </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread.resume() 方法</span><br><span class="line">本身并无问题，但是不能独立于suspend()方法存在 </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以使用的方法 ：</span><br><span class="line">wait() 暂停执行、放弃已经获得的锁、进入等待状态</span><br><span class="line">notify() 随机唤醒一个在等待锁的线程</span><br><span class="line">notifyAll() 唤醒所有在等待锁的线程，自行抢占cpu资源</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>什么时候适合使用挂起线程？</strong></p>
<p>我等的船还不来(等待某些未就绪的资源)，我等的人还不明白。直到notify方法被调用</p>
</li>
</ul>
</li>
<li><p><strong>线程的中断操作</strong></p>
<ul>
<li>stop() 废弃方法，开发中不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线程安全性问题</li>
<li>Thread.interrupt方法</li>
<li>自行定义一个标志，用来判断是否继续执行</li>
</ul>
</li>
<li><p><strong>线程的优先级</strong></p>
<ul>
<li><p>线程的优先级告诉程序该线程的重要程度有多大。如果有大量线程都被堵塞，都在等候运行，程序会尽可能地先运行优先级的那个线程。 但是，这并不表示优先级较低的线程不会运行。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。</p>
</li>
<li><p>线程的优先级设置可以为1-10的任一数值，Thread类中定义了三个线程优先级，分别是：MIN_PRIORITY（1）、NORM_PRIORITY（5）、MAX_PRIORITY（10），一般情况下推荐使用这几个常量，不要自行设置数值。</p>
</li>
<li><p>不同平台，对线程的优先级的支持不同。 编程的时候，不要过度依赖线程优先级，如果你的程序运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确</p>
</li>
<li><p>任务：</p>
<p>快速处理：设置高的优先级 慢慢处理：设置低的优先级</p>
</li>
</ul>
</li>
<li><p><strong>守护线程</strong></p>
<ul>
<li><p>线程分类：用户线程、守护线程 </p>
<p>守护线程：任何一个守护线程都是整个程序中所有用户线程的守护者，只要有活着的用户线程，守护线程就活着。当JVM实例中最后一个非守护线程结束时，也随JVM一起退出</p>
</li>
<li><p>守护线程的用处：jvm垃圾清理线程</p>
</li>
<li><p>建议： 尽量少使用守护线程，因其不可控，不要在守护线程里去进行读写操作、执行计算逻辑</p>
</li>
</ul>
</li>
</ul>
<h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞"></a>起飞</h3><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><h5 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h5><ul>
<li><p>当多个线程访问某个类,不管运行时环境采用何种调度方式或者这些线程如何交替执行,并且在主调代码中不需要任何额外的同步或协同,这个类都能表现出正确的行为,那么就称这个类为线程安全的。—-《并发编程实战》</p>
</li>
<li><p><strong>什么是线程不安全？</strong></p>
<p>多线程并发访问时，得不到正确的结果。</p>
</li>
</ul>
<h5 id="从字节码角度分析线程不安全操作"><a href="#从字节码角度分析线程不安全操作" class="headerlink" title="从字节码角度分析线程不安全操作"></a>从字节码角度分析线程不安全操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -encoding UTF-8  指定字节码编译</span><br><span class="line">javap -c 反编译</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="image-20201118170522642"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: getstatic     #2               获取指定类的静态域，并将其押入栈顶</span><br><span class="line">3: iconst_1						 将int型1押入栈顶</span><br><span class="line">4: iadd							 将栈顶两个int型相加，将结果押入栈顶</span><br><span class="line">5: putstatic     #2               为指定类静态域赋值</span><br><span class="line">8: return</span><br></pre></td></tr></table></figure>

<p>注意：究极原因++操作不是原子操作</p>
<h5 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h5><ul>
<li><p><strong>什么是原子性操作</strong></p>
<p>一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。（和mysql事务里的原子性感觉相差无几，要么都成功，要么都失败）</p>
</li>
<li><p><strong>如何变成原子操作</strong></p>
<ul>
<li>volatile关键字只能保证可见性，不能保证原子性</li>
<li>synchronized关键字可以保证原子性</li>
</ul>
</li>
</ul>
<h5 id="简单理解synchronized"><a href="#简单理解synchronized" class="headerlink" title="简单理解synchronized"></a>简单理解synchronized</h5><ul>
<li><p>内置锁</p>
<pre><code>        每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</code></pre>
</li>
<li><p>互斥锁</p>
<pre><code>    内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</code></pre>
</li>
<li><p>synchronized用法：</p>
<p>​    修饰普通方法：锁住对象的实例，不同对象不会竞争锁<br>​    修饰静态方法：锁住整个类，不同对象会竞争锁<br>​    修饰代码块： 锁住一个对象 synchronized (lock) 即synchronized后面括号里的内容</p>
</li>
</ul>
<h5 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h5><ul>
<li>能且仅能修饰变量</li>
<li>保证该变量的可见性，volatile关键字仅仅保证可见性，并不保证原子性</li>
<li>禁止指令重排序</li>
<li>A、B两个线程同时读取volatile关键字修饰的对象，A读取之后，修改了变量的值,修改后的值，对B线程来说，是可见</li>
<li>使用场景 1：作为线程开关 2：单例，修饰对象实例，禁止指令重排序</li>
</ul>
<h5 id="单例与线程安全"><a href="#单例与线程安全" class="headerlink" title="单例与线程安全"></a>单例与线程安全</h5><ul>
<li><p>饿汉式–本身线程安全</p>
<p>在类加载的时候，就已经进行实例化，无论之后用不用到。如果该类比较占内存，之后又没用到，就白白浪费了资源。</p>
</li>
<li><p>懒汉式 – 最简单的写法是非线程安全的，在需要的时候再实例化</p>
</li>
</ul>
<h5 id="避免线程安全性问题"><a href="#避免线程安全性问题" class="headerlink" title="避免线程安全性问题"></a>避免线程安全性问题</h5><ul>
<li><p>线程安全性问题成因</p>
<ul>
<li>多线程环境</li>
<li>多个线程操作同一共享资源</li>
<li>对该共享资源进行了非原子性操作</li>
</ul>
</li>
<li><p>如何避免<br>打破成因中三点任意一点</p>
<ul>
<li>多线程环境–将多线程改单线程（必要的代码，加锁访问）</li>
<li>多个线程操作同一共享资源–不共享资源（ThreadLocal、不共享、操作无状态化、不可变——比如final修饰）</li>
<li>对该共享资源进行了非原子性操作– 将非原子性操作改成原子性操作（加锁、使用JDK自带的原子性操作的类、JUC提供的相应的并发工具类）</li>
</ul>
</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h5><ul>
<li>自旋锁： 线程状态及上下文切换消耗系统资源，当访问共享资源的时间短，频繁上下文切换不值得。jvm实现，使线程在没获得锁的时候，不被挂起，转而执行空循环，循环几次之后，如果还没能获得锁，则被挂起</li>
<li>阻塞锁：阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态</li>
<li>重入锁:支持线程再次进入的锁,就跟我们有房间钥匙，可以多次进入房间类似</li>
<li>读写锁： 两把锁，读锁跟写锁，写写互斥、读写互斥、读读共享</li>
<li>互斥锁： 上厕所，进门之后就把门关了，不让其他人进来</li>
<li>悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁</li>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。（mysql的version机制）</li>
<li>公平锁：大家都老老实实排队，对大家而言都很公平</li>
<li>非公平锁：一部分人排着队，但是新来的可能插队</li>
<li>偏向锁：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</li>
<li>独占锁：独占锁模式下，每次只能有一个线程能持有锁</li>
<li>共享锁：允许多个线程同时获取锁，并发访问共享资源</li>
</ul>
<h5 id="深入理解lock接口"><a href="#深入理解lock接口" class="headerlink" title="深入理解lock接口"></a>深入理解lock接口</h5><ul>
<li><p>lock的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock mylock &#x3D; new ReentrantLock();</span><br><span class="line">&#x2F;&#x2F;手动加锁</span><br><span class="line">mylock.lock();</span><br><span class="line">&#x2F;&#x2F;手动解锁</span><br><span class="line">mylock.unlock();</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized和lock锁的区别</p>
<ul>
<li><p>lock 获取锁与释放锁的过程，都需要程序员手动的控制 </p>
</li>
<li><p>Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作 </p>
</li>
<li><p>synchronized托管给jvm执行 原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。</p>
</li>
</ul>
</li>
<li><p>lock实现类</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB" alt="image-20201118192050223"></p>
</li>
<li><p>lock里的方法</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/lock%E7%9A%84%E6%96%B9%E6%B3%95" alt="image-20201118192222720"></p>
</li>
</ul>
<h5 id="写一个锁"><a href="#写一个锁" class="headerlink" title="写一个锁"></a>写一个锁</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package net.zyaire.lock.mylock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isHoldLock &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private Thread holdLockThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private int reentryCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 同一时刻，能且仅能有一个线程获取到锁，</span><br><span class="line">     * 其他线程，只能等待该线程释放锁之后才能获取到锁</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void lock() &#123;</span><br><span class="line">        if (isHoldLock &amp;&amp; Thread.currentThread() !&#x3D; holdLockThread) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        holdLockThread &#x3D; Thread.currentThread();</span><br><span class="line">        isHoldLock &#x3D; true;</span><br><span class="line">        reentryCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void unlock() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断当前线程是否是持有锁的线程，是，重入次数减去1，不是就不做处理</span><br><span class="line">        if (Thread.currentThread() &#x3D;&#x3D; holdLockThread) &#123;</span><br><span class="line">            reentryCount--;</span><br><span class="line">            if (reentryCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                isHoldLock &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="浅入AQS"><a href="#浅入AQS" class="headerlink" title="浅入AQS"></a>浅入AQS</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/AQS%E7%9A%84public%E6%96%B9%E6%B3%95" alt="image-20201118194744682"></p>
<ul>
<li><p>主要方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  acqiure(相当于加锁)</span><br><span class="line">  release(相当于释放锁)</span><br><span class="line">addwaiter(加入等待队列)</span><br><span class="line">  isHeldExclusively(是否是独占锁)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="Reentrantlock非公平锁"><a href="#Reentrantlock非公平锁" class="headerlink" title="Reentrantlock非公平锁"></a>Reentrantlock非公平锁</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="ReentranLock非公平和公平锁的实现"></p>
<ul>
<li><p><strong>lock()</strong></p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%8A%A0%E9%94%81.png" alt="ReentranLock加锁"></p>
<p>1.进入aquire（）</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%85%AC%E5%B9%B3%E9%94%81aquire%E9%80%BB%E8%BE%91.png" alt="ReentranLock公平锁aquire逻辑"></p>
<ul>
<li>tryaquire(arg)尝试获得锁，aquireQueued（）加入等待队列。</li>
<li>假如既没有获得锁成功，也没有成功假如等待队列，就会执行selfInterrupt（）方法；</li>
</ul>
<p>2.进入selfInterrupt（），调用的是线程的interrupt（）方法</p>
<p>3.tryAquire()逻辑，具体实现在其子类NonfairSync（）实现</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/Reentranlock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0.png" alt="Reentranlock非公平锁加锁具体实现"></p>
<p>注意是compareAndSetState(0, acquires)进行都操作，即是CAS操作</p>
<p>4.加入队列的操作</p>
<p>//TODO</p>
</li>
<li><p><strong>unlock()</strong></p>
</li>
</ul>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E8%A7%A3%E9%94%81%E9%80%BB%E8%BE%91.png" alt="ReentranLock解锁逻辑"></p>
<ol>
<li><p>进入release()</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E9%87%8A%E6%94%BE%E9%94%81.png" alt="ReentranLock释放锁"></p>
<p>首先会tryRelease()，成功会唤起等待队列里面的线程</p>
</li>
<li><p>tryRelease()逻辑</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/tryRelease%E9%80%BB%E8%BE%91" alt="image-20201119160236412"></p>
</li>
</ol>
<h5 id="Reentrantlock公平锁"><a href="#Reentrantlock公平锁" class="headerlink" title="Reentrantlock公平锁"></a>Reentrantlock公平锁</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ReentranLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81" alt="image-20201119163132797"></p>
<h5 id="如何多线程debug"><a href="#如何多线程debug" class="headerlink" title="如何多线程debug"></a>如何多线程debug</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug" alt="image-20201119164635268"></p>
<h5 id="读写锁ReentrantReadlock"><a href="#读写锁ReentrantReadlock" class="headerlink" title="读写锁ReentrantReadlock"></a>读写锁ReentrantReadlock</h5><ul>
<li><strong>readLock（）</strong></li>
</ul>
<p><strong>lock操作</strong></p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/readLock()" alt="image-20201119172020524"></p>
<p>读锁具体实现之tryAcquireShared（）</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81%E5%86%99%E9%94%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" alt="image-20201119180216772"></p>
<p>读锁具体实现之doAcquireShared（）</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81doAcquire" alt="image-20201119181023428"></p>
<p><strong>unlock操作</strong></p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AF%BB%E5%86%99%E9%94%81releaseShared" alt="image-20201119181411049"></p>
<ul>
<li><h5 id="unLock（）-TODO"><a href="#unLock（）-TODO" class="headerlink" title="unLock（）//TODO"></a>unLock（）//TODO</h5><p>ps：差不多一样，更简单。</p>
</li>
</ul>
<h5 id="解密AQS如何用单一int值表示读写两种状态"><a href="#解密AQS如何用单一int值表示读写两种状态" class="headerlink" title="解密AQS如何用单一int值表示读写两种状态"></a>解密AQS如何用单一int值表示读写两种状态</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int 是32位，将其拆分成两个无符号short</span><br><span class="line">    高位表示读锁          低位表示写锁</span><br><span class="line">    0000000000000000   0000000000000000</span><br><span class="line"></span><br><span class="line">两种锁的最大次数均为65535也即是2的16次方减去1</span><br><span class="line">    读锁： 每次都从当前的状态加上65536</span><br><span class="line">    0000000000000000   0000000000000000</span><br><span class="line">    ‭0000000000000001   0000000000000000‬</span><br><span class="line">    -----------------------------------</span><br><span class="line">    0000000000000001   0000000000000000‬</span><br><span class="line">    0000000000000001   0000000000000000‬</span><br><span class="line">    -----------------------------------</span><br><span class="line">    0000000000000010   0000000000000000‬</span><br><span class="line"></span><br><span class="line">    获取读锁个数，将state整个无符号右移16位就可得出读锁的个数</span><br><span class="line">                       0000000000000001 </span><br><span class="line"></span><br><span class="line">    写锁：每次都直接加1</span><br><span class="line">    0000000000000000   0000000000000000</span><br><span class="line">    0000000000000000   0000000000000001</span><br><span class="line">    -----------------------------------</span><br><span class="line">    0000000000000000   0000000000000001</span><br><span class="line"></span><br><span class="line">    获取写锁的个数</span><br><span class="line">    0000000000000000   0000000000000001</span><br><span class="line">    ‭0000000000000000   1111111111111111‬   </span><br><span class="line">    ----------------------------------- </span><br><span class="line">    0000000000000000   0000000000000001</span><br></pre></td></tr></table></figure>

<h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><ul>
<li><p>锁降级：写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性。</p>
<p>注意点：锁降级之后，写锁并不会直接降级成读锁，不会随着读锁的释放而释放，因此需要显式地释放写锁</p>
</li>
<li><p>是否有锁升级？</p>
<p>在ReentrantReadWriteLock里面，不存在锁升级这一说法</p>
</li>
<li><p>锁降级的应用场景</p>
<p>用于对数据比较敏感，需要在对数据修改之后，获取到修改后的值，并进行接下来的其他操作</p>
</li>
</ul>
<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><ul>
<li><p><strong>1.8之前，锁已经那么多了，为什么还要有StampedLock？</strong></p>
<p>一般应用，都是读多写少，ReentrantReadWriteLock 因读写互斥，故读时阻塞写，因而性能上上不去。可能会使写线程饥饿</p>
</li>
<li><p>StampedLock的特点</p>
<p>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功； 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致； StampedLock是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁） 支持锁升级跟锁降级 可以乐观读也可以悲观读 使用有限次自旋，增加锁获得的几率，避免上下文切换带来的开销 乐观读不阻塞写操作，悲观读，阻塞写得操作</p>
</li>
<li><p>StampedLock的优点</p>
<p>相比于ReentrantReadWriteLock，吞吐量大幅提升</p>
</li>
<li><p>StampedLock的缺点</p>
<p>api相对复杂，容易用错 内部实现相比于ReentrantReadWriteLock复杂得多</p>
</li>
<li><p>StampedLock的原理</p>
<p>每次获取锁的时候，都会返回一个邮戳（stamp），相当于mysql里的version字段 释放锁的时候，再根据之前的获得的邮戳，去进行锁释放</p>
</li>
<li><p>使用stampedLock注意点</p>
<p>如果使用乐观读，一定要判断返回的邮戳是否是一开始获得到的，如果不是，要去获取悲观读锁，再次去读取</p>
<p>官方Demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * StampedLock Demo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StampedLockDemo &#123;</span><br><span class="line">    &#x2F;&#x2F; 成员变量</span><br><span class="line">    private double x, y;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 锁实例</span><br><span class="line">    private final StampedLock sl &#x3D; new StampedLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 排它锁-写锁（writeLock）</span><br><span class="line">    void move(double deltaX, double deltaY) &#123;</span><br><span class="line">        long stamp &#x3D; sl.writeLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            x +&#x3D; deltaX;</span><br><span class="line">            y +&#x3D; deltaY;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 乐观读锁</span><br><span class="line">    double distanceFromOrigin() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 尝试获取乐观读锁（1）</span><br><span class="line">        long stamp &#x3D; sl.tryOptimisticRead();</span><br><span class="line">        &#x2F;&#x2F; 将全部变量拷贝到方法体栈内（2）</span><br><span class="line">        double currentX &#x3D; x, currentY &#x3D; y;</span><br><span class="line">        &#x2F;&#x2F; 检查在（1）获取到读锁票据后，锁有没被其他写线程排它性抢占（3）</span><br><span class="line">        if (!sl.validate(stamp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果被抢占则获取一个共享读锁（悲观获取）（4）</span><br><span class="line">            stamp &#x3D; sl.readLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 将全部变量拷贝到方法体栈内（5）</span><br><span class="line">                currentX &#x3D; x;</span><br><span class="line">                currentY &#x3D; y;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 释放共享读锁（6）</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回计算结果（7）</span><br><span class="line">        return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用悲观锁获取读锁，并尝试转换为写锁</span><br><span class="line">    void moveIfAtOrigin(double newX, double newY) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里可以使用乐观读锁替换（1）</span><br><span class="line">        long stamp &#x3D; sl.readLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前点在原点则移动（2）</span><br><span class="line">            while (x &#x3D;&#x3D; 0.0 &amp;&amp; y &#x3D;&#x3D; 0.0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 尝试将获取的读锁升级为写锁（3）</span><br><span class="line">                long ws &#x3D; sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                &#x2F;&#x2F; 升级成功，则更新票据，并设置坐标值，然后退出循环（4）</span><br><span class="line">                if (ws !&#x3D; 0L) &#123;</span><br><span class="line">                    stamp &#x3D; ws;</span><br><span class="line">                    x &#x3D; newX;</span><br><span class="line">                    y &#x3D; newY;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 读锁升级写锁失败则释放读锁，显示获取独占写锁，然后循环重试（5）</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp &#x3D; sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁（6）</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><h5 id="wait，notify，notifyAll"><a href="#wait，notify，notifyAll" class="headerlink" title="wait，notify，notifyAll"></a>wait，notify，notifyAll</h5><ul>
<li><p>何时使用 在多线程环境下，有时候一个线程的执行，依赖于另外一个线程的某种状态的改变，这个时候，我们就可以使用wait与notify或者notifyAll</p>
</li>
<li><p>wait跟sleep的区别 wait会释放持有的锁，而sleep不会，sleep只是让线程在指定的时间内，不去抢占cpu的资源 注意点 wait notify必须放在同步代码块中, 且必须拥有当前对象的锁，即不能取得A对象的锁，而调用B对象的wait 哪个对象wait，就得调哪个对象的notify</p>
</li>
<li><p>notify跟notifyAll的区别</p>
<p>nofity随机唤醒一个等待的线程 notifyAll唤醒所有在该对象上等待的线程</p>
</li>
</ul>
<h5 id="等待通知经典模型之生产者消费者"><a href="#等待通知经典模型之生产者消费者" class="headerlink" title="等待通知经典模型之生产者消费者"></a>等待通知经典模型之生产者消费者</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="生产者消费者"></p>
<p>//TODO 代码太长</p>
<h5 id="使用管道流进行通信"><a href="#使用管道流进行通信" class="headerlink" title="使用管道流进行通信"></a>使用管道流进行通信</h5><ul>
<li><p>以内存为媒介，用于线程之间的数据传输。</p>
</li>
<li><p>主要有面向字节：【PipedOutputStream、PipedInputStream】、面向字符【PipedReader、PipedWriter】</p>
</li>
<li><p>reader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">public class Reader implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private PipedInputStream pipedInputStream;</span><br><span class="line"></span><br><span class="line">    public Reader(PipedInputStream pipedInputStream) &#123;</span><br><span class="line">        this.pipedInputStream &#x3D; pipedInputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (pipedInputStream !&#x3D; null) &#123;</span><br><span class="line">            String collect &#x3D; new BufferedReader(new InputStreamReader(pipedInputStream)).lines().collect(Collectors.joining(&quot;\n&quot;));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +collect);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            pipedInputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        PipedInputStream pipedInputStream &#x3D; new PipedInputStream();</span><br><span class="line">        PipedOutputStream pipedOutputStream &#x3D; new PipedOutputStream();</span><br><span class="line"></span><br><span class="line">        pipedOutputStream.connect(pipedInputStream);</span><br><span class="line"></span><br><span class="line">        new Thread(new Reader(pipedInputStream)).start();</span><br><span class="line">        BufferedReader bufferedReader &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bufferedReader &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            pipedOutputStream.write(bufferedReader.readLine().getBytes());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            pipedOutputStream.close();</span><br><span class="line">            if (bufferedReader !&#x3D; null) &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Thread-join（）方法"><a href="#Thread-join（）方法" class="headerlink" title="Thread.join（）方法"></a>Thread.join（）方法</h5><ul>
<li>使用场景：线程A执行到一半，需要一个数据，这个数据需要线程B去执行修改，只有B修改完成之后，A才能继续操作。线程A的run方法里面，调用线程B的join方法，这个时候，线程A会等待线程B运行完成之后，再接着运行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;开始运行&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;结束运行&quot;);</span><br><span class="line">        &#125;, &quot;线程1&quot;);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;开始运行&quot;);</span><br><span class="line">            thread.start();&#x2F;&#x2F;这里调用start,程序不会按预期进行</span><br><span class="line">            try &#123;</span><br><span class="line">&#x2F;&#x2F;调用join方法,结果:线程2开始---&gt;线程1开始---&gt;线程1结束----&gt;线程2结束</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;运行结束&quot;);</span><br><span class="line">        &#125;, &quot;线程2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join()方法可以传参，相当于wait()</p>
<h5 id="Threadlocal的使用"><a href="#Threadlocal的使用" class="headerlink" title="Threadlocal的使用"></a>Threadlocal的使用</h5><ul>
<li>线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。为每个线程单独存放一份变量副本，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。只要线程处于活动状态并且ThreadLocal实例可访问，那么每个线程都拥有对其本地线程副本的隐式引用变量一个线程消失后，它的所有副本线程局部实例受垃圾回收（除非其他存在对这些副本的引用）</li>
<li>一般用的比较多的是 <ul>
<li>ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。 </li>
<li>ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。 </li>
<li>ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。 </li>
<li>ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。</li>
</ul>
</li>
</ul>
<h5 id="condition的使用"><a href="#condition的使用" class="headerlink" title="condition的使用"></a>condition的使用</h5><ul>
<li>可以在一个锁里面，存在多种等待条件</li>
<li>主要的方法 await signal signalAll</li>
</ul>
<h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><ul>
<li><p>一度认为原子是不可分割的最小单位，故原子类可以认为其操作都是不可分割</p>
</li>
<li><p><strong>为什么要有原子类？</strong></p>
<p>对多线程访问同一个变量，我们需要加锁，而锁是比较消耗性能的，JDk1.5之后， 新增的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的.方式， 这些类同样位于JUC包下的atomic包下，发展到JDk1.8，该包下共有17个类， 囊括了原子更新基本类型、原子更新数组、原子更新属性、原子更新引用</p>
</li>
<li><p>1.8新增的原子类</p>
<p>DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder、Striped64</p>
</li>
</ul>
<h5 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h5><ul>
<li><p>发展至JDk1.8，基本类型原子类有以下几个：</p>
<p>AtomicBoolean、AtomicInteger、AtomicLong、DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p>
</li>
<li><p>大致可以归为3类</p>
<ul>
<li>AtomicBoolean、AtomicInteger、AtomicLong 元老级的原子更新，方法几乎一模一样 </li>
</ul>
<p><strong>AutomicInterger</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;初始化实例</span><br><span class="line">    private static AtomicInteger sum &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void inCreate() &#123;</span><br><span class="line">        sum.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 100; j++) &#123;</span><br><span class="line">                    inCreate();</span><br><span class="line">                    System.out.println(sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DoubleAdder、LongAdder 对Double、Long的原子更新性能进行优化提升 </li>
<li>DoubleAccumulator、LongAccumulator 支持自定义运算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;输入一个数字，如果比上一个输入的大，则直接返回，如果小，则返回上一个</span><br><span class="line">        LongAccumulator longAccumulator &#x3D; new LongAccumulator((left, right) -&gt;</span><br><span class="line">        &#x2F;&#x2F;可以自定义逻辑</span><br><span class="line">                left * right, 0L</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        longAccumulator.accumulate(3L);</span><br><span class="line">        System.out.println(longAccumulator.get());</span><br><span class="line">        longAccumulator.accumulate(5L);</span><br><span class="line">        System.out.println(longAccumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="原子更新数组类型"><a href="#原子更新数组类型" class="headerlink" title="原子更新数组类型"></a>原子更新数组类型</h5><ul>
<li><p>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * AtomicIntegerArray Demo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AtomicIntegerArrayDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;3, 2&#125;;</span><br><span class="line">        AtomicIntegerArray atomicIntegerArray &#x3D; new AtomicIntegerArray(arr);</span><br><span class="line">        System.out.println(atomicIntegerArray.addAndGet(1, 8));&#x2F;&#x2F;第一个入参是数组的下标，执行结果为10</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;自定义逻辑，支持lamada表达式</span><br><span class="line">        int i &#x3D; atomicIntegerArray.accumulateAndGet(0, 2, (left, right) -&gt;</span><br><span class="line">                left * right &#x2F; 3</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="原子地更新属性"><a href="#原子地更新属性" class="headerlink" title="原子地更新属性"></a>原子地更新属性</h5><ul>
<li><p>原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下4个类进行原子字段更新 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicStampedReference、AtomicReferenceFieldUpdater</p>
<p><strong>AtomicIntegerFieldUpdater</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicLongFieldUpdater;</span><br><span class="line">import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * AtomicLongFieldUpdaterDemo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AtomicLongFieldUpdaterDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicLongFieldUpdater&lt;Student&gt; longFieldUpdater &#x3D; AtomicLongFieldUpdater.newUpdater(Student.class, &quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        Student xdclass &#x3D; new Student(1L, &quot;xdclass&quot;);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F;第二个入参的是第几个字段,从1开始  </span><br><span class="line">        longFieldUpdater.compareAndSet(xdclass, 1L, 100L);</span><br><span class="line">        System.out.println(&quot;id&#x3D;&quot;+xdclass.getId());</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;第二个为要修改的类型，第三个为要修改的字段</span><br><span class="line">        AtomicReferenceFieldUpdater&lt;Student, String&gt; referenceFieldUpdater &#x3D; AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, &quot;name&quot;);</span><br><span class="line">        referenceFieldUpdater.compareAndSet(xdclass, &quot;xdclass&quot;, &quot;wiggin&quot;);</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+xdclass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;必须以volatile修饰，并且是基本数据类型，不能用包装类型</span><br><span class="line">    volatile long id;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    volatile String name;</span><br><span class="line"></span><br><span class="line">    public Student(Long id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用上述类的时候，必须遵循以下原则</span><br><span class="line">字段必须是volatile类型的，在线程之间共享变量时保证立即可见</span><br><span class="line">字段的描述类型是与调用者与操作对象字段的关系一致。</span><br><span class="line">也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。</span><br><span class="line">对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</span><br><span class="line">只能是实例变量，不能是类变量，也就是说不能加static关键字。</span><br><span class="line">只能是可修改变量，不能使final变量，因为final的语义就是不可修改。</span><br><span class="line">对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int&#x2F;long类型的字段，不能修改其包装类型（Integer&#x2F;Long）。</span><br><span class="line">如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h5><ul>
<li>AtomicReference：用于对引用的原子更新</li>
<li>AtomicMarkableReference：带版本戳的原子引用类型，版本戳为boolean类型。</li>
<li>AtomicStampedReference：带版本戳的原子引用类型，版本戳为int类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * AtomicReferenceDemo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AtomicReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicReference&lt;Student&gt; studentAtomicReference &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line">        Student student &#x3D; new Student(1L, &quot;xdclass&quot;);</span><br><span class="line">        Student student1 &#x3D; new Student(2L, &quot;wiggin&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果不先把要CAS的对象set进去的话,最后get会报空指针异常</span><br><span class="line">        studentAtomicReference.set(student);</span><br><span class="line">        studentAtomicReference.compareAndSet(student, student1);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;必需通过get获取CAS后的对象</span><br><span class="line">        Student student2 &#x3D; studentAtomicReference.get();</span><br><span class="line">        System.out.println(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(long id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="同步容器和并发容器"><a href="#同步容器和并发容器" class="headerlink" title="同步容器和并发容器"></a>同步容器和并发容器</h5><ul>
<li><p>同步容器</p>
<p>Vector、HashTable – JDK提供的同步容器类 Collections.synchronizedXXX 本质是对相应的容器进行包装</p>
</li>
<li><p>同步容器类的缺点</p>
<p>在单独使用里面的方法的时候，可以保证线程安全。但是，复合操作需要额外加锁来保证线程安全 使用Iterator迭代容器或使用for-each遍历容器，在迭代过程中修改容器会抛出ConcurrentModificationException异常。想要避免出现ConcurrentModificationException，就必须在迭代过程持有容器的锁。但是若容器较大，则迭代的时间也会较长。那么需要访问该容器的其他线程将会长时间等待。从而会极大降低性能。 </p>
<p>若不希望在迭代期间对容器加锁，可以使用”克隆”容器的方式。使用线程封闭，由于其他线程不会对容器进行修改，可以避免ConcurrentModificationException。但是在创建副本的时候，存在较大性能开销。 toString，hashCode，equalse，containsAll，removeAll，retainAll等方法都会隐式的Iterate，也即可能抛出ConcurrentModificationException。</p>
</li>
<li><p>并发容器</p>
<p>CopyOnWrite、Concurrent、BlockingQueue 根据具体场景进行设计，尽量避免使用锁，提高容器的并发访问性。</p>
<p> ConcurrentBlockingQueue：基于queue实现的FIFO的队列。队列为空，取操作会被阻塞 </p>
<p>ConcurrentLinkedQueue，队列为空，取得时候就直接返回空</p>
</li>
</ul>
<h5 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h5><ul>
<li><p>  public static void main(String[] args) {</p>
<pre><code>  Vector&lt;String&gt; stringVector = new Vector&lt;&gt;();
  for (int i = 0; i &lt; 1000; i++) &#123;
      stringVector.add(&quot;demo&quot; + i);
  &#125;

  //错误遍历
 stringVector.forEach(e-&gt;&#123;
     if (e.equals(&quot;demo3&quot;)) &#123;
         stringVector.remove(e);
     &#125;
     System.out.println(e);
 &#125;);

  //正确迭代
  Iterator&lt;String&gt; stringIterator = stringVector.iterator();
 while (stringIterator.hasNext()) &#123;
     String next = stringIterator.next();
     if (next.equals(&quot;demo2&quot;)) &#123;
         stringIterator.remove();
     &#125;
 &#125;

  //模拟多线程修改
  Iterator&lt;String&gt; stringIterator2 = stringVector.iterator();
  for (int i = 0; i &lt; 4; i++) &#123;
      new Thread(() -&gt; &#123;
          //不加synchronized会报错
          synchronized (stringIterator2) &#123;
              while (stringIterator2.hasNext()) &#123;
                  String next = stringIterator2.next();
                  if (next.equals(&quot;demo2&quot;)) &#123;
                      stringIterator2.remove();
                  &#125;
              &#125;
          &#125;
      &#125;).start();
  &#125;</code></pre>
<p>  }</p>
</li>
</ul>
<h5 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h5><pre><code>public static void main(String[] args) &#123;

    CopyOnWriteArrayList&lt;String&gt; strings = new CopyOnWriteArrayList&lt;&gt;();
    for (int i = 0; i &lt; 1000; i++) &#123;
        strings.add(&quot;demo&quot; + i);
    &#125;
    //不会报错
   strings.forEach(e-&gt;&#123;
       if (e.equals(&quot;demo2&quot;)) &#123;
           strings.remove(e);
       &#125;
   &#125;);
   //不支持在迭代器里直接remove的操作, 会直接报错
   Iterator&lt;String&gt; iterator = strings.iterator();
   while (iterator.hasNext()) &#123;
       String next = iterator.next();
       if (next.equals(&quot;demo2&quot;)) &#123;
           iterator.remove();
       &#125;
   &#125;

    //然鹅多线程修改并不会报错
    for (int i = 0; i &lt; 4; i++) &#123;
        new Thread(() -&gt; &#123;
            strings.forEach(e -&gt; &#123;
                if (e.equals(&quot;demo2&quot;)) &#123;
                    strings.remove(e);
                &#125;
            &#125;);
        &#125;).start();
    &#125;
&#125;</code></pre>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><ul>
<li><p>为什么用</p>
<p>在并发编程中，LinkedBlockingQueue使用的非常频繁。因其可以作为生产者消费者的中间商</p>
</li>
<li><p>常用方法</p>
<p>add  实际上调用的是offer，区别是在队列满的时候，add会报异常</p>
<p>offer  对列如果满了，直接入队失败</p>
</li>
</ul>
<p>  put(“111”); 在队列满的时候，会进入阻塞的状态  </p>
<p>  remove(); 直接调用poll，唯一的区别即使remove会抛出异常，而poll在队列为空的时候直接返回null<br>  poll(); 在队列为空的时候直接返回null<br>  take(); 在队列为空的时候，会进入等待的状态   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        LinkedBlockingQueue&lt;String&gt; strings &#x3D; new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;往队列里存元素</span><br><span class="line">        strings.add(&quot;111&quot;);</span><br><span class="line">        strings.offer(&quot;111&quot;);</span><br><span class="line">        strings.put(&quot;111&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;从队列中取元素</span><br><span class="line">        String remove &#x3D; strings.remove();</span><br><span class="line">        strings.poll();</span><br><span class="line">        strings.take();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h4><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><ul>
<li>await(),进入等待的状态</li>
<li>countDown(),计数器减一</li>
<li>应用场景：启动三个线程计算，需要对结果进行累加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(8);</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;800米比赛结束，准备清空跑道并继续跨栏比赛&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">            int finalI &#x3D; i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(finalI * 1000L);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;到达终点&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="CyclicBarrier–栅栏"><a href="#CyclicBarrier–栅栏" class="headerlink" title="CyclicBarrier–栅栏"></a>CyclicBarrier–栅栏</h5><ul>
<li><p>允许一组线程相互等待达到一个公共的障碍点，之后再继续执行</p>
</li>
<li><p>跟countDownLatch的区别</p>
<p>CountDownLatch一般用于某个线程等待若干个其他线程执行完任务之后，它才执行；不可重复使用 CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；可重用的</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xdclass.tool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(8);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">            int finalI &#x3D; i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(finalI * 1000L);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;准备就绪&quot;);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;开始比赛&quot;);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Semaphore–信号量"><a href="#Semaphore–信号量" class="headerlink" title="Semaphore–信号量"></a>Semaphore–信号量</h5><ul>
<li>控制并发数量</li>
<li>使用场景：接口限流</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                </span><br><span class="line">                	&#x2F;&#x2F;必须获得信号量才可以执行</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;开始执行&quot;);</span><br><span class="line">                    Thread.sleep(5000L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                	&#x2F;&#x2F;用完之后必须释放</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h5><ul>
<li>用于交换数据</li>
<li>它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger的重点是成对的线程使用exchange()方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是   <strong>成对</strong>   的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line">public class ExchangerDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;String&gt; stringExchanger &#x3D; new Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String str1 &#x3D; &quot;xdclass&quot;;</span><br><span class="line">        String str2 &#x3D; &quot;wiggin&quot;;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + str1);</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange &#x3D; stringExchanger.exchange(str1);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;交換后的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + str2);</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange &#x3D; stringExchanger.exchange(str2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;交換后的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程2&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新增一个线程执行exchange, 程序会一直卡着(必须要有一个线程的exchange和他匹配!!!)</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + str2);</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange &#x3D; stringExchanger.exchange(str2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;交換后的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程3&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池及Executor框架"><a href="#线程池及Executor框架" class="headerlink" title="线程池及Executor框架"></a>线程池及Executor框架</h4><h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">诸如 Web 服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务。请求以某种方式到达服务器，这种方式可能是通过网络协议（例如 HTTP、FTP ）、通过 JMS队列或者可能通过轮询数据库。不管请求如何到达，服务器应用程序中经常出现的情况是：单个任务处理的时间很短而请求的数目却是巨大的。每当一个请求到达就创建一个新线程，然后在新线程中为请求服务，但是频繁的创建线程，销毁线程所带来的系统开销其实是非常大的。</span><br><span class="line">线程池为线程生命周期开销问题和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。其好处是，因为在请求到达时线程已经存在，所以无意中也消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。而且，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。</span><br><span class="line">风险与机遇</span><br><span class="line">    用线程池构建的应用程序容易遭受任何其它多线程应用程序容易遭受的所有并发风险，</span><br><span class="line">    诸如同步错误和死锁，它还容易遭受特定于线程池的少数其它风险，诸如与池有关的死锁、资源不足和线程泄漏。</span><br></pre></td></tr></table></figure>

<h5 id="创建线程池及使用"><a href="#创建线程池及使用" class="headerlink" title="创建线程池及使用"></a>创建线程池及使用</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0" alt="image-20201120162227498"></p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E5%9B%BE%E7%A4%BA" alt="image-20201120162307754"></p>
<p>线程池的创建和使用</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BD%BF%E7%94%A8"></p>
<h5 id="Future与Callable、FutureTask"><a href="#Future与Callable、FutureTask" class="headerlink" title="Future与Callable、FutureTask"></a>Future与Callable、FutureTask</h5><ul>
<li>Callable与Runable功能相似，Callable的call有返回值，可以返回给客户端，而Runable没有返回值，一般情况下，Callable与FutureTask一起使用，或者通过线程池的submit方法返回相应的Future</li>
<li>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。get方法会阻塞，直到任务返回结果</li>
<li>FutureTask则是一个RunnableFuture，而RunnableFuture实现了Runnbale又实现了Futrue这两个接口</li>
</ul>
<p>FutureTask</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/FutureTask%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3" alt="image-20201120164134227"></p>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class CallableDemo implements Callable&lt;String&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(3000L);</span><br><span class="line">        return &quot;1111&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CallableDemo callableDemo &#x3D; new CallableDemo();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;callable的实现类不能直接使用</span><br><span class="line">        FutureTask&lt;String&gt; stringFutureTask &#x3D; new FutureTask&lt;&gt;(callableDemo);\</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;FutureTask实现了Rnnable接口</span><br><span class="line">        new Thread(stringFutureTask).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过get拿到返回值</span><br><span class="line">        System.out.println(stringFutureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程池核心组成部分"><a href="#线程池核心组成部分" class="headerlink" title="线程池核心组成部分"></a>线程池核心组成部分</h5><ul>
<li><p>构造参数</p>
<p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E5%9B%BE%E7%A4%BA" alt="image-20201120162307754"></p>
<ul>
<li>corePoolSize：核心线程池大小 cSize</li>
<li>maximumPoolSize：线程池最大容量 mSize</li>
<li>keepAliveTime：当线程数量大于核心时，多余的空闲线程在终止之前等待新任务的最大时间。</li>
<li>unit：时间单位</li>
<li>workQueue:工作队列 nWorks</li>
<li>ThreadFactory：线程工厂</li>
<li>handler：拒绝策略</li>
</ul>
</li>
<li><p>运行机制</p>
<p>通过new创建线程池时，除非调用prestartAllCoreThreads方法初始化核心线程，否则此时线程池中有0个线程，即使工作队列中存在多个任务，同样不会执行</p>
<p>任务数X</p>
<p>x &lt;= cSize(核心线程数) 只启动x个线程</p>
<p>x &gt;= cSize &amp;&amp; x &lt; nWorks(等待对列最大值) + cSize 会启动 &lt;= cSize 个线程 其他的任务就放到工作队列里</p>
<p>x &gt; cSize &amp;&amp; x &gt; nWorks + cSize</p>
<ul>
<li><p>x-(nWorks) &lt;= mSize 会启动x-(nWorks)个线程</p>
</li>
<li><p>x-(nWorks) &gt; mSize 会启动mSize个线程来执行任务，其余的执行相应的拒绝策略</p>
</li>
</ul>
</li>
</ul>
<h5 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h5><p><img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ExcutionHandler%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5" alt="image-20201120171650128"></p>
<ul>
<li><p>AbortPolicy：该策略直接抛出异常，阻止系统正常工作</p>
</li>
<li><p>CallerRunsPolicy：只要线程池没有关闭，该策略直接在调用者线程中，执行当前被丢弃的任务（叫老板帮你干活）</p>
</li>
<li><p>DiscardPolicy：直接啥事都不干，直接把任务丢弃</p>
</li>
<li><p>DiscardOldestPolicy：丢弃最老的一个请求（任务队列里面的第一个），再尝试提交任务</p>
</li>
<li><p>自定义handler</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">public class CustomPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送邮件告警</span><br><span class="line">        System.out.println(&quot;线程池满了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h5><p>总共六种    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Executor 框架Demo</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ExecutorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        ExecutorService executorService1 &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService &#x3D; Executors.newScheduledThreadPool(1);</span><br><span class="line">        ExecutorService executorService2 &#x3D; Executors.newWorkStealingPool();</span><br><span class="line">        ExecutorService executorService3 &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService1 &#x3D; Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;submit来使用线程池</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过相应的方法，能创建出6种线程池</p>
</li>
<li><p>上面的方法最终都创建了ThreadPoolExecutor</p>
<ul>
<li><p>newCachedThreadPool：创建一个可以根据需要创建新线程的线程池，如果有空闲线程，优先使用空闲的线程 </p>
</li>
<li><p>newFixedThreadPool：创建一个固定大小的线程池，在任何时候，最多只有N个线程在处理任务</p>
</li>
<li><p>newScheduledThreadPool：能延迟执行、定时执行的线程池 </p>
</li>
<li><p>newWorkStealingPool：工作窃取，使用多个队列来减少竞争 </p>
<p>通过new ForkJoinPool, 空闲队列窃取满队列任务</p>
</li>
<li><p>newSingleThreadExecutor：单一线程的线程次，只会使用唯一一个线程来执行任务，即使提交再多的任务，也都是会放到等待队列里进行等待 </p>
</li>
<li><p>newSingleThreadScheduledExecutor：单线程能延迟执行、定时执行的线程池</p>
</li>
</ul>
</li>
</ul>
<h5 id="线程池的使用建议"><a href="#线程池的使用建议" class="headerlink" title="线程池的使用建议"></a>线程池的使用建议</h5><ul>
<li><p>尽量避免使用Executor框架创建线程池</p>
<ul>
<li>newFixedThreadPool newSingleThreadExecutor 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </li>
<li>newCachedThreadPool newScheduledThreadPool 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</li>
</ul>
<p><strong>PS:</strong></p>
<p>创建线程时用的内存并不是我们制定jvm堆内存，而是系统的剩余内存。（电脑内存-系统其它程序占用的内存-已预留的jvm内存）</p>
</li>
<li><p>创建线程池时，核心线程数不要过大</p>
</li>
<li><p>相应的逻辑，发生异常时要处理</p>
</li>
<li><p>submit 如果发生异常，不会立即抛出，而是在get的时候，再抛出异常</p>
</li>
<li><p>execute 直接抛出异常</p>
</li>
</ul>
<h4 id="jvm与并发"><a href="#jvm与并发" class="headerlink" title="jvm与并发"></a>jvm与并发</h4><h5 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h5><ul>
<li><p>硬件内存模型</p>
<p>处理器—&gt;高速缓存—&gt;缓存一致性协议—&gt;主存</p>
</li>
<li><p>java内存模型</p>
<p>线程&lt;—&gt;工作内存&lt;—&gt;save和load &lt;—&gt;主存</p>
</li>
</ul>
<p>  <strong>硬件内存模型和java内存模型</strong></p>
<p>  <img src="/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="java内存模型"></p>
<ul>
<li><p><strong>java内存间的交互操作(八种)</strong></p>
<ul>
<li>lock(锁定)：作用于<strong>主内存的变量</strong>，把一个变量标记为一条线程独占状态 </li>
<li>unlock(解锁)：作用于<strong>主内存的变量</strong>，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 </li>
<li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 </li>
<li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 </li>
<li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 </li>
<li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 </li>
<li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 </li>
<li>write(写入)：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li>
</ul>
</li>
<li><p><strong>上面8中操作必须满足以下规则</strong>(8点)</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 </li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 </li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。 </li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 </li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 </li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 </li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 </li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
</li>
</ul>
<h5 id="Happens-before原则"><a href="#Happens-before原则" class="headerlink" title="Happens-before原则"></a>Happens-before原则</h5><ul>
<li><p>判断数据是有有竞争、线程是否安全的主要依据</p>
<ol>
<li>程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。</li>
<li>管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作</li>
<li>线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。</li>
<li>线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。</li>
<li>线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断</li>
<li>对象终结规则：一个对象的初始化完成先行于发生它的finalize（）方法的开始。</li>
<li>传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C。</li>
</ol>
</li>
<li><p><strong>为什么要有该原则？</strong></p>
<p> 无论jvm或者cpu，都希望程序运行的更快。如果两个操作不在上面罗列出来的规则里面，那么久可以对他们进行任意的重排序。</p>
</li>
<li><p>时间先后顺序与先行发生的顺序之间基本没有太大的关系。</p>
</li>
</ul>
<h5 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h5><ul>
<li><p>什么是指令重排序？</p>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
</li>
<li><p>数据依赖性</p>
<p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。）</p>
</li>
<li><p>两操作访问同一个变量，其两个操作中有至少一个写操作，此时就存在依赖性</p>
<p>写后读 a=0 b=a</p>
<p>读后写 a=b b=1</p>
<p>写后写 a=1 a=2 a=1,b=1</p>
<p>写后读 a=0 b=a 正确b=0 错误b=1</p>
</li>
<li><p>as-if-serial原则</p>
<p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HungerSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static HungerSingleton ourInstance &#x3D; new HungerSingleton();</span><br><span class="line"></span><br><span class="line">    public static HungerSingleton getInstance() &#123;</span><br><span class="line">        return ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private HungerSingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(HungerSingleton.getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断实例是否为空，为空则实例化</span><br><span class="line">        if (null &#x3D;&#x3D; lazySingleton) &#123;</span><br><span class="line">            &#x2F;&#x2F;模拟实例化时耗时的操作</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (LazySingleton.class) &#123;</span><br><span class="line">                if (null &#x3D;&#x3D; lazySingleton) &#123;</span><br><span class="line">                    lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则直接返回</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(LazySingleton.getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zyaire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/">http://example.com/2020/11/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">如今听雨僧庐下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-jvm-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">并发编程 jvm 设计模式</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98deomo/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">支付宝沙箱支付demo</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/13/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%B3%BB%E5%88%97/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mysql必知必会系列</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Zyaire</div><div class="author-info__description">除了技术菜，其他都还好。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B7%E6%AD%A5"><span class="toc-number">1.</span> <span class="toc-text">起步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">概念入门</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是并发编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">线程基础</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B7%E9%A3%9E"><span class="toc-number">2.</span> <span class="toc-text">起飞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">线程安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">什么是线程安全性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">从字节码角度分析线程不安全操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.3.</span> <span class="toc-text">原子性操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3synchronized"><span class="toc-number">2.1.4.</span> <span class="toc-text">简单理解synchronized</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.5.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text">单例与线程安全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.7.</span> <span class="toc-text">避免线程安全性问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">锁分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">深入理解lock接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E9%94%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">写一个锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%85%E5%85%A5AQS"><span class="toc-number">2.2.4.</span> <span class="toc-text">浅入AQS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reentrantlock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">2.2.5.</span> <span class="toc-text">Reentrantlock非公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reentrantlock%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">2.2.6.</span> <span class="toc-text">Reentrantlock公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug"><span class="toc-number">2.2.7.</span> <span class="toc-text">如何多线程debug</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadlock"><span class="toc-number">2.2.8.</span> <span class="toc-text">读写锁ReentrantReadlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unLock%EF%BC%88%EF%BC%89-TODO"><span class="toc-number">2.2.9.</span> <span class="toc-text">unLock（）&#x2F;&#x2F;TODO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86AQS%E5%A6%82%E4%BD%95%E7%94%A8%E5%8D%95%E4%B8%80int%E5%80%BC%E8%A1%A8%E7%A4%BA%E8%AF%BB%E5%86%99%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.10.</span> <span class="toc-text">解密AQS如何用单一int值表示读写两种状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">2.2.11.</span> <span class="toc-text">锁降级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StampedLock"><span class="toc-number">2.2.12.</span> <span class="toc-text">StampedLock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.3.</span> <span class="toc-text">线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#wait%EF%BC%8Cnotify%EF%BC%8CnotifyAll"><span class="toc-number">2.3.1.</span> <span class="toc-text">wait，notify，notifyAll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.3.2.</span> <span class="toc-text">等待通知经典模型之生产者消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E6%B5%81%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">2.3.3.</span> <span class="toc-text">使用管道流进行通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Thread-join%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">Thread.join（）方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Threadlocal%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.5.</span> <span class="toc-text">Threadlocal的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#condition%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.6.</span> <span class="toc-text">condition的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">原子更新基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">原子更新数组类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%9C%B0%E6%9B%B4%E6%96%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.3.</span> <span class="toc-text">原子地更新属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">原子更新引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%92%8C%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">同步容器和并发容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">同步容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">并发容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">2.5.4.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">2.6.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CyclicBarrier%E2%80%93%E6%A0%85%E6%A0%8F"><span class="toc-number">2.6.2.</span> <span class="toc-text">CyclicBarrier–栅栏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Semaphore%E2%80%93%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.6.3.</span> <span class="toc-text">Semaphore–信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Exchanger"><span class="toc-number">2.6.4.</span> <span class="toc-text">Exchanger</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8AExecutor%E6%A1%86%E6%9E%B6"><span class="toc-number">2.7.</span> <span class="toc-text">线程池及Executor框架</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.7.1.</span> <span class="toc-text">为什么要使用线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.2.</span> <span class="toc-text">创建线程池及使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Future%E4%B8%8ECallable%E3%80%81FutureTask"><span class="toc-number">2.7.3.</span> <span class="toc-text">Future与Callable、FutureTask</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">2.7.4.</span> <span class="toc-text">线程池核心组成部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">2.7.5.</span> <span class="toc-text">线程池拒绝策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Executor%E6%A1%86%E6%9E%B6"><span class="toc-number">2.7.6.</span> <span class="toc-text">Executor框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.7.7.</span> <span class="toc-text">线程池的使用建议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.8.</span> <span class="toc-text">jvm与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.8.1.</span> <span class="toc-text">jvm内存模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Happens-before%E5%8E%9F%E5%88%99"><span class="toc-number">2.8.2.</span> <span class="toc-text">Happens-before原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.8.3.</span> <span class="toc-text">指令重排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">懒汉式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">生产者消费者模型</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/17/Tengine/" title="Tengine"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tengine"/></a><div class="content"><a class="title" href="/2020/12/17/Tengine/" title="Tengine">Tengine</a><time datetime="2020-12-17T08:06:23.000Z" title="发表于 2020-12-17 16:06:23">2020-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/16/jmeter%E6%8E%A5%E5%8F%A3%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" title="jmeter接口压力测试"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jmeter接口压力测试"/></a><div class="content"><a class="title" href="/2020/12/16/jmeter%E6%8E%A5%E5%8F%A3%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" title="jmeter接口压力测试">jmeter接口压力测试</a><time datetime="2020-12-16T01:13:02.000Z" title="发表于 2020-12-16 09:13:02">2020-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Oracle学习笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Oracle学习笔记"/></a><div class="content"><a class="title" href="/2020/12/08/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Oracle学习笔记">Oracle学习笔记</a><time datetime="2020-12-08T00:59:37.000Z" title="发表于 2020-12-08 08:59:37">2020-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="java虚拟机"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java虚拟机"/></a><div class="content"><a class="title" href="/2020/11/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="java虚拟机">java虚拟机</a><time datetime="2020-11-21T01:18:57.000Z" title="发表于 2020-11-21 09:18:57">2020-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98deomo/" title="支付宝沙箱支付demo"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="支付宝沙箱支付demo"/></a><div class="content"><a class="title" href="/2020/11/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98deomo/" title="支付宝沙箱支付demo">支付宝沙箱支付demo</a><time datetime="2020-11-18T07:35:06.000Z" title="发表于 2020-11-18 15:35:06">2020-11-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Zyaire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'XPiuOvb6FBDdhlXIY8AiUKcT-gzGzoHsz',
      appKey: 'h5HoeqDOzslmWuc4Pd3qOsvt',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script></div></body></html>